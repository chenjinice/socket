// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vision.proto

#include "vision.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_vision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_AvailableArea_vision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_vision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_IllegalCarWarn2_vision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_vision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Obstacle_vision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_vision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Pedestrian_vision_2eproto;
namespace vision {
class PedestrianDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Pedestrian> _instance;
} _Pedestrian_default_instance_;
class ObstacleDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Obstacle> _instance;
} _Obstacle_default_instance_;
class AvailableAreaDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<AvailableArea> _instance;
} _AvailableArea_default_instance_;
class IllegalCarWarn2DefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IllegalCarWarn2> _instance;
} _IllegalCarWarn2_default_instance_;
class BaseDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Base> _instance;
} _Base_default_instance_;
class CrowdDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Crowd> _instance;
} _Crowd_default_instance_;
class ObstaclesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Obstacles> _instance;
} _Obstacles_default_instance_;
class AvailableAreasDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<AvailableAreas> _instance;
} _AvailableAreas_default_instance_;
class IllegalCarWarns2DefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IllegalCarWarns2> _instance;
} _IllegalCarWarns2_default_instance_;
class ThrowingObjDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ThrowingObj> _instance;
} _ThrowingObj_default_instance_;
class SeeingDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Seeing> _instance;
} _Seeing_default_instance_;
class SmokeWarnDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SmokeWarn> _instance;
} _SmokeWarn_default_instance_;
}  // namespace vision
static void InitDefaultsPedestrian_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_Pedestrian_default_instance_;
    new (ptr) ::vision::Pedestrian();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::Pedestrian::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Pedestrian_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsPedestrian_vision_2eproto}, {}};

static void InitDefaultsObstacle_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_Obstacle_default_instance_;
    new (ptr) ::vision::Obstacle();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::Obstacle::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Obstacle_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsObstacle_vision_2eproto}, {}};

static void InitDefaultsAvailableArea_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_AvailableArea_default_instance_;
    new (ptr) ::vision::AvailableArea();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::AvailableArea::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_AvailableArea_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsAvailableArea_vision_2eproto}, {}};

static void InitDefaultsIllegalCarWarn2_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_IllegalCarWarn2_default_instance_;
    new (ptr) ::vision::IllegalCarWarn2();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::IllegalCarWarn2::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_IllegalCarWarn2_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsIllegalCarWarn2_vision_2eproto}, {}};

static void InitDefaultsBase_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_Base_default_instance_;
    new (ptr) ::vision::Base();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::Base::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Base_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsBase_vision_2eproto}, {}};

static void InitDefaultsCrowd_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_Crowd_default_instance_;
    new (ptr) ::vision::Crowd();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::Crowd::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Crowd_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCrowd_vision_2eproto}, {
      &scc_info_Pedestrian_vision_2eproto.base,}};

static void InitDefaultsObstacles_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_Obstacles_default_instance_;
    new (ptr) ::vision::Obstacles();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::Obstacles::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Obstacles_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsObstacles_vision_2eproto}, {
      &scc_info_Obstacle_vision_2eproto.base,}};

static void InitDefaultsAvailableAreas_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_AvailableAreas_default_instance_;
    new (ptr) ::vision::AvailableAreas();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::AvailableAreas::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_AvailableAreas_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsAvailableAreas_vision_2eproto}, {
      &scc_info_AvailableArea_vision_2eproto.base,}};

static void InitDefaultsIllegalCarWarns2_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_IllegalCarWarns2_default_instance_;
    new (ptr) ::vision::IllegalCarWarns2();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::IllegalCarWarns2::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_IllegalCarWarns2_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsIllegalCarWarns2_vision_2eproto}, {
      &scc_info_IllegalCarWarn2_vision_2eproto.base,}};

static void InitDefaultsThrowingObj_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_ThrowingObj_default_instance_;
    new (ptr) ::vision::ThrowingObj();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::ThrowingObj::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_ThrowingObj_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsThrowingObj_vision_2eproto}, {
      &scc_info_Obstacle_vision_2eproto.base,}};

static void InitDefaultsSeeing_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_Seeing_default_instance_;
    new (ptr) ::vision::Seeing();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::Seeing::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Seeing_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsSeeing_vision_2eproto}, {}};

static void InitDefaultsSmokeWarn_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_SmokeWarn_default_instance_;
    new (ptr) ::vision::SmokeWarn();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::SmokeWarn::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_SmokeWarn_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsSmokeWarn_vision_2eproto}, {}};

void InitDefaults_vision_2eproto() {
  ::google::protobuf::internal::InitSCC(&scc_info_Pedestrian_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Obstacle_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_AvailableArea_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IllegalCarWarn2_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Base_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Crowd_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Obstacles_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_AvailableAreas_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IllegalCarWarns2_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ThrowingObj_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Seeing_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SmokeWarn_vision_2eproto.base);
}

static ::google::protobuf::Metadata file_level_metadata_vision_2eproto[12];
static const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors_vision_2eproto[2];
static constexpr ::google::protobuf::ServiceDescriptor const** file_level_service_descriptors_vision_2eproto = nullptr;

const ::google::protobuf::uint32 TableStruct_vision_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, object_id_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, object_type_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, x_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, y_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, camera_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, if_at_lane_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, lane_id_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, heading_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, object_id_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, x_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, y_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, camera_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, if_at_lane_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, lane_id_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, heading_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, object_id_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, x1_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, y1_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, x2_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, y2_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, camera_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, lane_id_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, heading_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, x3_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, y3_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, x4_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, y4_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  PROTOBUF_FIELD_OFFSET(::vision::IllegalCarWarn2, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::IllegalCarWarn2, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::IllegalCarWarn2, object_id_),
  PROTOBUF_FIELD_OFFSET(::vision::IllegalCarWarn2, x_),
  PROTOBUF_FIELD_OFFSET(::vision::IllegalCarWarn2, y_),
  PROTOBUF_FIELD_OFFSET(::vision::IllegalCarWarn2, camera_),
  PROTOBUF_FIELD_OFFSET(::vision::IllegalCarWarn2, lane_id_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::vision::Base, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::Base, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::Base, id_),
  0,
  PROTOBUF_FIELD_OFFSET(::vision::Crowd, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::Crowd, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::Crowd, id_),
  PROTOBUF_FIELD_OFFSET(::vision::Crowd, pedestrian_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::vision::Obstacles, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacles, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::Obstacles, id_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacles, obstacle_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::vision::AvailableAreas, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableAreas, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::AvailableAreas, id_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableAreas, area_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::vision::IllegalCarWarns2, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::IllegalCarWarns2, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::IllegalCarWarns2, id_),
  PROTOBUF_FIELD_OFFSET(::vision::IllegalCarWarns2, llegal_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::vision::ThrowingObj, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::ThrowingObj, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::ThrowingObj, id_),
  PROTOBUF_FIELD_OFFSET(::vision::ThrowingObj, array_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::vision::Seeing, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::Seeing, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::Seeing, id_),
  PROTOBUF_FIELD_OFFSET(::vision::Seeing, distance_),
  PROTOBUF_FIELD_OFFSET(::vision::Seeing, level_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::vision::SmokeWarn, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::SmokeWarn, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::SmokeWarn, id_),
  PROTOBUF_FIELD_OFFSET(::vision::SmokeWarn, warn_),
  0,
  1,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 13, sizeof(::vision::Pedestrian)},
  { 21, 33, sizeof(::vision::Obstacle)},
  { 40, 57, sizeof(::vision::AvailableArea)},
  { 69, 79, sizeof(::vision::IllegalCarWarn2)},
  { 84, 90, sizeof(::vision::Base)},
  { 91, 98, sizeof(::vision::Crowd)},
  { 100, 107, sizeof(::vision::Obstacles)},
  { 109, 116, sizeof(::vision::AvailableAreas)},
  { 118, 125, sizeof(::vision::IllegalCarWarns2)},
  { 127, 134, sizeof(::vision::ThrowingObj)},
  { 136, 144, sizeof(::vision::Seeing)},
  { 147, 154, sizeof(::vision::SmokeWarn)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_Pedestrian_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_Obstacle_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_AvailableArea_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_IllegalCarWarn2_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_Base_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_Crowd_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_Obstacles_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_AvailableAreas_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_IllegalCarWarns2_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_ThrowingObj_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_Seeing_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_SmokeWarn_default_instance_),
};

static ::google::protobuf::internal::AssignDescriptorsTable assign_descriptors_table_vision_2eproto = {
  {}, AddDescriptors_vision_2eproto, "vision.proto", schemas,
  file_default_instances, TableStruct_vision_2eproto::offsets,
  file_level_metadata_vision_2eproto, 12, file_level_enum_descriptors_vision_2eproto, file_level_service_descriptors_vision_2eproto,
};

const char descriptor_table_protodef_vision_2eproto[] =
  "\n\014vision.proto\022\006vision\"\236\001\n\nPedestrian\022\021\n"
  "\tobject_id\030\001 \002(\005\022!\n\013object_type\030\002 \002(\0162\014."
  "vision.TYPE\022\t\n\001x\030\003 \002(\005\022\t\n\001y\030\004 \002(\005\022\016\n\006cam"
  "era\030\005 \002(\005\022\022\n\nif_at_lane\030\006 \001(\005\022\017\n\007lane_id"
  "\030\007 \001(\005\022\017\n\007heading\030\010 \001(\005\"y\n\010Obstacle\022\021\n\to"
  "bject_id\030\001 \002(\005\022\t\n\001x\030\002 \002(\005\022\t\n\001y\030\003 \002(\005\022\016\n\006"
  "camera\030\004 \002(\005\022\022\n\nif_at_lane\030\005 \001(\005\022\017\n\007lane"
  "_id\030\006 \001(\005\022\017\n\007heading\030\007 \001(\005\"\264\001\n\rAvailable"
  "Area\022\021\n\tobject_id\030\001 \002(\005\022\n\n\002x1\030\002 \002(\005\022\n\n\002y"
  "1\030\003 \002(\005\022\n\n\002x2\030\004 \002(\005\022\n\n\002y2\030\005 \002(\005\022\016\n\006camer"
  "a\030\006 \002(\005\022\017\n\007lane_id\030\007 \001(\005\022\017\n\007heading\030\010 \001("
  "\005\022\n\n\002x3\030\t \002(\005\022\n\n\002y3\030\n \002(\005\022\n\n\002x4\030\013 \002(\005\022\n\n"
  "\002y4\030\014 \002(\005\"[\n\017IllegalCarWarn2\022\021\n\tobject_i"
  "d\030\001 \002(\005\022\t\n\001x\030\002 \002(\005\022\t\n\001y\030\003 \002(\005\022\016\n\006camera\030"
  "\004 \002(\005\022\017\n\007lane_id\030\005 \001(\005\"\036\n\004Base\022\026\n\002id\030\001 \002"
  "(\0162\n.vision.ID\"G\n\005Crowd\022\026\n\002id\030\001 \002(\0162\n.vi"
  "sion.ID\022&\n\npedestrian\030\002 \003(\0132\022.vision.Ped"
  "estrian\"G\n\tObstacles\022\026\n\002id\030\001 \002(\0162\n.visio"
  "n.ID\022\"\n\010obstacle\030\002 \003(\0132\020.vision.Obstacle"
  "\"M\n\016AvailableAreas\022\026\n\002id\030\001 \002(\0162\n.vision."
  "ID\022#\n\004area\030\002 \003(\0132\025.vision.AvailableArea\""
  "S\n\020IllegalCarWarns2\022\026\n\002id\030\001 \002(\0162\n.vision"
  ".ID\022\'\n\006llegal\030\002 \003(\0132\027.vision.IllegalCarW"
  "arn2\"F\n\013ThrowingObj\022\026\n\002id\030\001 \002(\0162\n.vision"
  ".ID\022\037\n\005array\030\002 \003(\0132\020.vision.Obstacle\"A\n\006"
  "Seeing\022\026\n\002id\030\001 \002(\0162\n.vision.ID\022\020\n\010distan"
  "ce\030\002 \002(\001\022\r\n\005level\030\003 \002(\005\"1\n\tSmokeWarn\022\026\n\002"
  "id\030\001 \002(\0162\n.vision.ID\022\014\n\004warn\030\002 \002(\010*\340\001\n\002I"
  "D\022\013\n\007DEFAULT\020\000\022\020\n\014PEDESTRIAN_D\020\001\022\016\n\nILLE"
  "GAL_V1\020\002\022\016\n\nCAMERA_CAL\020\003\022\016\n\nROCKFALL_D\020\004"
  "\022\014\n\010SEEING_D\020\005\022\022\n\016AVAILABLE_AREA\020\006\022\016\n\nOB"
  "STACLE_D\020\007\022\016\n\nILLEGAL_V2\020\010\022\022\n\016TRAFFIC_ST"
  "ATUS\020\t\022\024\n\020BACKWARD_DRIVING\020\n\022\017\n\013ROAD_DAN"
  "GER\020\013\022\016\n\nFIRE_SMOKE\020\014*:\n\004TYPE\022\n\n\006OTHERS\020"
  "\000\022\t\n\005HUMAN\020\001\022\013\n\007VEHICLE\020\002\022\016\n\nMOTORCYCLE\020"
  "\003"
  ;
static ::google::protobuf::internal::DescriptorTable descriptor_table_vision_2eproto = {
  false, InitDefaults_vision_2eproto, 
  descriptor_table_protodef_vision_2eproto,
  "vision.proto", &assign_descriptors_table_vision_2eproto, 1401,
};

void AddDescriptors_vision_2eproto() {
  static constexpr ::google::protobuf::internal::InitFunc deps[1] =
  {
  };
 ::google::protobuf::internal::AddDescriptors(&descriptor_table_vision_2eproto, deps, 0);
}

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_vision_2eproto = []() { AddDescriptors_vision_2eproto(); return true; }();
namespace vision {
const ::google::protobuf::EnumDescriptor* ID_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_vision_2eproto);
  return file_level_enum_descriptors_vision_2eproto[0];
}
bool ID_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TYPE_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_vision_2eproto);
  return file_level_enum_descriptors_vision_2eproto[1];
}
bool TYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void Pedestrian::InitAsDefaultInstance() {
}
class Pedestrian::HasBitSetters {
 public:
  static void set_has_object_id(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_object_type(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_x(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_y(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_camera(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_if_at_lane(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_lane_id(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_heading(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Pedestrian::kObjectIdFieldNumber;
const int Pedestrian::kObjectTypeFieldNumber;
const int Pedestrian::kXFieldNumber;
const int Pedestrian::kYFieldNumber;
const int Pedestrian::kCameraFieldNumber;
const int Pedestrian::kIfAtLaneFieldNumber;
const int Pedestrian::kLaneIdFieldNumber;
const int Pedestrian::kHeadingFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Pedestrian::Pedestrian()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.Pedestrian)
}
Pedestrian::Pedestrian(const Pedestrian& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&object_id_, &from.object_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&heading_) -
    reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
  // @@protoc_insertion_point(copy_constructor:vision.Pedestrian)
}

void Pedestrian::SharedCtor() {
  ::memset(&object_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&heading_) -
      reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
}

Pedestrian::~Pedestrian() {
  // @@protoc_insertion_point(destructor:vision.Pedestrian)
  SharedDtor();
}

void Pedestrian::SharedDtor() {
}

void Pedestrian::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Pedestrian& Pedestrian::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Pedestrian_vision_2eproto.base);
  return *internal_default_instance();
}


void Pedestrian::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.Pedestrian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&object_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&heading_) -
        reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Pedestrian::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_object_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required .vision.TYPE object_type = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::TYPE_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(2, val, mutable_unknown_fields());
          break;
        }
        set_object_type(static_cast<::vision::TYPE>(val));
        break;
      }
      // required int32 x = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_x(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 y = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        set_y(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 camera = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        set_camera(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 if_at_lane = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        set_if_at_lane(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_id = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        set_lane_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 heading = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 64) goto handle_unusual;
        set_heading(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Pedestrian::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.Pedestrian)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_object_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .vision.TYPE object_type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::TYPE_IsValid(value)) {
            set_object_type(static_cast< ::vision::TYPE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 x = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_x(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 y = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_y(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 camera = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_camera(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &camera_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 if_at_lane = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_if_at_lane(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &if_at_lane_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_id = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_lane_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 heading = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.Pedestrian)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.Pedestrian)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Pedestrian::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.Pedestrian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->object_id(), output);
  }

  // required .vision.TYPE object_type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->object_type(), output);
  }

  // required int32 x = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->x(), output);
  }

  // required int32 y = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->y(), output);
  }

  // required int32 camera = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->camera(), output);
  }

  // optional int32 if_at_lane = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->if_at_lane(), output);
  }

  // optional int32 lane_id = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->lane_id(), output);
  }

  // optional int32 heading = 8;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->heading(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.Pedestrian)
}

::google::protobuf::uint8* Pedestrian::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.Pedestrian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->object_id(), target);
  }

  // required .vision.TYPE object_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->object_type(), target);
  }

  // required int32 x = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->x(), target);
  }

  // required int32 y = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->y(), target);
  }

  // required int32 camera = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->camera(), target);
  }

  // optional int32 if_at_lane = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->if_at_lane(), target);
  }

  // optional int32 lane_id = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->lane_id(), target);
  }

  // optional int32 heading = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->heading(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.Pedestrian)
  return target;
}

size_t Pedestrian::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.Pedestrian)
  size_t total_size = 0;

  if (has_object_id()) {
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());
  }

  if (has_object_type()) {
    // required .vision.TYPE object_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->object_type());
  }

  if (has_x()) {
    // required int32 x = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());
  }

  if (has_y()) {
    // required int32 y = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());
  }

  if (has_camera()) {
    // required int32 camera = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());
  }

  return total_size;
}
size_t Pedestrian::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.Pedestrian)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());

    // required .vision.TYPE object_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->object_type());

    // required int32 x = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());

    // required int32 y = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());

    // required int32 camera = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000e0u) {
    // optional int32 if_at_lane = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->if_at_lane());
    }

    // optional int32 lane_id = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lane_id());
    }

    // optional int32 heading = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->heading());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Pedestrian::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.Pedestrian)
  GOOGLE_DCHECK_NE(&from, this);
  const Pedestrian* source =
      ::google::protobuf::DynamicCastToGenerated<Pedestrian>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.Pedestrian)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.Pedestrian)
    MergeFrom(*source);
  }
}

void Pedestrian::MergeFrom(const Pedestrian& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.Pedestrian)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      object_id_ = from.object_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      object_type_ = from.object_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000008u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000010u) {
      camera_ = from.camera_;
    }
    if (cached_has_bits & 0x00000020u) {
      if_at_lane_ = from.if_at_lane_;
    }
    if (cached_has_bits & 0x00000040u) {
      lane_id_ = from.lane_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      heading_ = from.heading_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Pedestrian::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.Pedestrian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Pedestrian::CopyFrom(const Pedestrian& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.Pedestrian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pedestrian::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  return true;
}

void Pedestrian::Swap(Pedestrian* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Pedestrian::InternalSwap(Pedestrian* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(object_id_, other->object_id_);
  swap(object_type_, other->object_type_);
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(camera_, other->camera_);
  swap(if_at_lane_, other->if_at_lane_);
  swap(lane_id_, other->lane_id_);
  swap(heading_, other->heading_);
}

::google::protobuf::Metadata Pedestrian::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Obstacle::InitAsDefaultInstance() {
}
class Obstacle::HasBitSetters {
 public:
  static void set_has_object_id(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_x(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_y(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_camera(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_if_at_lane(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_lane_id(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_heading(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Obstacle::kObjectIdFieldNumber;
const int Obstacle::kXFieldNumber;
const int Obstacle::kYFieldNumber;
const int Obstacle::kCameraFieldNumber;
const int Obstacle::kIfAtLaneFieldNumber;
const int Obstacle::kLaneIdFieldNumber;
const int Obstacle::kHeadingFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Obstacle::Obstacle()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.Obstacle)
}
Obstacle::Obstacle(const Obstacle& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&object_id_, &from.object_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&heading_) -
    reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
  // @@protoc_insertion_point(copy_constructor:vision.Obstacle)
}

void Obstacle::SharedCtor() {
  ::memset(&object_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&heading_) -
      reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
}

Obstacle::~Obstacle() {
  // @@protoc_insertion_point(destructor:vision.Obstacle)
  SharedDtor();
}

void Obstacle::SharedDtor() {
}

void Obstacle::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Obstacle& Obstacle::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Obstacle_vision_2eproto.base);
  return *internal_default_instance();
}


void Obstacle::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.Obstacle)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&object_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&heading_) -
        reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Obstacle::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_object_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 x = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        set_x(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 y = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_y(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 camera = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        set_camera(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 if_at_lane = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        set_if_at_lane(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_id = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        set_lane_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 heading = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        set_heading(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Obstacle::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.Obstacle)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_object_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 x = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_x(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 y = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_y(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 camera = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_camera(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &camera_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 if_at_lane = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_if_at_lane(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &if_at_lane_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_id = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_lane_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 heading = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.Obstacle)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.Obstacle)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Obstacle::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.Obstacle)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->object_id(), output);
  }

  // required int32 x = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->x(), output);
  }

  // required int32 y = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->y(), output);
  }

  // required int32 camera = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->camera(), output);
  }

  // optional int32 if_at_lane = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->if_at_lane(), output);
  }

  // optional int32 lane_id = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->lane_id(), output);
  }

  // optional int32 heading = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->heading(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.Obstacle)
}

::google::protobuf::uint8* Obstacle::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.Obstacle)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->object_id(), target);
  }

  // required int32 x = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->x(), target);
  }

  // required int32 y = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->y(), target);
  }

  // required int32 camera = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->camera(), target);
  }

  // optional int32 if_at_lane = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->if_at_lane(), target);
  }

  // optional int32 lane_id = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->lane_id(), target);
  }

  // optional int32 heading = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->heading(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.Obstacle)
  return target;
}

size_t Obstacle::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.Obstacle)
  size_t total_size = 0;

  if (has_object_id()) {
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());
  }

  if (has_x()) {
    // required int32 x = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());
  }

  if (has_y()) {
    // required int32 y = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());
  }

  if (has_camera()) {
    // required int32 camera = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());
  }

  return total_size;
}
size_t Obstacle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.Obstacle)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());

    // required int32 x = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());

    // required int32 y = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());

    // required int32 camera = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000070u) {
    // optional int32 if_at_lane = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->if_at_lane());
    }

    // optional int32 lane_id = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lane_id());
    }

    // optional int32 heading = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->heading());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Obstacle::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.Obstacle)
  GOOGLE_DCHECK_NE(&from, this);
  const Obstacle* source =
      ::google::protobuf::DynamicCastToGenerated<Obstacle>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.Obstacle)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.Obstacle)
    MergeFrom(*source);
  }
}

void Obstacle::MergeFrom(const Obstacle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.Obstacle)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      object_id_ = from.object_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000004u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000008u) {
      camera_ = from.camera_;
    }
    if (cached_has_bits & 0x00000010u) {
      if_at_lane_ = from.if_at_lane_;
    }
    if (cached_has_bits & 0x00000020u) {
      lane_id_ = from.lane_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      heading_ = from.heading_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Obstacle::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.Obstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Obstacle::CopyFrom(const Obstacle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.Obstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Obstacle::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  return true;
}

void Obstacle::Swap(Obstacle* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Obstacle::InternalSwap(Obstacle* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(object_id_, other->object_id_);
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(camera_, other->camera_);
  swap(if_at_lane_, other->if_at_lane_);
  swap(lane_id_, other->lane_id_);
  swap(heading_, other->heading_);
}

::google::protobuf::Metadata Obstacle::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void AvailableArea::InitAsDefaultInstance() {
}
class AvailableArea::HasBitSetters {
 public:
  static void set_has_object_id(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_x1(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_y1(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_x2(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_y2(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_camera(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_lane_id(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_heading(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_x3(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static void set_has_y3(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
  static void set_has_x4(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000400u;
  }
  static void set_has_y4(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000800u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AvailableArea::kObjectIdFieldNumber;
const int AvailableArea::kX1FieldNumber;
const int AvailableArea::kY1FieldNumber;
const int AvailableArea::kX2FieldNumber;
const int AvailableArea::kY2FieldNumber;
const int AvailableArea::kCameraFieldNumber;
const int AvailableArea::kLaneIdFieldNumber;
const int AvailableArea::kHeadingFieldNumber;
const int AvailableArea::kX3FieldNumber;
const int AvailableArea::kY3FieldNumber;
const int AvailableArea::kX4FieldNumber;
const int AvailableArea::kY4FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AvailableArea::AvailableArea()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.AvailableArea)
}
AvailableArea::AvailableArea(const AvailableArea& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&object_id_, &from.object_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&y4_) -
    reinterpret_cast<char*>(&object_id_)) + sizeof(y4_));
  // @@protoc_insertion_point(copy_constructor:vision.AvailableArea)
}

void AvailableArea::SharedCtor() {
  ::memset(&object_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&y4_) -
      reinterpret_cast<char*>(&object_id_)) + sizeof(y4_));
}

AvailableArea::~AvailableArea() {
  // @@protoc_insertion_point(destructor:vision.AvailableArea)
  SharedDtor();
}

void AvailableArea::SharedDtor() {
}

void AvailableArea::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AvailableArea& AvailableArea::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_AvailableArea_vision_2eproto.base);
  return *internal_default_instance();
}


void AvailableArea::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.AvailableArea)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&object_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&heading_) -
        reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&x3_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&y4_) -
        reinterpret_cast<char*>(&x3_)) + sizeof(y4_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AvailableArea::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_object_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 x1 = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        set_x1(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 y1 = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_y1(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 x2 = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        set_x2(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 y2 = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        set_y2(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 camera = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        set_camera(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_id = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        set_lane_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 heading = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 64) goto handle_unusual;
        set_heading(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 x3 = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 72) goto handle_unusual;
        set_x3(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 y3 = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 80) goto handle_unusual;
        set_y3(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 x4 = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 88) goto handle_unusual;
        set_x4(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 y4 = 12;
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 96) goto handle_unusual;
        set_y4(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AvailableArea::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.AvailableArea)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_object_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 x1 = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_x1(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x1_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 y1 = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_y1(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y1_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 x2 = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_x2(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x2_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 y2 = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_y2(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y2_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 camera = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_camera(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &camera_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_id = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_lane_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 heading = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 x3 = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_x3(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x3_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 y3 = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (80 & 0xFF)) {
          HasBitSetters::set_has_y3(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y3_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 x4 = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (88 & 0xFF)) {
          HasBitSetters::set_has_x4(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x4_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 y4 = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (96 & 0xFF)) {
          HasBitSetters::set_has_y4(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y4_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.AvailableArea)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.AvailableArea)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AvailableArea::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.AvailableArea)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->object_id(), output);
  }

  // required int32 x1 = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->x1(), output);
  }

  // required int32 y1 = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->y1(), output);
  }

  // required int32 x2 = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->x2(), output);
  }

  // required int32 y2 = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->y2(), output);
  }

  // required int32 camera = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->camera(), output);
  }

  // optional int32 lane_id = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->lane_id(), output);
  }

  // optional int32 heading = 8;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->heading(), output);
  }

  // required int32 x3 = 9;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->x3(), output);
  }

  // required int32 y3 = 10;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->y3(), output);
  }

  // required int32 x4 = 11;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->x4(), output);
  }

  // required int32 y4 = 12;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->y4(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.AvailableArea)
}

::google::protobuf::uint8* AvailableArea::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.AvailableArea)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->object_id(), target);
  }

  // required int32 x1 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->x1(), target);
  }

  // required int32 y1 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->y1(), target);
  }

  // required int32 x2 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->x2(), target);
  }

  // required int32 y2 = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->y2(), target);
  }

  // required int32 camera = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->camera(), target);
  }

  // optional int32 lane_id = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->lane_id(), target);
  }

  // optional int32 heading = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->heading(), target);
  }

  // required int32 x3 = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->x3(), target);
  }

  // required int32 y3 = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->y3(), target);
  }

  // required int32 x4 = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->x4(), target);
  }

  // required int32 y4 = 12;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(12, this->y4(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.AvailableArea)
  return target;
}

size_t AvailableArea::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.AvailableArea)
  size_t total_size = 0;

  if (has_object_id()) {
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());
  }

  if (has_x1()) {
    // required int32 x1 = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x1());
  }

  if (has_y1()) {
    // required int32 y1 = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y1());
  }

  if (has_x2()) {
    // required int32 x2 = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x2());
  }

  if (has_y2()) {
    // required int32 y2 = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y2());
  }

  if (has_camera()) {
    // required int32 camera = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());
  }

  if (has_x3()) {
    // required int32 x3 = 9;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x3());
  }

  if (has_y3()) {
    // required int32 y3 = 10;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y3());
  }

  if (has_x4()) {
    // required int32 x4 = 11;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x4());
  }

  if (has_y4()) {
    // required int32 y4 = 12;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y4());
  }

  return total_size;
}
size_t AvailableArea::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.AvailableArea)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000f3f) ^ 0x00000f3f) == 0) {  // All required fields are present.
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());

    // required int32 x1 = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x1());

    // required int32 y1 = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y1());

    // required int32 x2 = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x2());

    // required int32 y2 = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y2());

    // required int32 camera = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());

    // required int32 x3 = 9;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x3());

    // required int32 y3 = 10;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y3());

    // required int32 x4 = 11;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x4());

    // required int32 y4 = 12;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y4());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000c0u) {
    // optional int32 lane_id = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lane_id());
    }

    // optional int32 heading = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->heading());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AvailableArea::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.AvailableArea)
  GOOGLE_DCHECK_NE(&from, this);
  const AvailableArea* source =
      ::google::protobuf::DynamicCastToGenerated<AvailableArea>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.AvailableArea)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.AvailableArea)
    MergeFrom(*source);
  }
}

void AvailableArea::MergeFrom(const AvailableArea& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.AvailableArea)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      object_id_ = from.object_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      x1_ = from.x1_;
    }
    if (cached_has_bits & 0x00000004u) {
      y1_ = from.y1_;
    }
    if (cached_has_bits & 0x00000008u) {
      x2_ = from.x2_;
    }
    if (cached_has_bits & 0x00000010u) {
      y2_ = from.y2_;
    }
    if (cached_has_bits & 0x00000020u) {
      camera_ = from.camera_;
    }
    if (cached_has_bits & 0x00000040u) {
      lane_id_ = from.lane_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      heading_ = from.heading_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      x3_ = from.x3_;
    }
    if (cached_has_bits & 0x00000200u) {
      y3_ = from.y3_;
    }
    if (cached_has_bits & 0x00000400u) {
      x4_ = from.x4_;
    }
    if (cached_has_bits & 0x00000800u) {
      y4_ = from.y4_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AvailableArea::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.AvailableArea)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AvailableArea::CopyFrom(const AvailableArea& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.AvailableArea)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvailableArea::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000f3f) != 0x00000f3f) return false;
  return true;
}

void AvailableArea::Swap(AvailableArea* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AvailableArea::InternalSwap(AvailableArea* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(object_id_, other->object_id_);
  swap(x1_, other->x1_);
  swap(y1_, other->y1_);
  swap(x2_, other->x2_);
  swap(y2_, other->y2_);
  swap(camera_, other->camera_);
  swap(lane_id_, other->lane_id_);
  swap(heading_, other->heading_);
  swap(x3_, other->x3_);
  swap(y3_, other->y3_);
  swap(x4_, other->x4_);
  swap(y4_, other->y4_);
}

::google::protobuf::Metadata AvailableArea::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void IllegalCarWarn2::InitAsDefaultInstance() {
}
class IllegalCarWarn2::HasBitSetters {
 public:
  static void set_has_object_id(IllegalCarWarn2* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_x(IllegalCarWarn2* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_y(IllegalCarWarn2* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_camera(IllegalCarWarn2* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_lane_id(IllegalCarWarn2* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IllegalCarWarn2::kObjectIdFieldNumber;
const int IllegalCarWarn2::kXFieldNumber;
const int IllegalCarWarn2::kYFieldNumber;
const int IllegalCarWarn2::kCameraFieldNumber;
const int IllegalCarWarn2::kLaneIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IllegalCarWarn2::IllegalCarWarn2()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.IllegalCarWarn2)
}
IllegalCarWarn2::IllegalCarWarn2(const IllegalCarWarn2& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&object_id_, &from.object_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&lane_id_) -
    reinterpret_cast<char*>(&object_id_)) + sizeof(lane_id_));
  // @@protoc_insertion_point(copy_constructor:vision.IllegalCarWarn2)
}

void IllegalCarWarn2::SharedCtor() {
  ::memset(&object_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lane_id_) -
      reinterpret_cast<char*>(&object_id_)) + sizeof(lane_id_));
}

IllegalCarWarn2::~IllegalCarWarn2() {
  // @@protoc_insertion_point(destructor:vision.IllegalCarWarn2)
  SharedDtor();
}

void IllegalCarWarn2::SharedDtor() {
}

void IllegalCarWarn2::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IllegalCarWarn2& IllegalCarWarn2::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_IllegalCarWarn2_vision_2eproto.base);
  return *internal_default_instance();
}


void IllegalCarWarn2::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.IllegalCarWarn2)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&object_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lane_id_) -
        reinterpret_cast<char*>(&object_id_)) + sizeof(lane_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IllegalCarWarn2::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_object_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 x = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        set_x(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 y = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_y(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 camera = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        set_camera(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_id = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        set_lane_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IllegalCarWarn2::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.IllegalCarWarn2)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_object_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 x = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_x(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 y = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_y(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 camera = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_camera(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &camera_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_id = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_lane_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.IllegalCarWarn2)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.IllegalCarWarn2)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IllegalCarWarn2::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.IllegalCarWarn2)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->object_id(), output);
  }

  // required int32 x = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->x(), output);
  }

  // required int32 y = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->y(), output);
  }

  // required int32 camera = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->camera(), output);
  }

  // optional int32 lane_id = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->lane_id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.IllegalCarWarn2)
}

::google::protobuf::uint8* IllegalCarWarn2::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.IllegalCarWarn2)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->object_id(), target);
  }

  // required int32 x = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->x(), target);
  }

  // required int32 y = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->y(), target);
  }

  // required int32 camera = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->camera(), target);
  }

  // optional int32 lane_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->lane_id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.IllegalCarWarn2)
  return target;
}

size_t IllegalCarWarn2::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.IllegalCarWarn2)
  size_t total_size = 0;

  if (has_object_id()) {
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());
  }

  if (has_x()) {
    // required int32 x = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());
  }

  if (has_y()) {
    // required int32 y = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());
  }

  if (has_camera()) {
    // required int32 camera = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());
  }

  return total_size;
}
size_t IllegalCarWarn2::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.IllegalCarWarn2)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());

    // required int32 x = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());

    // required int32 y = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());

    // required int32 camera = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 lane_id = 5;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000010u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lane_id());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IllegalCarWarn2::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.IllegalCarWarn2)
  GOOGLE_DCHECK_NE(&from, this);
  const IllegalCarWarn2* source =
      ::google::protobuf::DynamicCastToGenerated<IllegalCarWarn2>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.IllegalCarWarn2)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.IllegalCarWarn2)
    MergeFrom(*source);
  }
}

void IllegalCarWarn2::MergeFrom(const IllegalCarWarn2& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.IllegalCarWarn2)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      object_id_ = from.object_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000004u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000008u) {
      camera_ = from.camera_;
    }
    if (cached_has_bits & 0x00000010u) {
      lane_id_ = from.lane_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IllegalCarWarn2::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.IllegalCarWarn2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IllegalCarWarn2::CopyFrom(const IllegalCarWarn2& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.IllegalCarWarn2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IllegalCarWarn2::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  return true;
}

void IllegalCarWarn2::Swap(IllegalCarWarn2* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IllegalCarWarn2::InternalSwap(IllegalCarWarn2* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(object_id_, other->object_id_);
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(camera_, other->camera_);
  swap(lane_id_, other->lane_id_);
}

::google::protobuf::Metadata IllegalCarWarn2::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Base::InitAsDefaultInstance() {
}
class Base::HasBitSetters {
 public:
  static void set_has_id(Base* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Base::kIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Base::Base()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.Base)
}
Base::Base(const Base& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:vision.Base)
}

void Base::SharedCtor() {
  id_ = 0;
}

Base::~Base() {
  // @@protoc_insertion_point(destructor:vision.Base)
  SharedDtor();
}

void Base::SharedDtor() {
}

void Base::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Base& Base::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Base_vision_2eproto.base);
  return *internal_default_instance();
}


void Base::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.Base)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Base::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Base::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.Base)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.Base)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.Base)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Base::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.Base)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.Base)
}

::google::protobuf::uint8* Base::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.Base)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.Base)
  return target;
}

size_t Base::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.Base)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .vision.ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Base::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.Base)
  GOOGLE_DCHECK_NE(&from, this);
  const Base* source =
      ::google::protobuf::DynamicCastToGenerated<Base>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.Base)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.Base)
    MergeFrom(*source);
  }
}

void Base::MergeFrom(const Base& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.Base)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_id()) {
    set_id(from.id());
  }
}

void Base::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.Base)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Base::CopyFrom(const Base& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.Base)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Base::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Base::Swap(Base* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Base::InternalSwap(Base* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(id_, other->id_);
}

::google::protobuf::Metadata Base::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Crowd::InitAsDefaultInstance() {
}
class Crowd::HasBitSetters {
 public:
  static void set_has_id(Crowd* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Crowd::kIdFieldNumber;
const int Crowd::kPedestrianFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Crowd::Crowd()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.Crowd)
}
Crowd::Crowd(const Crowd& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      pedestrian_(from.pedestrian_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:vision.Crowd)
}

void Crowd::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Crowd_vision_2eproto.base);
  id_ = 0;
}

Crowd::~Crowd() {
  // @@protoc_insertion_point(destructor:vision.Crowd)
  SharedDtor();
}

void Crowd::SharedDtor() {
}

void Crowd::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Crowd& Crowd::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Crowd_vision_2eproto.base);
  return *internal_default_instance();
}


void Crowd::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.Crowd)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  pedestrian_.Clear();
  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Crowd::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // repeated .vision.Pedestrian pedestrian = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_pedestrian(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Crowd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.Crowd)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .vision.Pedestrian pedestrian = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_pedestrian()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.Crowd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.Crowd)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Crowd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.Crowd)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // repeated .vision.Pedestrian pedestrian = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->pedestrian_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->pedestrian(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.Crowd)
}

::google::protobuf::uint8* Crowd::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.Crowd)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // repeated .vision.Pedestrian pedestrian = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->pedestrian_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->pedestrian(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.Crowd)
  return target;
}

size_t Crowd::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.Crowd)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .vision.ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vision.Pedestrian pedestrian = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->pedestrian_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->pedestrian(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Crowd::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.Crowd)
  GOOGLE_DCHECK_NE(&from, this);
  const Crowd* source =
      ::google::protobuf::DynamicCastToGenerated<Crowd>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.Crowd)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.Crowd)
    MergeFrom(*source);
  }
}

void Crowd::MergeFrom(const Crowd& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.Crowd)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  pedestrian_.MergeFrom(from.pedestrian_);
  if (from.has_id()) {
    set_id(from.id());
  }
}

void Crowd::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.Crowd)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Crowd::CopyFrom(const Crowd& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.Crowd)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Crowd::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->pedestrian())) return false;
  return true;
}

void Crowd::Swap(Crowd* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Crowd::InternalSwap(Crowd* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&pedestrian_)->InternalSwap(CastToBase(&other->pedestrian_));
  swap(id_, other->id_);
}

::google::protobuf::Metadata Crowd::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Obstacles::InitAsDefaultInstance() {
}
class Obstacles::HasBitSetters {
 public:
  static void set_has_id(Obstacles* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Obstacles::kIdFieldNumber;
const int Obstacles::kObstacleFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Obstacles::Obstacles()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.Obstacles)
}
Obstacles::Obstacles(const Obstacles& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      obstacle_(from.obstacle_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:vision.Obstacles)
}

void Obstacles::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Obstacles_vision_2eproto.base);
  id_ = 0;
}

Obstacles::~Obstacles() {
  // @@protoc_insertion_point(destructor:vision.Obstacles)
  SharedDtor();
}

void Obstacles::SharedDtor() {
}

void Obstacles::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Obstacles& Obstacles::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Obstacles_vision_2eproto.base);
  return *internal_default_instance();
}


void Obstacles::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.Obstacles)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  obstacle_.Clear();
  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Obstacles::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // repeated .vision.Obstacle obstacle = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_obstacle(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Obstacles::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.Obstacles)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .vision.Obstacle obstacle = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_obstacle()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.Obstacles)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.Obstacles)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Obstacles::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.Obstacles)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // repeated .vision.Obstacle obstacle = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->obstacle_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->obstacle(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.Obstacles)
}

::google::protobuf::uint8* Obstacles::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.Obstacles)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // repeated .vision.Obstacle obstacle = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->obstacle_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->obstacle(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.Obstacles)
  return target;
}

size_t Obstacles::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.Obstacles)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .vision.ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vision.Obstacle obstacle = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->obstacle_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->obstacle(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Obstacles::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.Obstacles)
  GOOGLE_DCHECK_NE(&from, this);
  const Obstacles* source =
      ::google::protobuf::DynamicCastToGenerated<Obstacles>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.Obstacles)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.Obstacles)
    MergeFrom(*source);
  }
}

void Obstacles::MergeFrom(const Obstacles& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.Obstacles)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  obstacle_.MergeFrom(from.obstacle_);
  if (from.has_id()) {
    set_id(from.id());
  }
}

void Obstacles::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.Obstacles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Obstacles::CopyFrom(const Obstacles& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.Obstacles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Obstacles::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->obstacle())) return false;
  return true;
}

void Obstacles::Swap(Obstacles* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Obstacles::InternalSwap(Obstacles* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&obstacle_)->InternalSwap(CastToBase(&other->obstacle_));
  swap(id_, other->id_);
}

::google::protobuf::Metadata Obstacles::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void AvailableAreas::InitAsDefaultInstance() {
}
class AvailableAreas::HasBitSetters {
 public:
  static void set_has_id(AvailableAreas* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AvailableAreas::kIdFieldNumber;
const int AvailableAreas::kAreaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AvailableAreas::AvailableAreas()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.AvailableAreas)
}
AvailableAreas::AvailableAreas(const AvailableAreas& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      area_(from.area_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:vision.AvailableAreas)
}

void AvailableAreas::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_AvailableAreas_vision_2eproto.base);
  id_ = 0;
}

AvailableAreas::~AvailableAreas() {
  // @@protoc_insertion_point(destructor:vision.AvailableAreas)
  SharedDtor();
}

void AvailableAreas::SharedDtor() {
}

void AvailableAreas::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AvailableAreas& AvailableAreas::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_AvailableAreas_vision_2eproto.base);
  return *internal_default_instance();
}


void AvailableAreas::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.AvailableAreas)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  area_.Clear();
  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AvailableAreas::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // repeated .vision.AvailableArea area = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_area(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AvailableAreas::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.AvailableAreas)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .vision.AvailableArea area = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_area()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.AvailableAreas)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.AvailableAreas)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AvailableAreas::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.AvailableAreas)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // repeated .vision.AvailableArea area = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->area_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->area(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.AvailableAreas)
}

::google::protobuf::uint8* AvailableAreas::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.AvailableAreas)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // repeated .vision.AvailableArea area = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->area_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->area(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.AvailableAreas)
  return target;
}

size_t AvailableAreas::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.AvailableAreas)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .vision.ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vision.AvailableArea area = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->area_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->area(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AvailableAreas::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.AvailableAreas)
  GOOGLE_DCHECK_NE(&from, this);
  const AvailableAreas* source =
      ::google::protobuf::DynamicCastToGenerated<AvailableAreas>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.AvailableAreas)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.AvailableAreas)
    MergeFrom(*source);
  }
}

void AvailableAreas::MergeFrom(const AvailableAreas& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.AvailableAreas)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  area_.MergeFrom(from.area_);
  if (from.has_id()) {
    set_id(from.id());
  }
}

void AvailableAreas::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.AvailableAreas)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AvailableAreas::CopyFrom(const AvailableAreas& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.AvailableAreas)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvailableAreas::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->area())) return false;
  return true;
}

void AvailableAreas::Swap(AvailableAreas* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AvailableAreas::InternalSwap(AvailableAreas* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&area_)->InternalSwap(CastToBase(&other->area_));
  swap(id_, other->id_);
}

::google::protobuf::Metadata AvailableAreas::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void IllegalCarWarns2::InitAsDefaultInstance() {
}
class IllegalCarWarns2::HasBitSetters {
 public:
  static void set_has_id(IllegalCarWarns2* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IllegalCarWarns2::kIdFieldNumber;
const int IllegalCarWarns2::kLlegalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IllegalCarWarns2::IllegalCarWarns2()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.IllegalCarWarns2)
}
IllegalCarWarns2::IllegalCarWarns2(const IllegalCarWarns2& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      llegal_(from.llegal_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:vision.IllegalCarWarns2)
}

void IllegalCarWarns2::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_IllegalCarWarns2_vision_2eproto.base);
  id_ = 0;
}

IllegalCarWarns2::~IllegalCarWarns2() {
  // @@protoc_insertion_point(destructor:vision.IllegalCarWarns2)
  SharedDtor();
}

void IllegalCarWarns2::SharedDtor() {
}

void IllegalCarWarns2::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IllegalCarWarns2& IllegalCarWarns2::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_IllegalCarWarns2_vision_2eproto.base);
  return *internal_default_instance();
}


void IllegalCarWarns2::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.IllegalCarWarns2)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  llegal_.Clear();
  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IllegalCarWarns2::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // repeated .vision.IllegalCarWarn2 llegal = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_llegal(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IllegalCarWarns2::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.IllegalCarWarns2)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .vision.IllegalCarWarn2 llegal = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_llegal()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.IllegalCarWarns2)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.IllegalCarWarns2)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IllegalCarWarns2::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.IllegalCarWarns2)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // repeated .vision.IllegalCarWarn2 llegal = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->llegal_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->llegal(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.IllegalCarWarns2)
}

::google::protobuf::uint8* IllegalCarWarns2::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.IllegalCarWarns2)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // repeated .vision.IllegalCarWarn2 llegal = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->llegal_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->llegal(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.IllegalCarWarns2)
  return target;
}

size_t IllegalCarWarns2::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.IllegalCarWarns2)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .vision.ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vision.IllegalCarWarn2 llegal = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->llegal_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->llegal(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IllegalCarWarns2::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.IllegalCarWarns2)
  GOOGLE_DCHECK_NE(&from, this);
  const IllegalCarWarns2* source =
      ::google::protobuf::DynamicCastToGenerated<IllegalCarWarns2>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.IllegalCarWarns2)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.IllegalCarWarns2)
    MergeFrom(*source);
  }
}

void IllegalCarWarns2::MergeFrom(const IllegalCarWarns2& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.IllegalCarWarns2)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  llegal_.MergeFrom(from.llegal_);
  if (from.has_id()) {
    set_id(from.id());
  }
}

void IllegalCarWarns2::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.IllegalCarWarns2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IllegalCarWarns2::CopyFrom(const IllegalCarWarns2& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.IllegalCarWarns2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IllegalCarWarns2::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->llegal())) return false;
  return true;
}

void IllegalCarWarns2::Swap(IllegalCarWarns2* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IllegalCarWarns2::InternalSwap(IllegalCarWarns2* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&llegal_)->InternalSwap(CastToBase(&other->llegal_));
  swap(id_, other->id_);
}

::google::protobuf::Metadata IllegalCarWarns2::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ThrowingObj::InitAsDefaultInstance() {
}
class ThrowingObj::HasBitSetters {
 public:
  static void set_has_id(ThrowingObj* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ThrowingObj::kIdFieldNumber;
const int ThrowingObj::kArrayFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ThrowingObj::ThrowingObj()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.ThrowingObj)
}
ThrowingObj::ThrowingObj(const ThrowingObj& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      array_(from.array_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:vision.ThrowingObj)
}

void ThrowingObj::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_ThrowingObj_vision_2eproto.base);
  id_ = 0;
}

ThrowingObj::~ThrowingObj() {
  // @@protoc_insertion_point(destructor:vision.ThrowingObj)
  SharedDtor();
}

void ThrowingObj::SharedDtor() {
}

void ThrowingObj::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ThrowingObj& ThrowingObj::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ThrowingObj_vision_2eproto.base);
  return *internal_default_instance();
}


void ThrowingObj::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.ThrowingObj)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  array_.Clear();
  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ThrowingObj::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // repeated .vision.Obstacle array = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_array(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ThrowingObj::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.ThrowingObj)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .vision.Obstacle array = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_array()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.ThrowingObj)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.ThrowingObj)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ThrowingObj::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.ThrowingObj)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // repeated .vision.Obstacle array = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->array_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->array(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.ThrowingObj)
}

::google::protobuf::uint8* ThrowingObj::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.ThrowingObj)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // repeated .vision.Obstacle array = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->array_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->array(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.ThrowingObj)
  return target;
}

size_t ThrowingObj::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.ThrowingObj)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .vision.ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vision.Obstacle array = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->array_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->array(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThrowingObj::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.ThrowingObj)
  GOOGLE_DCHECK_NE(&from, this);
  const ThrowingObj* source =
      ::google::protobuf::DynamicCastToGenerated<ThrowingObj>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.ThrowingObj)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.ThrowingObj)
    MergeFrom(*source);
  }
}

void ThrowingObj::MergeFrom(const ThrowingObj& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.ThrowingObj)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  array_.MergeFrom(from.array_);
  if (from.has_id()) {
    set_id(from.id());
  }
}

void ThrowingObj::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.ThrowingObj)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ThrowingObj::CopyFrom(const ThrowingObj& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.ThrowingObj)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThrowingObj::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->array())) return false;
  return true;
}

void ThrowingObj::Swap(ThrowingObj* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ThrowingObj::InternalSwap(ThrowingObj* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&array_)->InternalSwap(CastToBase(&other->array_));
  swap(id_, other->id_);
}

::google::protobuf::Metadata ThrowingObj::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Seeing::InitAsDefaultInstance() {
}
class Seeing::HasBitSetters {
 public:
  static void set_has_id(Seeing* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_distance(Seeing* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_level(Seeing* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Seeing::kIdFieldNumber;
const int Seeing::kDistanceFieldNumber;
const int Seeing::kLevelFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Seeing::Seeing()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.Seeing)
}
Seeing::Seeing(const Seeing& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&distance_, &from.distance_,
    static_cast<size_t>(reinterpret_cast<char*>(&level_) -
    reinterpret_cast<char*>(&distance_)) + sizeof(level_));
  // @@protoc_insertion_point(copy_constructor:vision.Seeing)
}

void Seeing::SharedCtor() {
  ::memset(&distance_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&level_) -
      reinterpret_cast<char*>(&distance_)) + sizeof(level_));
}

Seeing::~Seeing() {
  // @@protoc_insertion_point(destructor:vision.Seeing)
  SharedDtor();
}

void Seeing::SharedDtor() {
}

void Seeing::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Seeing& Seeing::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Seeing_vision_2eproto.base);
  return *internal_default_instance();
}


void Seeing::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.Seeing)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&distance_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&level_) -
        reinterpret_cast<char*>(&distance_)) + sizeof(level_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Seeing::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // required double distance = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        set_distance(::google::protobuf::internal::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // required int32 level = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_level(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Seeing::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.Seeing)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required double distance = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          HasBitSetters::set_has_distance(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 level = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_level(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &level_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.Seeing)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.Seeing)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Seeing::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.Seeing)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // required double distance = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->distance(), output);
  }

  // required int32 level = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->level(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.Seeing)
}

::google::protobuf::uint8* Seeing::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.Seeing)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // required double distance = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->distance(), target);
  }

  // required int32 level = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->level(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.Seeing)
  return target;
}

size_t Seeing::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.Seeing)
  size_t total_size = 0;

  if (has_distance()) {
    // required double distance = 2;
    total_size += 1 + 8;
  }

  if (has_id()) {
    // required .vision.ID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }

  if (has_level()) {
    // required int32 level = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->level());
  }

  return total_size;
}
size_t Seeing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.Seeing)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required double distance = 2;
    total_size += 1 + 8;

    // required .vision.ID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());

    // required int32 level = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->level());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Seeing::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.Seeing)
  GOOGLE_DCHECK_NE(&from, this);
  const Seeing* source =
      ::google::protobuf::DynamicCastToGenerated<Seeing>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.Seeing)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.Seeing)
    MergeFrom(*source);
  }
}

void Seeing::MergeFrom(const Seeing& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.Seeing)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      distance_ = from.distance_;
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      level_ = from.level_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Seeing::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.Seeing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Seeing::CopyFrom(const Seeing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.Seeing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Seeing::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  return true;
}

void Seeing::Swap(Seeing* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Seeing::InternalSwap(Seeing* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(distance_, other->distance_);
  swap(id_, other->id_);
  swap(level_, other->level_);
}

::google::protobuf::Metadata Seeing::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SmokeWarn::InitAsDefaultInstance() {
}
class SmokeWarn::HasBitSetters {
 public:
  static void set_has_id(SmokeWarn* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_warn(SmokeWarn* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SmokeWarn::kIdFieldNumber;
const int SmokeWarn::kWarnFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SmokeWarn::SmokeWarn()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.SmokeWarn)
}
SmokeWarn::SmokeWarn(const SmokeWarn& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&warn_) -
    reinterpret_cast<char*>(&id_)) + sizeof(warn_));
  // @@protoc_insertion_point(copy_constructor:vision.SmokeWarn)
}

void SmokeWarn::SharedCtor() {
  ::memset(&id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&warn_) -
      reinterpret_cast<char*>(&id_)) + sizeof(warn_));
}

SmokeWarn::~SmokeWarn() {
  // @@protoc_insertion_point(destructor:vision.SmokeWarn)
  SharedDtor();
}

void SmokeWarn::SharedDtor() {
}

void SmokeWarn::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SmokeWarn& SmokeWarn::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SmokeWarn_vision_2eproto.base);
  return *internal_default_instance();
}


void SmokeWarn::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.SmokeWarn)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&warn_) -
        reinterpret_cast<char*>(&id_)) + sizeof(warn_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SmokeWarn::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // required bool warn = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        set_warn(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SmokeWarn::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.SmokeWarn)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bool warn = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_warn(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &warn_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.SmokeWarn)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.SmokeWarn)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SmokeWarn::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.SmokeWarn)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // required bool warn = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->warn(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.SmokeWarn)
}

::google::protobuf::uint8* SmokeWarn::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.SmokeWarn)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // required bool warn = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->warn(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.SmokeWarn)
  return target;
}

size_t SmokeWarn::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.SmokeWarn)
  size_t total_size = 0;

  if (has_id()) {
    // required .vision.ID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }

  if (has_warn()) {
    // required bool warn = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t SmokeWarn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.SmokeWarn)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .vision.ID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());

    // required bool warn = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SmokeWarn::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.SmokeWarn)
  GOOGLE_DCHECK_NE(&from, this);
  const SmokeWarn* source =
      ::google::protobuf::DynamicCastToGenerated<SmokeWarn>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.SmokeWarn)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.SmokeWarn)
    MergeFrom(*source);
  }
}

void SmokeWarn::MergeFrom(const SmokeWarn& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.SmokeWarn)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      warn_ = from.warn_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SmokeWarn::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.SmokeWarn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SmokeWarn::CopyFrom(const SmokeWarn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.SmokeWarn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SmokeWarn::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void SmokeWarn::Swap(SmokeWarn* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SmokeWarn::InternalSwap(SmokeWarn* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(id_, other->id_);
  swap(warn_, other->warn_);
}

::google::protobuf::Metadata SmokeWarn::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace vision
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::vision::Pedestrian* Arena::CreateMaybeMessage< ::vision::Pedestrian >(Arena* arena) {
  return Arena::CreateInternal< ::vision::Pedestrian >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::Obstacle* Arena::CreateMaybeMessage< ::vision::Obstacle >(Arena* arena) {
  return Arena::CreateInternal< ::vision::Obstacle >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::AvailableArea* Arena::CreateMaybeMessage< ::vision::AvailableArea >(Arena* arena) {
  return Arena::CreateInternal< ::vision::AvailableArea >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::IllegalCarWarn2* Arena::CreateMaybeMessage< ::vision::IllegalCarWarn2 >(Arena* arena) {
  return Arena::CreateInternal< ::vision::IllegalCarWarn2 >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::Base* Arena::CreateMaybeMessage< ::vision::Base >(Arena* arena) {
  return Arena::CreateInternal< ::vision::Base >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::Crowd* Arena::CreateMaybeMessage< ::vision::Crowd >(Arena* arena) {
  return Arena::CreateInternal< ::vision::Crowd >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::Obstacles* Arena::CreateMaybeMessage< ::vision::Obstacles >(Arena* arena) {
  return Arena::CreateInternal< ::vision::Obstacles >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::AvailableAreas* Arena::CreateMaybeMessage< ::vision::AvailableAreas >(Arena* arena) {
  return Arena::CreateInternal< ::vision::AvailableAreas >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::IllegalCarWarns2* Arena::CreateMaybeMessage< ::vision::IllegalCarWarns2 >(Arena* arena) {
  return Arena::CreateInternal< ::vision::IllegalCarWarns2 >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::ThrowingObj* Arena::CreateMaybeMessage< ::vision::ThrowingObj >(Arena* arena) {
  return Arena::CreateInternal< ::vision::ThrowingObj >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::Seeing* Arena::CreateMaybeMessage< ::vision::Seeing >(Arena* arena) {
  return Arena::CreateInternal< ::vision::Seeing >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::SmokeWarn* Arena::CreateMaybeMessage< ::vision::SmokeWarn >(Arena* arena) {
  return Arena::CreateInternal< ::vision::SmokeWarn >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
