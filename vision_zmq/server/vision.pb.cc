// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vision.proto

#include "vision.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_vision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_AbnormalCar_vision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_vision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_AvailableArea_vision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_vision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Detectobject_vision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_vision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_FlowInfo_vision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_vision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_JamInfo_vision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_vision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Obstacle_vision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_vision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Pedestrian_vision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_vision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_SpecialCar_vision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_vision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Timestamp_vision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_vision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_data_time_vision_2eproto;
namespace vision {
class data_timeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<data_time> _instance;
} _data_time_default_instance_;
class PedestrianDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Pedestrian> _instance;
} _Pedestrian_default_instance_;
class ObstacleDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Obstacle> _instance;
} _Obstacle_default_instance_;
class AbnormalCarDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<AbnormalCar> _instance;
} _AbnormalCar_default_instance_;
class SpecialCarDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SpecialCar> _instance;
} _SpecialCar_default_instance_;
class AvailableAreaDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<AvailableArea> _instance;
} _AvailableArea_default_instance_;
class JamInfoDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<JamInfo> _instance;
} _JamInfo_default_instance_;
class FlowInfoDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<FlowInfo> _instance;
} _FlowInfo_default_instance_;
class BaseDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Base> _instance;
} _Base_default_instance_;
class CrowdDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Crowd> _instance;
} _Crowd_default_instance_;
class ObstaclesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Obstacles> _instance;
} _Obstacles_default_instance_;
class AvailableAreasDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<AvailableAreas> _instance;
} _AvailableAreas_default_instance_;
class IllegalCarWarnDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IllegalCarWarn> _instance;
} _IllegalCarWarn_default_instance_;
class VisibilityDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Visibility> _instance;
} _Visibility_default_instance_;
class SmokeWarnDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SmokeWarn> _instance;
} _SmokeWarn_default_instance_;
class TimestampDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Timestamp> _instance;
} _Timestamp_default_instance_;
class DetectobjectDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Detectobject> _instance;
} _Detectobject_default_instance_;
class DetectobjectsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Detectobjects> _instance;
} _Detectobjects_default_instance_;
class TrafficJamDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TrafficJam> _instance;
} _TrafficJam_default_instance_;
class TrafficFlowDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TrafficFlow> _instance;
} _TrafficFlow_default_instance_;
class IceWarnDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IceWarn> _instance;
} _IceWarn_default_instance_;
class LaneWareDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<LaneWare> _instance;
} _LaneWare_default_instance_;
class SpecialCarMsgDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SpecialCarMsg> _instance;
} _SpecialCarMsg_default_instance_;
}  // namespace vision
static void InitDefaultsdata_time_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_data_time_default_instance_;
    new (ptr) ::vision::data_time();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::data_time::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_data_time_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsdata_time_vision_2eproto}, {}};

static void InitDefaultsPedestrian_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_Pedestrian_default_instance_;
    new (ptr) ::vision::Pedestrian();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::Pedestrian::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Pedestrian_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsPedestrian_vision_2eproto}, {}};

static void InitDefaultsObstacle_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_Obstacle_default_instance_;
    new (ptr) ::vision::Obstacle();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::Obstacle::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Obstacle_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsObstacle_vision_2eproto}, {}};

static void InitDefaultsAbnormalCar_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_AbnormalCar_default_instance_;
    new (ptr) ::vision::AbnormalCar();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::AbnormalCar::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_AbnormalCar_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsAbnormalCar_vision_2eproto}, {}};

static void InitDefaultsSpecialCar_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_SpecialCar_default_instance_;
    new (ptr) ::vision::SpecialCar();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::SpecialCar::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_SpecialCar_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsSpecialCar_vision_2eproto}, {}};

static void InitDefaultsAvailableArea_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_AvailableArea_default_instance_;
    new (ptr) ::vision::AvailableArea();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::AvailableArea::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_AvailableArea_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsAvailableArea_vision_2eproto}, {}};

static void InitDefaultsJamInfo_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_JamInfo_default_instance_;
    new (ptr) ::vision::JamInfo();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::JamInfo::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_JamInfo_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsJamInfo_vision_2eproto}, {}};

static void InitDefaultsFlowInfo_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_FlowInfo_default_instance_;
    new (ptr) ::vision::FlowInfo();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::FlowInfo::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_FlowInfo_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsFlowInfo_vision_2eproto}, {}};

static void InitDefaultsBase_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_Base_default_instance_;
    new (ptr) ::vision::Base();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::Base::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Base_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsBase_vision_2eproto}, {}};

static void InitDefaultsCrowd_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_Crowd_default_instance_;
    new (ptr) ::vision::Crowd();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::Crowd::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_Crowd_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsCrowd_vision_2eproto}, {
      &scc_info_Pedestrian_vision_2eproto.base,
      &scc_info_data_time_vision_2eproto.base,}};

static void InitDefaultsObstacles_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_Obstacles_default_instance_;
    new (ptr) ::vision::Obstacles();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::Obstacles::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_Obstacles_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsObstacles_vision_2eproto}, {
      &scc_info_Obstacle_vision_2eproto.base,
      &scc_info_data_time_vision_2eproto.base,}};

static void InitDefaultsAvailableAreas_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_AvailableAreas_default_instance_;
    new (ptr) ::vision::AvailableAreas();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::AvailableAreas::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_AvailableAreas_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsAvailableAreas_vision_2eproto}, {
      &scc_info_AvailableArea_vision_2eproto.base,
      &scc_info_data_time_vision_2eproto.base,}};

static void InitDefaultsIllegalCarWarn_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_IllegalCarWarn_default_instance_;
    new (ptr) ::vision::IllegalCarWarn();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::IllegalCarWarn::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_IllegalCarWarn_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsIllegalCarWarn_vision_2eproto}, {
      &scc_info_AbnormalCar_vision_2eproto.base,
      &scc_info_data_time_vision_2eproto.base,}};

static void InitDefaultsVisibility_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_Visibility_default_instance_;
    new (ptr) ::vision::Visibility();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::Visibility::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Visibility_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsVisibility_vision_2eproto}, {}};

static void InitDefaultsSmokeWarn_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_SmokeWarn_default_instance_;
    new (ptr) ::vision::SmokeWarn();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::SmokeWarn::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_SmokeWarn_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsSmokeWarn_vision_2eproto}, {}};

static void InitDefaultsTimestamp_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_Timestamp_default_instance_;
    new (ptr) ::vision::Timestamp();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::Timestamp::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Timestamp_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsTimestamp_vision_2eproto}, {}};

static void InitDefaultsDetectobject_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_Detectobject_default_instance_;
    new (ptr) ::vision::Detectobject();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::Detectobject::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Detectobject_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsDetectobject_vision_2eproto}, {}};

static void InitDefaultsDetectobjects_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_Detectobjects_default_instance_;
    new (ptr) ::vision::Detectobjects();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::Detectobjects::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_Detectobjects_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsDetectobjects_vision_2eproto}, {
      &scc_info_Detectobject_vision_2eproto.base,
      &scc_info_Timestamp_vision_2eproto.base,}};

static void InitDefaultsTrafficJam_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_TrafficJam_default_instance_;
    new (ptr) ::vision::TrafficJam();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::TrafficJam::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_TrafficJam_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsTrafficJam_vision_2eproto}, {
      &scc_info_JamInfo_vision_2eproto.base,
      &scc_info_data_time_vision_2eproto.base,}};

static void InitDefaultsTrafficFlow_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_TrafficFlow_default_instance_;
    new (ptr) ::vision::TrafficFlow();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::TrafficFlow::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_TrafficFlow_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsTrafficFlow_vision_2eproto}, {
      &scc_info_FlowInfo_vision_2eproto.base,
      &scc_info_data_time_vision_2eproto.base,}};

static void InitDefaultsIceWarn_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_IceWarn_default_instance_;
    new (ptr) ::vision::IceWarn();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::IceWarn::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_IceWarn_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsIceWarn_vision_2eproto}, {}};

static void InitDefaultsLaneWare_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_LaneWare_default_instance_;
    new (ptr) ::vision::LaneWare();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::LaneWare::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_LaneWare_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsLaneWare_vision_2eproto}, {}};

static void InitDefaultsSpecialCarMsg_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_SpecialCarMsg_default_instance_;
    new (ptr) ::vision::SpecialCarMsg();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::SpecialCarMsg::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_SpecialCarMsg_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsSpecialCarMsg_vision_2eproto}, {
      &scc_info_SpecialCar_vision_2eproto.base,
      &scc_info_data_time_vision_2eproto.base,}};

void InitDefaults_vision_2eproto() {
  ::google::protobuf::internal::InitSCC(&scc_info_data_time_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Pedestrian_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Obstacle_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_AbnormalCar_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SpecialCar_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_AvailableArea_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_JamInfo_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_FlowInfo_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Base_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Crowd_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Obstacles_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_AvailableAreas_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IllegalCarWarn_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Visibility_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SmokeWarn_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Timestamp_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Detectobject_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Detectobjects_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_TrafficJam_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_TrafficFlow_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IceWarn_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_LaneWare_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SpecialCarMsg_vision_2eproto.base);
}

static ::google::protobuf::Metadata file_level_metadata_vision_2eproto[23];
static const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors_vision_2eproto[6];
static constexpr ::google::protobuf::ServiceDescriptor const** file_level_service_descriptors_vision_2eproto = nullptr;

const ::google::protobuf::uint32 TableStruct_vision_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::vision::data_time, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::data_time, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::data_time, sec_),
  PROTOBUF_FIELD_OFFSET(::vision::data_time, usec_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, object_id_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, object_type_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, lng_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, lat_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, camera_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, if_at_lane_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, lane_id_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, heading_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, approach_judge_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, speed_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, people_heading_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, lane_type_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, object_id_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, lng_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, lat_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, camera_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, if_at_lane_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, lane_id_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, heading_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, length_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, width_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, height_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::vision::AbnormalCar, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::AbnormalCar, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::AbnormalCar, object_id_),
  PROTOBUF_FIELD_OFFSET(::vision::AbnormalCar, lng_),
  PROTOBUF_FIELD_OFFSET(::vision::AbnormalCar, lat_),
  PROTOBUF_FIELD_OFFSET(::vision::AbnormalCar, lane_id_),
  PROTOBUF_FIELD_OFFSET(::vision::AbnormalCar, camera_),
  PROTOBUF_FIELD_OFFSET(::vision::AbnormalCar, abnormal_type_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::vision::SpecialCar, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::SpecialCar, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::SpecialCar, object_id_),
  PROTOBUF_FIELD_OFFSET(::vision::SpecialCar, special_type_),
  PROTOBUF_FIELD_OFFSET(::vision::SpecialCar, lng_),
  PROTOBUF_FIELD_OFFSET(::vision::SpecialCar, lat_),
  PROTOBUF_FIELD_OFFSET(::vision::SpecialCar, camera_),
  PROTOBUF_FIELD_OFFSET(::vision::SpecialCar, lane_id_),
  PROTOBUF_FIELD_OFFSET(::vision::SpecialCar, heading_),
  PROTOBUF_FIELD_OFFSET(::vision::SpecialCar, lane_type_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, object_id_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, lng1_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, lat1_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, lng2_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, lat2_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, lng3_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, lat3_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, lng4_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, lat4_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, camera_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, lane_id_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, heading_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  PROTOBUF_FIELD_OFFSET(::vision::JamInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::JamInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::JamInfo, vehicle_num_),
  PROTOBUF_FIELD_OFFSET(::vision::JamInfo, vehicle_avg_speed_),
  PROTOBUF_FIELD_OFFSET(::vision::JamInfo, road_yaw_),
  PROTOBUF_FIELD_OFFSET(::vision::JamInfo, vehicle_flow_),
  PROTOBUF_FIELD_OFFSET(::vision::JamInfo, lane_id_),
  2,
  0,
  1,
  ~0u,
  3,
  PROTOBUF_FIELD_OFFSET(::vision::FlowInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::FlowInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::FlowInfo, camera_),
  PROTOBUF_FIELD_OFFSET(::vision::FlowInfo, vehicle_num_),
  PROTOBUF_FIELD_OFFSET(::vision::FlowInfo, pass_num_),
  PROTOBUF_FIELD_OFFSET(::vision::FlowInfo, signal_),
  0,
  ~0u,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::vision::Base, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::Base, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::Base, id_),
  0,
  PROTOBUF_FIELD_OFFSET(::vision::Crowd, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::Crowd, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::Crowd, id_),
  PROTOBUF_FIELD_OFFSET(::vision::Crowd, pedestrian_),
  PROTOBUF_FIELD_OFFSET(::vision::Crowd, time_),
  1,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::vision::Obstacles, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacles, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::Obstacles, id_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacles, array_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacles, time_),
  1,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::vision::AvailableAreas, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableAreas, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::AvailableAreas, id_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableAreas, area_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableAreas, time_),
  1,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::vision::IllegalCarWarn, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::IllegalCarWarn, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::IllegalCarWarn, id_),
  PROTOBUF_FIELD_OFFSET(::vision::IllegalCarWarn, array_),
  PROTOBUF_FIELD_OFFSET(::vision::IllegalCarWarn, time_),
  1,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::vision::Visibility, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::Visibility, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::Visibility, id_),
  PROTOBUF_FIELD_OFFSET(::vision::Visibility, distance_),
  PROTOBUF_FIELD_OFFSET(::vision::Visibility, level_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::vision::SmokeWarn, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::SmokeWarn, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::SmokeWarn, id_),
  PROTOBUF_FIELD_OFFSET(::vision::SmokeWarn, warn_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::vision::Timestamp, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::Timestamp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::Timestamp, seconds_),
  PROTOBUF_FIELD_OFFSET(::vision::Timestamp, nanos_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::vision::Detectobject, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::Detectobject, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::Detectobject, object_id_),
  PROTOBUF_FIELD_OFFSET(::vision::Detectobject, object_type_),
  PROTOBUF_FIELD_OFFSET(::vision::Detectobject, longitudinalx_),
  PROTOBUF_FIELD_OFFSET(::vision::Detectobject, lateraly_),
  PROTOBUF_FIELD_OFFSET(::vision::Detectobject, velocity_),
  PROTOBUF_FIELD_OFFSET(::vision::Detectobject, camera_),
  PROTOBUF_FIELD_OFFSET(::vision::Detectobject, if_at_lane_),
  PROTOBUF_FIELD_OFFSET(::vision::Detectobject, lane_id_),
  PROTOBUF_FIELD_OFFSET(::vision::Detectobject, heading_),
  PROTOBUF_FIELD_OFFSET(::vision::Detectobject, lane_type_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::vision::Detectobjects, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::Detectobjects, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::Detectobjects, id_),
  PROTOBUF_FIELD_OFFSET(::vision::Detectobjects, object_),
  PROTOBUF_FIELD_OFFSET(::vision::Detectobjects, time_),
  1,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::vision::TrafficJam, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::TrafficJam, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::TrafficJam, id_),
  PROTOBUF_FIELD_OFFSET(::vision::TrafficJam, jam_),
  PROTOBUF_FIELD_OFFSET(::vision::TrafficJam, time_),
  1,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::vision::TrafficFlow, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::TrafficFlow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::TrafficFlow, id_),
  PROTOBUF_FIELD_OFFSET(::vision::TrafficFlow, flow_),
  PROTOBUF_FIELD_OFFSET(::vision::TrafficFlow, time_),
  1,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::vision::IceWarn, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::IceWarn, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::IceWarn, id_),
  PROTOBUF_FIELD_OFFSET(::vision::IceWarn, warn_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::vision::LaneWare, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::LaneWare, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::LaneWare, id_),
  PROTOBUF_FIELD_OFFSET(::vision::LaneWare, ware_type_),
  PROTOBUF_FIELD_OFFSET(::vision::LaneWare, lng1_),
  PROTOBUF_FIELD_OFFSET(::vision::LaneWare, lat1_),
  PROTOBUF_FIELD_OFFSET(::vision::LaneWare, lng2_),
  PROTOBUF_FIELD_OFFSET(::vision::LaneWare, lat2_),
  PROTOBUF_FIELD_OFFSET(::vision::LaneWare, heading_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::vision::SpecialCarMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::SpecialCarMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::SpecialCarMsg, id_),
  PROTOBUF_FIELD_OFFSET(::vision::SpecialCarMsg, array_),
  PROTOBUF_FIELD_OFFSET(::vision::SpecialCarMsg, time_),
  1,
  ~0u,
  0,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, sizeof(::vision::data_time)},
  { 9, 26, sizeof(::vision::Pedestrian)},
  { 38, 53, sizeof(::vision::Obstacle)},
  { 63, 74, sizeof(::vision::AbnormalCar)},
  { 80, 93, sizeof(::vision::SpecialCar)},
  { 101, 118, sizeof(::vision::AvailableArea)},
  { 130, 140, sizeof(::vision::JamInfo)},
  { 145, 154, sizeof(::vision::FlowInfo)},
  { 158, 164, sizeof(::vision::Base)},
  { 165, 173, sizeof(::vision::Crowd)},
  { 176, 184, sizeof(::vision::Obstacles)},
  { 187, 195, sizeof(::vision::AvailableAreas)},
  { 198, 206, sizeof(::vision::IllegalCarWarn)},
  { 209, 217, sizeof(::vision::Visibility)},
  { 220, 227, sizeof(::vision::SmokeWarn)},
  { 229, 236, sizeof(::vision::Timestamp)},
  { 238, 253, sizeof(::vision::Detectobject)},
  { 263, 271, sizeof(::vision::Detectobjects)},
  { 274, 282, sizeof(::vision::TrafficJam)},
  { 285, 293, sizeof(::vision::TrafficFlow)},
  { 296, 303, sizeof(::vision::IceWarn)},
  { 305, 317, sizeof(::vision::LaneWare)},
  { 324, 332, sizeof(::vision::SpecialCarMsg)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_data_time_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_Pedestrian_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_Obstacle_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_AbnormalCar_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_SpecialCar_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_AvailableArea_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_JamInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_FlowInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_Base_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_Crowd_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_Obstacles_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_AvailableAreas_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_IllegalCarWarn_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_Visibility_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_SmokeWarn_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_Timestamp_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_Detectobject_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_Detectobjects_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_TrafficJam_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_TrafficFlow_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_IceWarn_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_LaneWare_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_SpecialCarMsg_default_instance_),
};

static ::google::protobuf::internal::AssignDescriptorsTable assign_descriptors_table_vision_2eproto = {
  {}, AddDescriptors_vision_2eproto, "vision.proto", schemas,
  file_default_instances, TableStruct_vision_2eproto::offsets,
  file_level_metadata_vision_2eproto, 23, file_level_enum_descriptors_vision_2eproto, file_level_service_descriptors_vision_2eproto,
};

const char descriptor_table_protodef_vision_2eproto[] =
  "\n\014vision.proto\022\006vision\"&\n\tdata_time\022\013\n\003s"
  "ec\030\001 \002(\004\022\014\n\004usec\030\002 \002(\r\"\364\001\n\nPedestrian\022\021\n"
  "\tobject_id\030\001 \002(\005\022!\n\013object_type\030\002 \002(\0162\014."
  "vision.TYPE\022\013\n\003lng\030\003 \002(\005\022\013\n\003lat\030\004 \002(\005\022\016\n"
  "\006camera\030\005 \002(\005\022\022\n\nif_at_lane\030\006 \001(\005\022\017\n\007lan"
  "e_id\030\007 \001(\005\022\017\n\007heading\030\010 \001(\005\022\026\n\016approach_"
  "judge\030\t \001(\005\022\r\n\005speed\030\n \001(\005\022\026\n\016people_hea"
  "ding\030\013 \001(\005\022\021\n\tlane_type\030\014 \001(\005\"\254\001\n\010Obstac"
  "le\022\021\n\tobject_id\030\001 \002(\005\022\013\n\003lng\030\002 \002(\005\022\013\n\003la"
  "t\030\003 \002(\005\022\016\n\006camera\030\004 \002(\005\022\022\n\nif_at_lane\030\005 "
  "\001(\005\022\017\n\007lane_id\030\006 \001(\005\022\017\n\007heading\030\007 \001(\005\022\016\n"
  "\006length\030\010 \001(\005\022\r\n\005width\030\t \001(\005\022\016\n\006height\030\n"
  " \001(\005\"\210\001\n\013AbnormalCar\022\021\n\tobject_id\030\001 \002(\005\022"
  "\013\n\003lng\030\002 \002(\005\022\013\n\003lat\030\003 \002(\005\022\017\n\007lane_id\030\004 \001"
  "(\005\022\016\n\006camera\030\005 \001(\005\022+\n\rabnormal_type\030\006 \001("
  "\0162\024.vision.ABNORMALTYPE\"\375\001\n\nSpecialCar\022\021"
  "\n\tobject_id\030\001 \002(\005\0224\n\014special_type\030\002 \002(\0162"
  "\036.vision.SpecialCar.SPECIALTYPE\022\013\n\003lng\030\003"
  " \002(\005\022\013\n\003lat\030\004 \002(\005\022\016\n\006camera\030\005 \002(\005\022\017\n\007lan"
  "e_id\030\006 \001(\005\022\017\n\007heading\030\007 \001(\005\022\021\n\tlane_type"
  "\030\010 \001(\005\"G\n\013SPECIALTYPE\022\n\n\006NORMAL\020\000\022\r\n\tAMB"
  "ULANCE\020\001\022\r\n\tDANGERCAR\020\002\022\016\n\nFIREENGINE\020\003\""
  "\304\001\n\rAvailableArea\022\021\n\tobject_id\030\001 \002(\005\022\014\n\004"
  "lng1\030\002 \002(\005\022\014\n\004lat1\030\003 \002(\005\022\014\n\004lng2\030\004 \002(\005\022\014"
  "\n\004lat2\030\005 \002(\005\022\014\n\004lng3\030\006 \002(\005\022\014\n\004lat3\030\007 \002(\005"
  "\022\014\n\004lng4\030\010 \002(\005\022\014\n\004lat4\030\t \002(\005\022\016\n\006camera\030\n"
  " \002(\005\022\017\n\007lane_id\030\013 \001(\005\022\017\n\007heading\030\014 \001(\005\"r"
  "\n\007JamInfo\022\023\n\013vehicle_num\030\001 \002(\r\022\031\n\021vehicl"
  "e_avg_speed\030\002 \002(\001\022\020\n\010road_yaw\030\003 \002(\001\022\024\n\014v"
  "ehicle_flow\030\004 \003(\005\022\017\n\007lane_id\030\005 \001(\005\"\234\001\n\010F"
  "lowInfo\022\016\n\006camera\030\001 \001(\005\022\023\n\013vehicle_num\030\002"
  " \003(\r\022\020\n\010pass_num\030\003 \003(\r\022+\n\006signal\030\004 \001(\0162\033"
  ".vision.FlowInfo.TrafficSig\",\n\nTrafficSi"
  "g\022\013\n\007UNKNOWN\020\000\022\007\n\003Y2G\020\001\022\010\n\004OVER\020\002\"\036\n\004Bas"
  "e\022\026\n\002id\030\001 \002(\0162\n.vision.ID\"h\n\005Crowd\022\026\n\002id"
  "\030\001 \002(\0162\n.vision.ID\022&\n\npedestrian\030\002 \003(\0132\022"
  ".vision.Pedestrian\022\037\n\004time\030\003 \001(\0132\021.visio"
  "n.data_time\"e\n\tObstacles\022\026\n\002id\030\001 \002(\0162\n.v"
  "ision.ID\022\037\n\005array\030\002 \003(\0132\020.vision.Obstacl"
  "e\022\037\n\004time\030\003 \001(\0132\021.vision.data_time\"n\n\016Av"
  "ailableAreas\022\026\n\002id\030\001 \002(\0162\n.vision.ID\022#\n\004"
  "area\030\002 \003(\0132\025.vision.AvailableArea\022\037\n\004tim"
  "e\030\003 \001(\0132\021.vision.data_time\"m\n\016IllegalCar"
  "Warn\022\026\n\002id\030\001 \002(\0162\n.vision.ID\022\"\n\005array\030\002 "
  "\003(\0132\023.vision.AbnormalCar\022\037\n\004time\030\003 \001(\0132\021"
  ".vision.data_time\"E\n\nVisibility\022\026\n\002id\030\001 "
  "\002(\0162\n.vision.ID\022\020\n\010distance\030\002 \002(\001\022\r\n\005lev"
  "el\030\003 \002(\005\"1\n\tSmokeWarn\022\026\n\002id\030\001 \002(\0162\n.visi"
  "on.ID\022\014\n\004warn\030\002 \002(\010\"+\n\tTimestamp\022\017\n\007seco"
  "nds\030\001 \002(\003\022\r\n\005nanos\030\002 \002(\005\"\330\001\n\014Detectobjec"
  "t\022\021\n\tobject_id\030\001 \002(\005\022!\n\013object_type\030\002 \002("
  "\0162\014.vision.TYPE\022\025\n\rlongitudinalX\030\003 \002(\005\022\020"
  "\n\010lateralY\030\004 \002(\005\022\020\n\010velocity\030\005 \002(\005\022\016\n\006ca"
  "mera\030\006 \002(\005\022\022\n\nif_at_lane\030\007 \001(\005\022\017\n\007lane_i"
  "d\030\010 \001(\005\022\017\n\007heading\030\t \001(\005\022\021\n\tlane_type\030\n "
  "\001(\005\"n\n\rDetectobjects\022\026\n\002id\030\001 \002(\0162\n.visio"
  "n.ID\022$\n\006object\030\002 \003(\0132\024.vision.Detectobje"
  "ct\022\037\n\004time\030\003 \001(\0132\021.vision.Timestamp\"c\n\nT"
  "rafficJam\022\026\n\002id\030\001 \002(\0162\n.vision.ID\022\034\n\003jam"
  "\030\002 \003(\0132\017.vision.JamInfo\022\037\n\004time\030\003 \001(\0132\021."
  "vision.data_time\"f\n\013TrafficFlow\022\026\n\002id\030\001 "
  "\002(\0162\n.vision.ID\022\036\n\004flow\030\002 \003(\0132\020.vision.F"
  "lowInfo\022\037\n\004time\030\003 \001(\0132\021.vision.data_time"
  "\"/\n\007IceWarn\022\026\n\002id\030\001 \002(\0162\n.vision.ID\022\014\n\004w"
  "arn\030\002 \002(\010\"\346\001\n\010LaneWare\022\026\n\002id\030\001 \002(\0162\n.vis"
  "ion.ID\022,\n\tware_type\030\002 \002(\0162\031.vision.LaneW"
  "are.WARETYPE\022\014\n\004lng1\030\003 \002(\005\022\014\n\004lat1\030\004 \002(\005"
  "\022\014\n\004lng2\030\005 \002(\005\022\014\n\004lat2\030\006 \002(\005\022\017\n\007heading\030"
  "\007 \001(\005\"K\n\010WARETYPE\022\013\n\007DEFAULT\020\000\022\014\n\010FULLLI"
  "NE\020\001\022\016\n\nDOTTEDLINE\020\002\022\024\n\020DOUBLEYELLOWLINE"
  "\020\003\"k\n\rSpecialCarMsg\022\026\n\002id\030\001 \002(\0162\n.vision"
  ".ID\022!\n\005array\030\002 \003(\0132\022.vision.SpecialCar\022\037"
  "\n\004time\030\003 \001(\0132\021.vision.data_time*\264\002\n\002ID\022\013"
  "\n\007DEFAULT\020\000\022\020\n\014PEDESTRIAN_D\020\001\022\016\n\nILLEGAL"
  "_V1\020\002\022\016\n\nVISIBILITY\020\003\022\022\n\016AVAILABLE_AREA\020"
  "\004\022\020\n\014ABNORMAL_CAR\020\005\022\016\n\nILLEGAL_V2\020\006\022\022\n\016T"
  "RAFFIC_STATUS\020\007\022\024\n\020BACKWARD_DRIVING\020\010\022\017\n"
  "\013ROAD_DANGER\020\t\022\016\n\nFIRE_SMOKE\020\n\022\021\n\rDETECT"
  "OBJECTS\020\013\022\017\n\013TRAFFIC_JAM\020\014\022\020\n\014TRAFFIC_FL"
  "OW\020\r\022\016\n\nSPECIALCAR\020\016\022\014\n\010ACCIDENT\020\017\022\013\n\007IC"
  "EWARN\020\020\022\r\n\tLANE_WARE\020\021*F\n\004TYPE\022\n\n\006OTHERS"
  "\020\000\022\t\n\005HUMAN\020\001\022\013\n\007VEHICLE\020\002\022\016\n\nMOTORCYCLE"
  "\020\003\022\n\n\006ANIMAL\020\004*h\n\014ABNORMALTYPE\022\r\n\tDEFAUL"
  "T_A\020\000\022\r\n\tSTOP_CAR1\020\001\022\r\n\tSTOP_CAR2\020\002\022\030\n\024C"
  "ONTINUOUS_DIVERSION\020\003\022\021\n\rLINE_PRESSING\020\004"
  ;
static ::google::protobuf::internal::DescriptorTable descriptor_table_vision_2eproto = {
  false, InitDefaults_vision_2eproto, 
  descriptor_table_protodef_vision_2eproto,
  "vision.proto", &assign_descriptors_table_vision_2eproto, 3400,
};

void AddDescriptors_vision_2eproto() {
  static constexpr ::google::protobuf::internal::InitFunc deps[1] =
  {
  };
 ::google::protobuf::internal::AddDescriptors(&descriptor_table_vision_2eproto, deps, 0);
}

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_vision_2eproto = []() { AddDescriptors_vision_2eproto(); return true; }();
namespace vision {
const ::google::protobuf::EnumDescriptor* SpecialCar_SPECIALTYPE_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_vision_2eproto);
  return file_level_enum_descriptors_vision_2eproto[0];
}
bool SpecialCar_SPECIALTYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr SpecialCar_SPECIALTYPE SpecialCar::NORMAL;
constexpr SpecialCar_SPECIALTYPE SpecialCar::AMBULANCE;
constexpr SpecialCar_SPECIALTYPE SpecialCar::DANGERCAR;
constexpr SpecialCar_SPECIALTYPE SpecialCar::FIREENGINE;
constexpr SpecialCar_SPECIALTYPE SpecialCar::SPECIALTYPE_MIN;
constexpr SpecialCar_SPECIALTYPE SpecialCar::SPECIALTYPE_MAX;
constexpr int SpecialCar::SPECIALTYPE_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::google::protobuf::EnumDescriptor* FlowInfo_TrafficSig_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_vision_2eproto);
  return file_level_enum_descriptors_vision_2eproto[1];
}
bool FlowInfo_TrafficSig_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr FlowInfo_TrafficSig FlowInfo::UNKNOWN;
constexpr FlowInfo_TrafficSig FlowInfo::Y2G;
constexpr FlowInfo_TrafficSig FlowInfo::OVER;
constexpr FlowInfo_TrafficSig FlowInfo::TrafficSig_MIN;
constexpr FlowInfo_TrafficSig FlowInfo::TrafficSig_MAX;
constexpr int FlowInfo::TrafficSig_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::google::protobuf::EnumDescriptor* LaneWare_WARETYPE_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_vision_2eproto);
  return file_level_enum_descriptors_vision_2eproto[2];
}
bool LaneWare_WARETYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr LaneWare_WARETYPE LaneWare::DEFAULT;
constexpr LaneWare_WARETYPE LaneWare::FULLLINE;
constexpr LaneWare_WARETYPE LaneWare::DOTTEDLINE;
constexpr LaneWare_WARETYPE LaneWare::DOUBLEYELLOWLINE;
constexpr LaneWare_WARETYPE LaneWare::WARETYPE_MIN;
constexpr LaneWare_WARETYPE LaneWare::WARETYPE_MAX;
constexpr int LaneWare::WARETYPE_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::google::protobuf::EnumDescriptor* ID_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_vision_2eproto);
  return file_level_enum_descriptors_vision_2eproto[3];
}
bool ID_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TYPE_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_vision_2eproto);
  return file_level_enum_descriptors_vision_2eproto[4];
}
bool TYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ABNORMALTYPE_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_vision_2eproto);
  return file_level_enum_descriptors_vision_2eproto[5];
}
bool ABNORMALTYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void data_time::InitAsDefaultInstance() {
}
class data_time::HasBitSetters {
 public:
  static void set_has_sec(data_time* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_usec(data_time* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int data_time::kSecFieldNumber;
const int data_time::kUsecFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

data_time::data_time()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.data_time)
}
data_time::data_time(const data_time& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&sec_, &from.sec_,
    static_cast<size_t>(reinterpret_cast<char*>(&usec_) -
    reinterpret_cast<char*>(&sec_)) + sizeof(usec_));
  // @@protoc_insertion_point(copy_constructor:vision.data_time)
}

void data_time::SharedCtor() {
  ::memset(&sec_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&usec_) -
      reinterpret_cast<char*>(&sec_)) + sizeof(usec_));
}

data_time::~data_time() {
  // @@protoc_insertion_point(destructor:vision.data_time)
  SharedDtor();
}

void data_time::SharedDtor() {
}

void data_time::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const data_time& data_time::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_data_time_vision_2eproto.base);
  return *internal_default_instance();
}


void data_time::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.data_time)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&sec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&usec_) -
        reinterpret_cast<char*>(&sec_)) + sizeof(usec_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* data_time::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required uint64 sec = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_sec(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required uint32 usec = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        set_usec(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool data_time::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.data_time)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 sec = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_sec(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &sec_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 usec = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_usec(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &usec_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.data_time)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.data_time)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void data_time::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.data_time)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 sec = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->sec(), output);
  }

  // required uint32 usec = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->usec(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.data_time)
}

::google::protobuf::uint8* data_time::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.data_time)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 sec = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->sec(), target);
  }

  // required uint32 usec = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->usec(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.data_time)
  return target;
}

size_t data_time::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.data_time)
  size_t total_size = 0;

  if (has_sec()) {
    // required uint64 sec = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->sec());
  }

  if (has_usec()) {
    // required uint32 usec = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->usec());
  }

  return total_size;
}
size_t data_time::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.data_time)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 sec = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->sec());

    // required uint32 usec = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->usec());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void data_time::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.data_time)
  GOOGLE_DCHECK_NE(&from, this);
  const data_time* source =
      ::google::protobuf::DynamicCastToGenerated<data_time>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.data_time)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.data_time)
    MergeFrom(*source);
  }
}

void data_time::MergeFrom(const data_time& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.data_time)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sec_ = from.sec_;
    }
    if (cached_has_bits & 0x00000002u) {
      usec_ = from.usec_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void data_time::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.data_time)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void data_time::CopyFrom(const data_time& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.data_time)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool data_time::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void data_time::Swap(data_time* other) {
  if (other == this) return;
  InternalSwap(other);
}
void data_time::InternalSwap(data_time* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(sec_, other->sec_);
  swap(usec_, other->usec_);
}

::google::protobuf::Metadata data_time::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Pedestrian::InitAsDefaultInstance() {
}
class Pedestrian::HasBitSetters {
 public:
  static void set_has_object_id(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_object_type(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lng(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_lat(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_camera(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_if_at_lane(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_lane_id(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_heading(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_approach_judge(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static void set_has_speed(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
  static void set_has_people_heading(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000400u;
  }
  static void set_has_lane_type(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000800u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Pedestrian::kObjectIdFieldNumber;
const int Pedestrian::kObjectTypeFieldNumber;
const int Pedestrian::kLngFieldNumber;
const int Pedestrian::kLatFieldNumber;
const int Pedestrian::kCameraFieldNumber;
const int Pedestrian::kIfAtLaneFieldNumber;
const int Pedestrian::kLaneIdFieldNumber;
const int Pedestrian::kHeadingFieldNumber;
const int Pedestrian::kApproachJudgeFieldNumber;
const int Pedestrian::kSpeedFieldNumber;
const int Pedestrian::kPeopleHeadingFieldNumber;
const int Pedestrian::kLaneTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Pedestrian::Pedestrian()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.Pedestrian)
}
Pedestrian::Pedestrian(const Pedestrian& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&object_id_, &from.object_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&lane_type_) -
    reinterpret_cast<char*>(&object_id_)) + sizeof(lane_type_));
  // @@protoc_insertion_point(copy_constructor:vision.Pedestrian)
}

void Pedestrian::SharedCtor() {
  ::memset(&object_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lane_type_) -
      reinterpret_cast<char*>(&object_id_)) + sizeof(lane_type_));
}

Pedestrian::~Pedestrian() {
  // @@protoc_insertion_point(destructor:vision.Pedestrian)
  SharedDtor();
}

void Pedestrian::SharedDtor() {
}

void Pedestrian::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Pedestrian& Pedestrian::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Pedestrian_vision_2eproto.base);
  return *internal_default_instance();
}


void Pedestrian::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.Pedestrian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&object_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&heading_) -
        reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&approach_judge_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lane_type_) -
        reinterpret_cast<char*>(&approach_judge_)) + sizeof(lane_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Pedestrian::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_object_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required .vision.TYPE object_type = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::TYPE_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(2, val, mutable_unknown_fields());
          break;
        }
        set_object_type(static_cast<::vision::TYPE>(val));
        break;
      }
      // required int32 lng = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_lng(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lat = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        set_lat(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 camera = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        set_camera(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 if_at_lane = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        set_if_at_lane(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_id = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        set_lane_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 heading = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 64) goto handle_unusual;
        set_heading(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 approach_judge = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 72) goto handle_unusual;
        set_approach_judge(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 speed = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 80) goto handle_unusual;
        set_speed(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 people_heading = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 88) goto handle_unusual;
        set_people_heading(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_type = 12;
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 96) goto handle_unusual;
        set_lane_type(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Pedestrian::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.Pedestrian)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_object_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .vision.TYPE object_type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::TYPE_IsValid(value)) {
            set_object_type(static_cast< ::vision::TYPE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lng = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_lng(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lng_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lat = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_lat(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lat_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 camera = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_camera(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &camera_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 if_at_lane = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_if_at_lane(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &if_at_lane_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_id = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_lane_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 heading = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 approach_judge = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_approach_judge(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &approach_judge_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 speed = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (80 & 0xFF)) {
          HasBitSetters::set_has_speed(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &speed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 people_heading = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (88 & 0xFF)) {
          HasBitSetters::set_has_people_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &people_heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_type = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (96 & 0xFF)) {
          HasBitSetters::set_has_lane_type(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_type_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.Pedestrian)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.Pedestrian)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Pedestrian::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.Pedestrian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->object_id(), output);
  }

  // required .vision.TYPE object_type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->object_type(), output);
  }

  // required int32 lng = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lng(), output);
  }

  // required int32 lat = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->lat(), output);
  }

  // required int32 camera = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->camera(), output);
  }

  // optional int32 if_at_lane = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->if_at_lane(), output);
  }

  // optional int32 lane_id = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->lane_id(), output);
  }

  // optional int32 heading = 8;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->heading(), output);
  }

  // optional int32 approach_judge = 9;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->approach_judge(), output);
  }

  // optional int32 speed = 10;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->speed(), output);
  }

  // optional int32 people_heading = 11;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->people_heading(), output);
  }

  // optional int32 lane_type = 12;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->lane_type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.Pedestrian)
}

::google::protobuf::uint8* Pedestrian::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.Pedestrian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->object_id(), target);
  }

  // required .vision.TYPE object_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->object_type(), target);
  }

  // required int32 lng = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->lng(), target);
  }

  // required int32 lat = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->lat(), target);
  }

  // required int32 camera = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->camera(), target);
  }

  // optional int32 if_at_lane = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->if_at_lane(), target);
  }

  // optional int32 lane_id = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->lane_id(), target);
  }

  // optional int32 heading = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->heading(), target);
  }

  // optional int32 approach_judge = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->approach_judge(), target);
  }

  // optional int32 speed = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->speed(), target);
  }

  // optional int32 people_heading = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->people_heading(), target);
  }

  // optional int32 lane_type = 12;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(12, this->lane_type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.Pedestrian)
  return target;
}

size_t Pedestrian::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.Pedestrian)
  size_t total_size = 0;

  if (has_object_id()) {
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());
  }

  if (has_object_type()) {
    // required .vision.TYPE object_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->object_type());
  }

  if (has_lng()) {
    // required int32 lng = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng());
  }

  if (has_lat()) {
    // required int32 lat = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat());
  }

  if (has_camera()) {
    // required int32 camera = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());
  }

  return total_size;
}
size_t Pedestrian::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.Pedestrian)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());

    // required .vision.TYPE object_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->object_type());

    // required int32 lng = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng());

    // required int32 lat = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat());

    // required int32 camera = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000e0u) {
    // optional int32 if_at_lane = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->if_at_lane());
    }

    // optional int32 lane_id = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lane_id());
    }

    // optional int32 heading = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->heading());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional int32 approach_judge = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->approach_judge());
    }

    // optional int32 speed = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->speed());
    }

    // optional int32 people_heading = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->people_heading());
    }

    // optional int32 lane_type = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lane_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Pedestrian::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.Pedestrian)
  GOOGLE_DCHECK_NE(&from, this);
  const Pedestrian* source =
      ::google::protobuf::DynamicCastToGenerated<Pedestrian>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.Pedestrian)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.Pedestrian)
    MergeFrom(*source);
  }
}

void Pedestrian::MergeFrom(const Pedestrian& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.Pedestrian)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      object_id_ = from.object_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      object_type_ = from.object_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      lng_ = from.lng_;
    }
    if (cached_has_bits & 0x00000008u) {
      lat_ = from.lat_;
    }
    if (cached_has_bits & 0x00000010u) {
      camera_ = from.camera_;
    }
    if (cached_has_bits & 0x00000020u) {
      if_at_lane_ = from.if_at_lane_;
    }
    if (cached_has_bits & 0x00000040u) {
      lane_id_ = from.lane_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      heading_ = from.heading_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      approach_judge_ = from.approach_judge_;
    }
    if (cached_has_bits & 0x00000200u) {
      speed_ = from.speed_;
    }
    if (cached_has_bits & 0x00000400u) {
      people_heading_ = from.people_heading_;
    }
    if (cached_has_bits & 0x00000800u) {
      lane_type_ = from.lane_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Pedestrian::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.Pedestrian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Pedestrian::CopyFrom(const Pedestrian& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.Pedestrian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pedestrian::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  return true;
}

void Pedestrian::Swap(Pedestrian* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Pedestrian::InternalSwap(Pedestrian* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(object_id_, other->object_id_);
  swap(object_type_, other->object_type_);
  swap(lng_, other->lng_);
  swap(lat_, other->lat_);
  swap(camera_, other->camera_);
  swap(if_at_lane_, other->if_at_lane_);
  swap(lane_id_, other->lane_id_);
  swap(heading_, other->heading_);
  swap(approach_judge_, other->approach_judge_);
  swap(speed_, other->speed_);
  swap(people_heading_, other->people_heading_);
  swap(lane_type_, other->lane_type_);
}

::google::protobuf::Metadata Pedestrian::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Obstacle::InitAsDefaultInstance() {
}
class Obstacle::HasBitSetters {
 public:
  static void set_has_object_id(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_lng(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lat(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_camera(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_if_at_lane(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_lane_id(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_heading(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_length(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_width(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static void set_has_height(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Obstacle::kObjectIdFieldNumber;
const int Obstacle::kLngFieldNumber;
const int Obstacle::kLatFieldNumber;
const int Obstacle::kCameraFieldNumber;
const int Obstacle::kIfAtLaneFieldNumber;
const int Obstacle::kLaneIdFieldNumber;
const int Obstacle::kHeadingFieldNumber;
const int Obstacle::kLengthFieldNumber;
const int Obstacle::kWidthFieldNumber;
const int Obstacle::kHeightFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Obstacle::Obstacle()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.Obstacle)
}
Obstacle::Obstacle(const Obstacle& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&object_id_, &from.object_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&object_id_)) + sizeof(height_));
  // @@protoc_insertion_point(copy_constructor:vision.Obstacle)
}

void Obstacle::SharedCtor() {
  ::memset(&object_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&height_) -
      reinterpret_cast<char*>(&object_id_)) + sizeof(height_));
}

Obstacle::~Obstacle() {
  // @@protoc_insertion_point(destructor:vision.Obstacle)
  SharedDtor();
}

void Obstacle::SharedDtor() {
}

void Obstacle::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Obstacle& Obstacle::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Obstacle_vision_2eproto.base);
  return *internal_default_instance();
}


void Obstacle::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.Obstacle)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&object_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&length_) -
        reinterpret_cast<char*>(&object_id_)) + sizeof(length_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&height_) -
        reinterpret_cast<char*>(&width_)) + sizeof(height_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Obstacle::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_object_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lng = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        set_lng(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lat = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_lat(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 camera = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        set_camera(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 if_at_lane = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        set_if_at_lane(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_id = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        set_lane_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 heading = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        set_heading(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 length = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 64) goto handle_unusual;
        set_length(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 width = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 72) goto handle_unusual;
        set_width(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 height = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 80) goto handle_unusual;
        set_height(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Obstacle::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.Obstacle)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_object_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lng = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_lng(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lng_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lat = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_lat(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lat_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 camera = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_camera(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &camera_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 if_at_lane = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_if_at_lane(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &if_at_lane_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_id = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_lane_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 heading = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 length = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_length(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 width = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_width(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &width_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 height = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (80 & 0xFF)) {
          HasBitSetters::set_has_height(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &height_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.Obstacle)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.Obstacle)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Obstacle::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.Obstacle)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->object_id(), output);
  }

  // required int32 lng = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->lng(), output);
  }

  // required int32 lat = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lat(), output);
  }

  // required int32 camera = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->camera(), output);
  }

  // optional int32 if_at_lane = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->if_at_lane(), output);
  }

  // optional int32 lane_id = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->lane_id(), output);
  }

  // optional int32 heading = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->heading(), output);
  }

  // optional int32 length = 8;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->length(), output);
  }

  // optional int32 width = 9;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->width(), output);
  }

  // optional int32 height = 10;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->height(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.Obstacle)
}

::google::protobuf::uint8* Obstacle::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.Obstacle)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->object_id(), target);
  }

  // required int32 lng = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->lng(), target);
  }

  // required int32 lat = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->lat(), target);
  }

  // required int32 camera = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->camera(), target);
  }

  // optional int32 if_at_lane = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->if_at_lane(), target);
  }

  // optional int32 lane_id = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->lane_id(), target);
  }

  // optional int32 heading = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->heading(), target);
  }

  // optional int32 length = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->length(), target);
  }

  // optional int32 width = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->width(), target);
  }

  // optional int32 height = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->height(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.Obstacle)
  return target;
}

size_t Obstacle::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.Obstacle)
  size_t total_size = 0;

  if (has_object_id()) {
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());
  }

  if (has_lng()) {
    // required int32 lng = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng());
  }

  if (has_lat()) {
    // required int32 lat = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat());
  }

  if (has_camera()) {
    // required int32 camera = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());
  }

  return total_size;
}
size_t Obstacle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.Obstacle)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());

    // required int32 lng = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng());

    // required int32 lat = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat());

    // required int32 camera = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000f0u) {
    // optional int32 if_at_lane = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->if_at_lane());
    }

    // optional int32 lane_id = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lane_id());
    }

    // optional int32 heading = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->heading());
    }

    // optional int32 length = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->length());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional int32 width = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->width());
    }

    // optional int32 height = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->height());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Obstacle::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.Obstacle)
  GOOGLE_DCHECK_NE(&from, this);
  const Obstacle* source =
      ::google::protobuf::DynamicCastToGenerated<Obstacle>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.Obstacle)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.Obstacle)
    MergeFrom(*source);
  }
}

void Obstacle::MergeFrom(const Obstacle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.Obstacle)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      object_id_ = from.object_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      lng_ = from.lng_;
    }
    if (cached_has_bits & 0x00000004u) {
      lat_ = from.lat_;
    }
    if (cached_has_bits & 0x00000008u) {
      camera_ = from.camera_;
    }
    if (cached_has_bits & 0x00000010u) {
      if_at_lane_ = from.if_at_lane_;
    }
    if (cached_has_bits & 0x00000020u) {
      lane_id_ = from.lane_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      heading_ = from.heading_;
    }
    if (cached_has_bits & 0x00000080u) {
      length_ = from.length_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000200u) {
      height_ = from.height_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Obstacle::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.Obstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Obstacle::CopyFrom(const Obstacle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.Obstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Obstacle::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  return true;
}

void Obstacle::Swap(Obstacle* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Obstacle::InternalSwap(Obstacle* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(object_id_, other->object_id_);
  swap(lng_, other->lng_);
  swap(lat_, other->lat_);
  swap(camera_, other->camera_);
  swap(if_at_lane_, other->if_at_lane_);
  swap(lane_id_, other->lane_id_);
  swap(heading_, other->heading_);
  swap(length_, other->length_);
  swap(width_, other->width_);
  swap(height_, other->height_);
}

::google::protobuf::Metadata Obstacle::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void AbnormalCar::InitAsDefaultInstance() {
}
class AbnormalCar::HasBitSetters {
 public:
  static void set_has_object_id(AbnormalCar* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_lng(AbnormalCar* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lat(AbnormalCar* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_lane_id(AbnormalCar* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_camera(AbnormalCar* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_abnormal_type(AbnormalCar* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AbnormalCar::kObjectIdFieldNumber;
const int AbnormalCar::kLngFieldNumber;
const int AbnormalCar::kLatFieldNumber;
const int AbnormalCar::kLaneIdFieldNumber;
const int AbnormalCar::kCameraFieldNumber;
const int AbnormalCar::kAbnormalTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AbnormalCar::AbnormalCar()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.AbnormalCar)
}
AbnormalCar::AbnormalCar(const AbnormalCar& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&object_id_, &from.object_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&abnormal_type_) -
    reinterpret_cast<char*>(&object_id_)) + sizeof(abnormal_type_));
  // @@protoc_insertion_point(copy_constructor:vision.AbnormalCar)
}

void AbnormalCar::SharedCtor() {
  ::memset(&object_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&abnormal_type_) -
      reinterpret_cast<char*>(&object_id_)) + sizeof(abnormal_type_));
}

AbnormalCar::~AbnormalCar() {
  // @@protoc_insertion_point(destructor:vision.AbnormalCar)
  SharedDtor();
}

void AbnormalCar::SharedDtor() {
}

void AbnormalCar::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AbnormalCar& AbnormalCar::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_AbnormalCar_vision_2eproto.base);
  return *internal_default_instance();
}


void AbnormalCar::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.AbnormalCar)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&object_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&abnormal_type_) -
        reinterpret_cast<char*>(&object_id_)) + sizeof(abnormal_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AbnormalCar::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_object_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lng = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        set_lng(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lat = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_lat(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_id = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        set_lane_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 camera = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        set_camera(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .vision.ABNORMALTYPE abnormal_type = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ABNORMALTYPE_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(6, val, mutable_unknown_fields());
          break;
        }
        set_abnormal_type(static_cast<::vision::ABNORMALTYPE>(val));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AbnormalCar::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.AbnormalCar)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_object_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lng = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_lng(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lng_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lat = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_lat(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lat_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_id = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_lane_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 camera = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_camera(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &camera_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .vision.ABNORMALTYPE abnormal_type = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ABNORMALTYPE_IsValid(value)) {
            set_abnormal_type(static_cast< ::vision::ABNORMALTYPE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                6, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.AbnormalCar)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.AbnormalCar)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AbnormalCar::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.AbnormalCar)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->object_id(), output);
  }

  // required int32 lng = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->lng(), output);
  }

  // required int32 lat = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lat(), output);
  }

  // optional int32 lane_id = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->lane_id(), output);
  }

  // optional int32 camera = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->camera(), output);
  }

  // optional .vision.ABNORMALTYPE abnormal_type = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->abnormal_type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.AbnormalCar)
}

::google::protobuf::uint8* AbnormalCar::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.AbnormalCar)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->object_id(), target);
  }

  // required int32 lng = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->lng(), target);
  }

  // required int32 lat = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->lat(), target);
  }

  // optional int32 lane_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->lane_id(), target);
  }

  // optional int32 camera = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->camera(), target);
  }

  // optional .vision.ABNORMALTYPE abnormal_type = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->abnormal_type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.AbnormalCar)
  return target;
}

size_t AbnormalCar::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.AbnormalCar)
  size_t total_size = 0;

  if (has_object_id()) {
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());
  }

  if (has_lng()) {
    // required int32 lng = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng());
  }

  if (has_lat()) {
    // required int32 lat = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat());
  }

  return total_size;
}
size_t AbnormalCar::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.AbnormalCar)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());

    // required int32 lng = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng());

    // required int32 lat = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000038u) {
    // optional int32 lane_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lane_id());
    }

    // optional int32 camera = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->camera());
    }

    // optional .vision.ABNORMALTYPE abnormal_type = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->abnormal_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AbnormalCar::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.AbnormalCar)
  GOOGLE_DCHECK_NE(&from, this);
  const AbnormalCar* source =
      ::google::protobuf::DynamicCastToGenerated<AbnormalCar>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.AbnormalCar)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.AbnormalCar)
    MergeFrom(*source);
  }
}

void AbnormalCar::MergeFrom(const AbnormalCar& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.AbnormalCar)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      object_id_ = from.object_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      lng_ = from.lng_;
    }
    if (cached_has_bits & 0x00000004u) {
      lat_ = from.lat_;
    }
    if (cached_has_bits & 0x00000008u) {
      lane_id_ = from.lane_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      camera_ = from.camera_;
    }
    if (cached_has_bits & 0x00000020u) {
      abnormal_type_ = from.abnormal_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AbnormalCar::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.AbnormalCar)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AbnormalCar::CopyFrom(const AbnormalCar& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.AbnormalCar)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AbnormalCar::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  return true;
}

void AbnormalCar::Swap(AbnormalCar* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AbnormalCar::InternalSwap(AbnormalCar* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(object_id_, other->object_id_);
  swap(lng_, other->lng_);
  swap(lat_, other->lat_);
  swap(lane_id_, other->lane_id_);
  swap(camera_, other->camera_);
  swap(abnormal_type_, other->abnormal_type_);
}

::google::protobuf::Metadata AbnormalCar::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SpecialCar::InitAsDefaultInstance() {
}
class SpecialCar::HasBitSetters {
 public:
  static void set_has_object_id(SpecialCar* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_special_type(SpecialCar* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lng(SpecialCar* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_lat(SpecialCar* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_camera(SpecialCar* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_lane_id(SpecialCar* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_heading(SpecialCar* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_lane_type(SpecialCar* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SpecialCar::kObjectIdFieldNumber;
const int SpecialCar::kSpecialTypeFieldNumber;
const int SpecialCar::kLngFieldNumber;
const int SpecialCar::kLatFieldNumber;
const int SpecialCar::kCameraFieldNumber;
const int SpecialCar::kLaneIdFieldNumber;
const int SpecialCar::kHeadingFieldNumber;
const int SpecialCar::kLaneTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SpecialCar::SpecialCar()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.SpecialCar)
}
SpecialCar::SpecialCar(const SpecialCar& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&object_id_, &from.object_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&lane_type_) -
    reinterpret_cast<char*>(&object_id_)) + sizeof(lane_type_));
  // @@protoc_insertion_point(copy_constructor:vision.SpecialCar)
}

void SpecialCar::SharedCtor() {
  ::memset(&object_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lane_type_) -
      reinterpret_cast<char*>(&object_id_)) + sizeof(lane_type_));
}

SpecialCar::~SpecialCar() {
  // @@protoc_insertion_point(destructor:vision.SpecialCar)
  SharedDtor();
}

void SpecialCar::SharedDtor() {
}

void SpecialCar::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SpecialCar& SpecialCar::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SpecialCar_vision_2eproto.base);
  return *internal_default_instance();
}


void SpecialCar::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.SpecialCar)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&object_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lane_type_) -
        reinterpret_cast<char*>(&object_id_)) + sizeof(lane_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SpecialCar::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_object_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required .vision.SpecialCar.SPECIALTYPE special_type = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::SpecialCar_SPECIALTYPE_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(2, val, mutable_unknown_fields());
          break;
        }
        set_special_type(static_cast<::vision::SpecialCar_SPECIALTYPE>(val));
        break;
      }
      // required int32 lng = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_lng(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lat = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        set_lat(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 camera = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        set_camera(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_id = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        set_lane_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 heading = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        set_heading(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_type = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 64) goto handle_unusual;
        set_lane_type(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SpecialCar::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.SpecialCar)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_object_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .vision.SpecialCar.SPECIALTYPE special_type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::SpecialCar_SPECIALTYPE_IsValid(value)) {
            set_special_type(static_cast< ::vision::SpecialCar_SPECIALTYPE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lng = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_lng(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lng_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lat = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_lat(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lat_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 camera = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_camera(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &camera_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_id = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_lane_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 heading = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_type = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_lane_type(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_type_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.SpecialCar)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.SpecialCar)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SpecialCar::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.SpecialCar)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->object_id(), output);
  }

  // required .vision.SpecialCar.SPECIALTYPE special_type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->special_type(), output);
  }

  // required int32 lng = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lng(), output);
  }

  // required int32 lat = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->lat(), output);
  }

  // required int32 camera = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->camera(), output);
  }

  // optional int32 lane_id = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->lane_id(), output);
  }

  // optional int32 heading = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->heading(), output);
  }

  // optional int32 lane_type = 8;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->lane_type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.SpecialCar)
}

::google::protobuf::uint8* SpecialCar::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.SpecialCar)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->object_id(), target);
  }

  // required .vision.SpecialCar.SPECIALTYPE special_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->special_type(), target);
  }

  // required int32 lng = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->lng(), target);
  }

  // required int32 lat = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->lat(), target);
  }

  // required int32 camera = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->camera(), target);
  }

  // optional int32 lane_id = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->lane_id(), target);
  }

  // optional int32 heading = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->heading(), target);
  }

  // optional int32 lane_type = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->lane_type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.SpecialCar)
  return target;
}

size_t SpecialCar::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.SpecialCar)
  size_t total_size = 0;

  if (has_object_id()) {
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());
  }

  if (has_special_type()) {
    // required .vision.SpecialCar.SPECIALTYPE special_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->special_type());
  }

  if (has_lng()) {
    // required int32 lng = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng());
  }

  if (has_lat()) {
    // required int32 lat = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat());
  }

  if (has_camera()) {
    // required int32 camera = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());
  }

  return total_size;
}
size_t SpecialCar::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.SpecialCar)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());

    // required .vision.SpecialCar.SPECIALTYPE special_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->special_type());

    // required int32 lng = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng());

    // required int32 lat = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat());

    // required int32 camera = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000e0u) {
    // optional int32 lane_id = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lane_id());
    }

    // optional int32 heading = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->heading());
    }

    // optional int32 lane_type = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lane_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SpecialCar::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.SpecialCar)
  GOOGLE_DCHECK_NE(&from, this);
  const SpecialCar* source =
      ::google::protobuf::DynamicCastToGenerated<SpecialCar>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.SpecialCar)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.SpecialCar)
    MergeFrom(*source);
  }
}

void SpecialCar::MergeFrom(const SpecialCar& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.SpecialCar)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      object_id_ = from.object_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      special_type_ = from.special_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      lng_ = from.lng_;
    }
    if (cached_has_bits & 0x00000008u) {
      lat_ = from.lat_;
    }
    if (cached_has_bits & 0x00000010u) {
      camera_ = from.camera_;
    }
    if (cached_has_bits & 0x00000020u) {
      lane_id_ = from.lane_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      heading_ = from.heading_;
    }
    if (cached_has_bits & 0x00000080u) {
      lane_type_ = from.lane_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SpecialCar::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.SpecialCar)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SpecialCar::CopyFrom(const SpecialCar& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.SpecialCar)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpecialCar::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  return true;
}

void SpecialCar::Swap(SpecialCar* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SpecialCar::InternalSwap(SpecialCar* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(object_id_, other->object_id_);
  swap(special_type_, other->special_type_);
  swap(lng_, other->lng_);
  swap(lat_, other->lat_);
  swap(camera_, other->camera_);
  swap(lane_id_, other->lane_id_);
  swap(heading_, other->heading_);
  swap(lane_type_, other->lane_type_);
}

::google::protobuf::Metadata SpecialCar::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void AvailableArea::InitAsDefaultInstance() {
}
class AvailableArea::HasBitSetters {
 public:
  static void set_has_object_id(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_lng1(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lat1(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_lng2(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_lat2(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_lng3(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_lat3(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_lng4(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_lat4(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static void set_has_camera(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
  static void set_has_lane_id(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000400u;
  }
  static void set_has_heading(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000800u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AvailableArea::kObjectIdFieldNumber;
const int AvailableArea::kLng1FieldNumber;
const int AvailableArea::kLat1FieldNumber;
const int AvailableArea::kLng2FieldNumber;
const int AvailableArea::kLat2FieldNumber;
const int AvailableArea::kLng3FieldNumber;
const int AvailableArea::kLat3FieldNumber;
const int AvailableArea::kLng4FieldNumber;
const int AvailableArea::kLat4FieldNumber;
const int AvailableArea::kCameraFieldNumber;
const int AvailableArea::kLaneIdFieldNumber;
const int AvailableArea::kHeadingFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AvailableArea::AvailableArea()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.AvailableArea)
}
AvailableArea::AvailableArea(const AvailableArea& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&object_id_, &from.object_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&heading_) -
    reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
  // @@protoc_insertion_point(copy_constructor:vision.AvailableArea)
}

void AvailableArea::SharedCtor() {
  ::memset(&object_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&heading_) -
      reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
}

AvailableArea::~AvailableArea() {
  // @@protoc_insertion_point(destructor:vision.AvailableArea)
  SharedDtor();
}

void AvailableArea::SharedDtor() {
}

void AvailableArea::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AvailableArea& AvailableArea::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_AvailableArea_vision_2eproto.base);
  return *internal_default_instance();
}


void AvailableArea::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.AvailableArea)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&object_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lng4_) -
        reinterpret_cast<char*>(&object_id_)) + sizeof(lng4_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&lat4_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&heading_) -
        reinterpret_cast<char*>(&lat4_)) + sizeof(heading_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AvailableArea::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_object_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lng1 = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        set_lng1(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lat1 = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_lat1(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lng2 = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        set_lng2(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lat2 = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        set_lat2(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lng3 = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        set_lng3(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lat3 = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        set_lat3(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lng4 = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 64) goto handle_unusual;
        set_lng4(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lat4 = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 72) goto handle_unusual;
        set_lat4(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 camera = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 80) goto handle_unusual;
        set_camera(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_id = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 88) goto handle_unusual;
        set_lane_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 heading = 12;
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 96) goto handle_unusual;
        set_heading(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AvailableArea::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.AvailableArea)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_object_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lng1 = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_lng1(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lng1_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lat1 = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_lat1(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lat1_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lng2 = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_lng2(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lng2_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lat2 = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_lat2(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lat2_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lng3 = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_lng3(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lng3_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lat3 = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_lat3(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lat3_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lng4 = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_lng4(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lng4_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lat4 = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_lat4(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lat4_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 camera = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (80 & 0xFF)) {
          HasBitSetters::set_has_camera(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &camera_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_id = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (88 & 0xFF)) {
          HasBitSetters::set_has_lane_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 heading = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (96 & 0xFF)) {
          HasBitSetters::set_has_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.AvailableArea)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.AvailableArea)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AvailableArea::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.AvailableArea)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->object_id(), output);
  }

  // required int32 lng1 = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->lng1(), output);
  }

  // required int32 lat1 = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lat1(), output);
  }

  // required int32 lng2 = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->lng2(), output);
  }

  // required int32 lat2 = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->lat2(), output);
  }

  // required int32 lng3 = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->lng3(), output);
  }

  // required int32 lat3 = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->lat3(), output);
  }

  // required int32 lng4 = 8;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->lng4(), output);
  }

  // required int32 lat4 = 9;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->lat4(), output);
  }

  // required int32 camera = 10;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->camera(), output);
  }

  // optional int32 lane_id = 11;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->lane_id(), output);
  }

  // optional int32 heading = 12;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->heading(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.AvailableArea)
}

::google::protobuf::uint8* AvailableArea::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.AvailableArea)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->object_id(), target);
  }

  // required int32 lng1 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->lng1(), target);
  }

  // required int32 lat1 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->lat1(), target);
  }

  // required int32 lng2 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->lng2(), target);
  }

  // required int32 lat2 = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->lat2(), target);
  }

  // required int32 lng3 = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->lng3(), target);
  }

  // required int32 lat3 = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->lat3(), target);
  }

  // required int32 lng4 = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->lng4(), target);
  }

  // required int32 lat4 = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->lat4(), target);
  }

  // required int32 camera = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->camera(), target);
  }

  // optional int32 lane_id = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->lane_id(), target);
  }

  // optional int32 heading = 12;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(12, this->heading(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.AvailableArea)
  return target;
}

size_t AvailableArea::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.AvailableArea)
  size_t total_size = 0;

  if (has_object_id()) {
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());
  }

  if (has_lng1()) {
    // required int32 lng1 = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng1());
  }

  if (has_lat1()) {
    // required int32 lat1 = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat1());
  }

  if (has_lng2()) {
    // required int32 lng2 = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng2());
  }

  if (has_lat2()) {
    // required int32 lat2 = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat2());
  }

  if (has_lng3()) {
    // required int32 lng3 = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng3());
  }

  if (has_lat3()) {
    // required int32 lat3 = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat3());
  }

  if (has_lng4()) {
    // required int32 lng4 = 8;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng4());
  }

  if (has_lat4()) {
    // required int32 lat4 = 9;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat4());
  }

  if (has_camera()) {
    // required int32 camera = 10;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());
  }

  return total_size;
}
size_t AvailableArea::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.AvailableArea)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x000003ff) ^ 0x000003ff) == 0) {  // All required fields are present.
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());

    // required int32 lng1 = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng1());

    // required int32 lat1 = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat1());

    // required int32 lng2 = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng2());

    // required int32 lat2 = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat2());

    // required int32 lng3 = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng3());

    // required int32 lat3 = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat3());

    // required int32 lng4 = 8;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng4());

    // required int32 lat4 = 9;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat4());

    // required int32 camera = 10;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000c00u) {
    // optional int32 lane_id = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lane_id());
    }

    // optional int32 heading = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->heading());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AvailableArea::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.AvailableArea)
  GOOGLE_DCHECK_NE(&from, this);
  const AvailableArea* source =
      ::google::protobuf::DynamicCastToGenerated<AvailableArea>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.AvailableArea)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.AvailableArea)
    MergeFrom(*source);
  }
}

void AvailableArea::MergeFrom(const AvailableArea& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.AvailableArea)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      object_id_ = from.object_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      lng1_ = from.lng1_;
    }
    if (cached_has_bits & 0x00000004u) {
      lat1_ = from.lat1_;
    }
    if (cached_has_bits & 0x00000008u) {
      lng2_ = from.lng2_;
    }
    if (cached_has_bits & 0x00000010u) {
      lat2_ = from.lat2_;
    }
    if (cached_has_bits & 0x00000020u) {
      lng3_ = from.lng3_;
    }
    if (cached_has_bits & 0x00000040u) {
      lat3_ = from.lat3_;
    }
    if (cached_has_bits & 0x00000080u) {
      lng4_ = from.lng4_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      lat4_ = from.lat4_;
    }
    if (cached_has_bits & 0x00000200u) {
      camera_ = from.camera_;
    }
    if (cached_has_bits & 0x00000400u) {
      lane_id_ = from.lane_id_;
    }
    if (cached_has_bits & 0x00000800u) {
      heading_ = from.heading_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AvailableArea::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.AvailableArea)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AvailableArea::CopyFrom(const AvailableArea& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.AvailableArea)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvailableArea::IsInitialized() const {
  if ((_has_bits_[0] & 0x000003ff) != 0x000003ff) return false;
  return true;
}

void AvailableArea::Swap(AvailableArea* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AvailableArea::InternalSwap(AvailableArea* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(object_id_, other->object_id_);
  swap(lng1_, other->lng1_);
  swap(lat1_, other->lat1_);
  swap(lng2_, other->lng2_);
  swap(lat2_, other->lat2_);
  swap(lng3_, other->lng3_);
  swap(lat3_, other->lat3_);
  swap(lng4_, other->lng4_);
  swap(lat4_, other->lat4_);
  swap(camera_, other->camera_);
  swap(lane_id_, other->lane_id_);
  swap(heading_, other->heading_);
}

::google::protobuf::Metadata AvailableArea::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void JamInfo::InitAsDefaultInstance() {
}
class JamInfo::HasBitSetters {
 public:
  static void set_has_vehicle_num(JamInfo* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_vehicle_avg_speed(JamInfo* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_road_yaw(JamInfo* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lane_id(JamInfo* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int JamInfo::kVehicleNumFieldNumber;
const int JamInfo::kVehicleAvgSpeedFieldNumber;
const int JamInfo::kRoadYawFieldNumber;
const int JamInfo::kVehicleFlowFieldNumber;
const int JamInfo::kLaneIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

JamInfo::JamInfo()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.JamInfo)
}
JamInfo::JamInfo(const JamInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      vehicle_flow_(from.vehicle_flow_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&vehicle_avg_speed_, &from.vehicle_avg_speed_,
    static_cast<size_t>(reinterpret_cast<char*>(&lane_id_) -
    reinterpret_cast<char*>(&vehicle_avg_speed_)) + sizeof(lane_id_));
  // @@protoc_insertion_point(copy_constructor:vision.JamInfo)
}

void JamInfo::SharedCtor() {
  ::memset(&vehicle_avg_speed_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lane_id_) -
      reinterpret_cast<char*>(&vehicle_avg_speed_)) + sizeof(lane_id_));
}

JamInfo::~JamInfo() {
  // @@protoc_insertion_point(destructor:vision.JamInfo)
  SharedDtor();
}

void JamInfo::SharedDtor() {
}

void JamInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const JamInfo& JamInfo::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_JamInfo_vision_2eproto.base);
  return *internal_default_instance();
}


void JamInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.JamInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vehicle_flow_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&vehicle_avg_speed_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lane_id_) -
        reinterpret_cast<char*>(&vehicle_avg_speed_)) + sizeof(lane_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* JamInfo::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required uint32 vehicle_num = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_vehicle_num(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required double vehicle_avg_speed = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        set_vehicle_avg_speed(::google::protobuf::internal::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // required double road_yaw = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        set_road_yaw(::google::protobuf::internal::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // repeated int32 vehicle_flow = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) == 32) {
          do {
            add_vehicle_flow(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ctx->Done(&ptr)) return ptr;
          } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 32 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::internal::PackedInt32Parser(mutable_vehicle_flow(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_id = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        set_lane_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool JamInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.JamInfo)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 vehicle_num = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_vehicle_num(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &vehicle_num_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required double vehicle_avg_speed = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          HasBitSetters::set_has_vehicle_avg_speed(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &vehicle_avg_speed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required double road_yaw = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {
          HasBitSetters::set_has_road_yaw(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &road_yaw_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 vehicle_flow = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 32u, input, this->mutable_vehicle_flow())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_vehicle_flow())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_id = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_lane_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.JamInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.JamInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void JamInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.JamInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 vehicle_num = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->vehicle_num(), output);
  }

  // required double vehicle_avg_speed = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->vehicle_avg_speed(), output);
  }

  // required double road_yaw = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->road_yaw(), output);
  }

  // repeated int32 vehicle_flow = 4;
  for (int i = 0, n = this->vehicle_flow_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      4, this->vehicle_flow(i), output);
  }

  // optional int32 lane_id = 5;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->lane_id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.JamInfo)
}

::google::protobuf::uint8* JamInfo::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.JamInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 vehicle_num = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->vehicle_num(), target);
  }

  // required double vehicle_avg_speed = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->vehicle_avg_speed(), target);
  }

  // required double road_yaw = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->road_yaw(), target);
  }

  // repeated int32 vehicle_flow = 4;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteInt32ToArray(4, this->vehicle_flow_, target);

  // optional int32 lane_id = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->lane_id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.JamInfo)
  return target;
}

size_t JamInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.JamInfo)
  size_t total_size = 0;

  if (has_vehicle_avg_speed()) {
    // required double vehicle_avg_speed = 2;
    total_size += 1 + 8;
  }

  if (has_road_yaw()) {
    // required double road_yaw = 3;
    total_size += 1 + 8;
  }

  if (has_vehicle_num()) {
    // required uint32 vehicle_num = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->vehicle_num());
  }

  return total_size;
}
size_t JamInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.JamInfo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required double vehicle_avg_speed = 2;
    total_size += 1 + 8;

    // required double road_yaw = 3;
    total_size += 1 + 8;

    // required uint32 vehicle_num = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->vehicle_num());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 vehicle_flow = 4;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int32Size(this->vehicle_flow_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->vehicle_flow_size());
    total_size += data_size;
  }

  // optional int32 lane_id = 5;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lane_id());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void JamInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.JamInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const JamInfo* source =
      ::google::protobuf::DynamicCastToGenerated<JamInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.JamInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.JamInfo)
    MergeFrom(*source);
  }
}

void JamInfo::MergeFrom(const JamInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.JamInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  vehicle_flow_.MergeFrom(from.vehicle_flow_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      vehicle_avg_speed_ = from.vehicle_avg_speed_;
    }
    if (cached_has_bits & 0x00000002u) {
      road_yaw_ = from.road_yaw_;
    }
    if (cached_has_bits & 0x00000004u) {
      vehicle_num_ = from.vehicle_num_;
    }
    if (cached_has_bits & 0x00000008u) {
      lane_id_ = from.lane_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void JamInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.JamInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void JamInfo::CopyFrom(const JamInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.JamInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JamInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  return true;
}

void JamInfo::Swap(JamInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void JamInfo::InternalSwap(JamInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  vehicle_flow_.InternalSwap(&other->vehicle_flow_);
  swap(vehicle_avg_speed_, other->vehicle_avg_speed_);
  swap(road_yaw_, other->road_yaw_);
  swap(vehicle_num_, other->vehicle_num_);
  swap(lane_id_, other->lane_id_);
}

::google::protobuf::Metadata JamInfo::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void FlowInfo::InitAsDefaultInstance() {
}
class FlowInfo::HasBitSetters {
 public:
  static void set_has_camera(FlowInfo* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_signal(FlowInfo* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FlowInfo::kCameraFieldNumber;
const int FlowInfo::kVehicleNumFieldNumber;
const int FlowInfo::kPassNumFieldNumber;
const int FlowInfo::kSignalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FlowInfo::FlowInfo()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.FlowInfo)
}
FlowInfo::FlowInfo(const FlowInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      vehicle_num_(from.vehicle_num_),
      pass_num_(from.pass_num_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&camera_, &from.camera_,
    static_cast<size_t>(reinterpret_cast<char*>(&signal_) -
    reinterpret_cast<char*>(&camera_)) + sizeof(signal_));
  // @@protoc_insertion_point(copy_constructor:vision.FlowInfo)
}

void FlowInfo::SharedCtor() {
  ::memset(&camera_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&signal_) -
      reinterpret_cast<char*>(&camera_)) + sizeof(signal_));
}

FlowInfo::~FlowInfo() {
  // @@protoc_insertion_point(destructor:vision.FlowInfo)
  SharedDtor();
}

void FlowInfo::SharedDtor() {
}

void FlowInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FlowInfo& FlowInfo::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_FlowInfo_vision_2eproto.base);
  return *internal_default_instance();
}


void FlowInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.FlowInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vehicle_num_.Clear();
  pass_num_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&camera_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&signal_) -
        reinterpret_cast<char*>(&camera_)) + sizeof(signal_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* FlowInfo::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional int32 camera = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_camera(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated uint32 vehicle_num = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) == 16) {
          do {
            add_vehicle_num(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ctx->Done(&ptr)) return ptr;
          } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 16 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::internal::PackedUInt32Parser(mutable_vehicle_num(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated uint32 pass_num = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) == 24) {
          do {
            add_pass_num(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ctx->Done(&ptr)) return ptr;
          } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 24 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::internal::PackedUInt32Parser(mutable_pass_num(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .vision.FlowInfo.TrafficSig signal = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::FlowInfo_TrafficSig_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(4, val, mutable_unknown_fields());
          break;
        }
        set_signal(static_cast<::vision::FlowInfo_TrafficSig>(val));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool FlowInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.FlowInfo)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 camera = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_camera(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &camera_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated uint32 vehicle_num = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16u, input, this->mutable_vehicle_num())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_vehicle_num())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated uint32 pass_num = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 24u, input, this->mutable_pass_num())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_pass_num())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .vision.FlowInfo.TrafficSig signal = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::FlowInfo_TrafficSig_IsValid(value)) {
            set_signal(static_cast< ::vision::FlowInfo_TrafficSig >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                4, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.FlowInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.FlowInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void FlowInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.FlowInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 camera = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->camera(), output);
  }

  // repeated uint32 vehicle_num = 2;
  for (int i = 0, n = this->vehicle_num_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->vehicle_num(i), output);
  }

  // repeated uint32 pass_num = 3;
  for (int i = 0, n = this->pass_num_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      3, this->pass_num(i), output);
  }

  // optional .vision.FlowInfo.TrafficSig signal = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->signal(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.FlowInfo)
}

::google::protobuf::uint8* FlowInfo::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.FlowInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 camera = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->camera(), target);
  }

  // repeated uint32 vehicle_num = 2;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(2, this->vehicle_num_, target);

  // repeated uint32 pass_num = 3;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(3, this->pass_num_, target);

  // optional .vision.FlowInfo.TrafficSig signal = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->signal(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.FlowInfo)
  return target;
}

size_t FlowInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.FlowInfo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 vehicle_num = 2;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->vehicle_num_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->vehicle_num_size());
    total_size += data_size;
  }

  // repeated uint32 pass_num = 3;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->pass_num_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->pass_num_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 camera = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->camera());
    }

    // optional .vision.FlowInfo.TrafficSig signal = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->signal());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FlowInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.FlowInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const FlowInfo* source =
      ::google::protobuf::DynamicCastToGenerated<FlowInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.FlowInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.FlowInfo)
    MergeFrom(*source);
  }
}

void FlowInfo::MergeFrom(const FlowInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.FlowInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  vehicle_num_.MergeFrom(from.vehicle_num_);
  pass_num_.MergeFrom(from.pass_num_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      camera_ = from.camera_;
    }
    if (cached_has_bits & 0x00000002u) {
      signal_ = from.signal_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FlowInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.FlowInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FlowInfo::CopyFrom(const FlowInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.FlowInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlowInfo::IsInitialized() const {
  return true;
}

void FlowInfo::Swap(FlowInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FlowInfo::InternalSwap(FlowInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  vehicle_num_.InternalSwap(&other->vehicle_num_);
  pass_num_.InternalSwap(&other->pass_num_);
  swap(camera_, other->camera_);
  swap(signal_, other->signal_);
}

::google::protobuf::Metadata FlowInfo::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Base::InitAsDefaultInstance() {
}
class Base::HasBitSetters {
 public:
  static void set_has_id(Base* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Base::kIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Base::Base()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.Base)
}
Base::Base(const Base& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:vision.Base)
}

void Base::SharedCtor() {
  id_ = 0;
}

Base::~Base() {
  // @@protoc_insertion_point(destructor:vision.Base)
  SharedDtor();
}

void Base::SharedDtor() {
}

void Base::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Base& Base::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Base_vision_2eproto.base);
  return *internal_default_instance();
}


void Base::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.Base)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Base::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Base::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.Base)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.Base)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.Base)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Base::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.Base)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.Base)
}

::google::protobuf::uint8* Base::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.Base)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.Base)
  return target;
}

size_t Base::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.Base)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .vision.ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Base::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.Base)
  GOOGLE_DCHECK_NE(&from, this);
  const Base* source =
      ::google::protobuf::DynamicCastToGenerated<Base>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.Base)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.Base)
    MergeFrom(*source);
  }
}

void Base::MergeFrom(const Base& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.Base)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_id()) {
    set_id(from.id());
  }
}

void Base::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.Base)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Base::CopyFrom(const Base& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.Base)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Base::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Base::Swap(Base* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Base::InternalSwap(Base* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(id_, other->id_);
}

::google::protobuf::Metadata Base::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Crowd::InitAsDefaultInstance() {
  ::vision::_Crowd_default_instance_._instance.get_mutable()->time_ = const_cast< ::vision::data_time*>(
      ::vision::data_time::internal_default_instance());
}
class Crowd::HasBitSetters {
 public:
  static void set_has_id(Crowd* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::vision::data_time& time(const Crowd* msg);
  static void set_has_time(Crowd* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

const ::vision::data_time&
Crowd::HasBitSetters::time(const Crowd* msg) {
  return *msg->time_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Crowd::kIdFieldNumber;
const int Crowd::kPedestrianFieldNumber;
const int Crowd::kTimeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Crowd::Crowd()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.Crowd)
}
Crowd::Crowd(const Crowd& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      pedestrian_(from.pedestrian_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_time()) {
    time_ = new ::vision::data_time(*from.time_);
  } else {
    time_ = nullptr;
  }
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:vision.Crowd)
}

void Crowd::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Crowd_vision_2eproto.base);
  ::memset(&time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&id_) -
      reinterpret_cast<char*>(&time_)) + sizeof(id_));
}

Crowd::~Crowd() {
  // @@protoc_insertion_point(destructor:vision.Crowd)
  SharedDtor();
}

void Crowd::SharedDtor() {
  if (this != internal_default_instance()) delete time_;
}

void Crowd::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Crowd& Crowd::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Crowd_vision_2eproto.base);
  return *internal_default_instance();
}


void Crowd::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.Crowd)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  pedestrian_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(time_ != nullptr);
    time_->Clear();
  }
  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Crowd::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // repeated .vision.Pedestrian pedestrian = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_pedestrian(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      // optional .vision.data_time time = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ctx->ParseMessage(mutable_time(), ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Crowd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.Crowd)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .vision.Pedestrian pedestrian = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_pedestrian()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .vision.data_time time = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_time()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.Crowd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.Crowd)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Crowd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.Crowd)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // repeated .vision.Pedestrian pedestrian = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->pedestrian_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->pedestrian(static_cast<int>(i)),
      output);
  }

  // optional .vision.data_time time = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::time(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.Crowd)
}

::google::protobuf::uint8* Crowd::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.Crowd)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // repeated .vision.Pedestrian pedestrian = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->pedestrian_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->pedestrian(static_cast<int>(i)), target);
  }

  // optional .vision.data_time time = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::time(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.Crowd)
  return target;
}

size_t Crowd::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.Crowd)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .vision.ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vision.Pedestrian pedestrian = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->pedestrian_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->pedestrian(static_cast<int>(i)));
    }
  }

  // optional .vision.data_time time = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *time_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Crowd::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.Crowd)
  GOOGLE_DCHECK_NE(&from, this);
  const Crowd* source =
      ::google::protobuf::DynamicCastToGenerated<Crowd>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.Crowd)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.Crowd)
    MergeFrom(*source);
  }
}

void Crowd::MergeFrom(const Crowd& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.Crowd)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  pedestrian_.MergeFrom(from.pedestrian_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_time()->::vision::data_time::MergeFrom(from.time());
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Crowd::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.Crowd)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Crowd::CopyFrom(const Crowd& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.Crowd)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Crowd::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->pedestrian())) return false;
  if (has_time()) {
    if (!this->time_->IsInitialized()) return false;
  }
  return true;
}

void Crowd::Swap(Crowd* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Crowd::InternalSwap(Crowd* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&pedestrian_)->InternalSwap(CastToBase(&other->pedestrian_));
  swap(time_, other->time_);
  swap(id_, other->id_);
}

::google::protobuf::Metadata Crowd::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Obstacles::InitAsDefaultInstance() {
  ::vision::_Obstacles_default_instance_._instance.get_mutable()->time_ = const_cast< ::vision::data_time*>(
      ::vision::data_time::internal_default_instance());
}
class Obstacles::HasBitSetters {
 public:
  static void set_has_id(Obstacles* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::vision::data_time& time(const Obstacles* msg);
  static void set_has_time(Obstacles* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

const ::vision::data_time&
Obstacles::HasBitSetters::time(const Obstacles* msg) {
  return *msg->time_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Obstacles::kIdFieldNumber;
const int Obstacles::kArrayFieldNumber;
const int Obstacles::kTimeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Obstacles::Obstacles()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.Obstacles)
}
Obstacles::Obstacles(const Obstacles& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      array_(from.array_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_time()) {
    time_ = new ::vision::data_time(*from.time_);
  } else {
    time_ = nullptr;
  }
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:vision.Obstacles)
}

void Obstacles::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Obstacles_vision_2eproto.base);
  ::memset(&time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&id_) -
      reinterpret_cast<char*>(&time_)) + sizeof(id_));
}

Obstacles::~Obstacles() {
  // @@protoc_insertion_point(destructor:vision.Obstacles)
  SharedDtor();
}

void Obstacles::SharedDtor() {
  if (this != internal_default_instance()) delete time_;
}

void Obstacles::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Obstacles& Obstacles::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Obstacles_vision_2eproto.base);
  return *internal_default_instance();
}


void Obstacles::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.Obstacles)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  array_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(time_ != nullptr);
    time_->Clear();
  }
  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Obstacles::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // repeated .vision.Obstacle array = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_array(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      // optional .vision.data_time time = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ctx->ParseMessage(mutable_time(), ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Obstacles::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.Obstacles)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .vision.Obstacle array = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_array()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .vision.data_time time = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_time()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.Obstacles)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.Obstacles)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Obstacles::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.Obstacles)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // repeated .vision.Obstacle array = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->array_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->array(static_cast<int>(i)),
      output);
  }

  // optional .vision.data_time time = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::time(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.Obstacles)
}

::google::protobuf::uint8* Obstacles::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.Obstacles)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // repeated .vision.Obstacle array = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->array_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->array(static_cast<int>(i)), target);
  }

  // optional .vision.data_time time = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::time(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.Obstacles)
  return target;
}

size_t Obstacles::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.Obstacles)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .vision.ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vision.Obstacle array = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->array_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->array(static_cast<int>(i)));
    }
  }

  // optional .vision.data_time time = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *time_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Obstacles::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.Obstacles)
  GOOGLE_DCHECK_NE(&from, this);
  const Obstacles* source =
      ::google::protobuf::DynamicCastToGenerated<Obstacles>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.Obstacles)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.Obstacles)
    MergeFrom(*source);
  }
}

void Obstacles::MergeFrom(const Obstacles& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.Obstacles)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  array_.MergeFrom(from.array_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_time()->::vision::data_time::MergeFrom(from.time());
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Obstacles::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.Obstacles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Obstacles::CopyFrom(const Obstacles& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.Obstacles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Obstacles::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->array())) return false;
  if (has_time()) {
    if (!this->time_->IsInitialized()) return false;
  }
  return true;
}

void Obstacles::Swap(Obstacles* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Obstacles::InternalSwap(Obstacles* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&array_)->InternalSwap(CastToBase(&other->array_));
  swap(time_, other->time_);
  swap(id_, other->id_);
}

::google::protobuf::Metadata Obstacles::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void AvailableAreas::InitAsDefaultInstance() {
  ::vision::_AvailableAreas_default_instance_._instance.get_mutable()->time_ = const_cast< ::vision::data_time*>(
      ::vision::data_time::internal_default_instance());
}
class AvailableAreas::HasBitSetters {
 public:
  static void set_has_id(AvailableAreas* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::vision::data_time& time(const AvailableAreas* msg);
  static void set_has_time(AvailableAreas* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

const ::vision::data_time&
AvailableAreas::HasBitSetters::time(const AvailableAreas* msg) {
  return *msg->time_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AvailableAreas::kIdFieldNumber;
const int AvailableAreas::kAreaFieldNumber;
const int AvailableAreas::kTimeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AvailableAreas::AvailableAreas()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.AvailableAreas)
}
AvailableAreas::AvailableAreas(const AvailableAreas& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      area_(from.area_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_time()) {
    time_ = new ::vision::data_time(*from.time_);
  } else {
    time_ = nullptr;
  }
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:vision.AvailableAreas)
}

void AvailableAreas::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_AvailableAreas_vision_2eproto.base);
  ::memset(&time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&id_) -
      reinterpret_cast<char*>(&time_)) + sizeof(id_));
}

AvailableAreas::~AvailableAreas() {
  // @@protoc_insertion_point(destructor:vision.AvailableAreas)
  SharedDtor();
}

void AvailableAreas::SharedDtor() {
  if (this != internal_default_instance()) delete time_;
}

void AvailableAreas::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AvailableAreas& AvailableAreas::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_AvailableAreas_vision_2eproto.base);
  return *internal_default_instance();
}


void AvailableAreas::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.AvailableAreas)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  area_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(time_ != nullptr);
    time_->Clear();
  }
  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AvailableAreas::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // repeated .vision.AvailableArea area = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_area(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      // optional .vision.data_time time = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ctx->ParseMessage(mutable_time(), ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AvailableAreas::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.AvailableAreas)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .vision.AvailableArea area = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_area()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .vision.data_time time = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_time()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.AvailableAreas)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.AvailableAreas)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AvailableAreas::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.AvailableAreas)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // repeated .vision.AvailableArea area = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->area_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->area(static_cast<int>(i)),
      output);
  }

  // optional .vision.data_time time = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::time(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.AvailableAreas)
}

::google::protobuf::uint8* AvailableAreas::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.AvailableAreas)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // repeated .vision.AvailableArea area = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->area_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->area(static_cast<int>(i)), target);
  }

  // optional .vision.data_time time = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::time(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.AvailableAreas)
  return target;
}

size_t AvailableAreas::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.AvailableAreas)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .vision.ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vision.AvailableArea area = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->area_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->area(static_cast<int>(i)));
    }
  }

  // optional .vision.data_time time = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *time_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AvailableAreas::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.AvailableAreas)
  GOOGLE_DCHECK_NE(&from, this);
  const AvailableAreas* source =
      ::google::protobuf::DynamicCastToGenerated<AvailableAreas>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.AvailableAreas)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.AvailableAreas)
    MergeFrom(*source);
  }
}

void AvailableAreas::MergeFrom(const AvailableAreas& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.AvailableAreas)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  area_.MergeFrom(from.area_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_time()->::vision::data_time::MergeFrom(from.time());
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AvailableAreas::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.AvailableAreas)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AvailableAreas::CopyFrom(const AvailableAreas& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.AvailableAreas)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvailableAreas::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->area())) return false;
  if (has_time()) {
    if (!this->time_->IsInitialized()) return false;
  }
  return true;
}

void AvailableAreas::Swap(AvailableAreas* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AvailableAreas::InternalSwap(AvailableAreas* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&area_)->InternalSwap(CastToBase(&other->area_));
  swap(time_, other->time_);
  swap(id_, other->id_);
}

::google::protobuf::Metadata AvailableAreas::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void IllegalCarWarn::InitAsDefaultInstance() {
  ::vision::_IllegalCarWarn_default_instance_._instance.get_mutable()->time_ = const_cast< ::vision::data_time*>(
      ::vision::data_time::internal_default_instance());
}
class IllegalCarWarn::HasBitSetters {
 public:
  static void set_has_id(IllegalCarWarn* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::vision::data_time& time(const IllegalCarWarn* msg);
  static void set_has_time(IllegalCarWarn* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

const ::vision::data_time&
IllegalCarWarn::HasBitSetters::time(const IllegalCarWarn* msg) {
  return *msg->time_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IllegalCarWarn::kIdFieldNumber;
const int IllegalCarWarn::kArrayFieldNumber;
const int IllegalCarWarn::kTimeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IllegalCarWarn::IllegalCarWarn()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.IllegalCarWarn)
}
IllegalCarWarn::IllegalCarWarn(const IllegalCarWarn& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      array_(from.array_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_time()) {
    time_ = new ::vision::data_time(*from.time_);
  } else {
    time_ = nullptr;
  }
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:vision.IllegalCarWarn)
}

void IllegalCarWarn::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_IllegalCarWarn_vision_2eproto.base);
  ::memset(&time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&id_) -
      reinterpret_cast<char*>(&time_)) + sizeof(id_));
}

IllegalCarWarn::~IllegalCarWarn() {
  // @@protoc_insertion_point(destructor:vision.IllegalCarWarn)
  SharedDtor();
}

void IllegalCarWarn::SharedDtor() {
  if (this != internal_default_instance()) delete time_;
}

void IllegalCarWarn::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IllegalCarWarn& IllegalCarWarn::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_IllegalCarWarn_vision_2eproto.base);
  return *internal_default_instance();
}


void IllegalCarWarn::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.IllegalCarWarn)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  array_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(time_ != nullptr);
    time_->Clear();
  }
  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IllegalCarWarn::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // repeated .vision.AbnormalCar array = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_array(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      // optional .vision.data_time time = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ctx->ParseMessage(mutable_time(), ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IllegalCarWarn::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.IllegalCarWarn)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .vision.AbnormalCar array = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_array()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .vision.data_time time = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_time()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.IllegalCarWarn)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.IllegalCarWarn)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IllegalCarWarn::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.IllegalCarWarn)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // repeated .vision.AbnormalCar array = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->array_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->array(static_cast<int>(i)),
      output);
  }

  // optional .vision.data_time time = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::time(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.IllegalCarWarn)
}

::google::protobuf::uint8* IllegalCarWarn::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.IllegalCarWarn)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // repeated .vision.AbnormalCar array = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->array_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->array(static_cast<int>(i)), target);
  }

  // optional .vision.data_time time = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::time(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.IllegalCarWarn)
  return target;
}

size_t IllegalCarWarn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.IllegalCarWarn)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .vision.ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vision.AbnormalCar array = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->array_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->array(static_cast<int>(i)));
    }
  }

  // optional .vision.data_time time = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *time_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IllegalCarWarn::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.IllegalCarWarn)
  GOOGLE_DCHECK_NE(&from, this);
  const IllegalCarWarn* source =
      ::google::protobuf::DynamicCastToGenerated<IllegalCarWarn>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.IllegalCarWarn)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.IllegalCarWarn)
    MergeFrom(*source);
  }
}

void IllegalCarWarn::MergeFrom(const IllegalCarWarn& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.IllegalCarWarn)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  array_.MergeFrom(from.array_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_time()->::vision::data_time::MergeFrom(from.time());
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IllegalCarWarn::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.IllegalCarWarn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IllegalCarWarn::CopyFrom(const IllegalCarWarn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.IllegalCarWarn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IllegalCarWarn::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->array())) return false;
  if (has_time()) {
    if (!this->time_->IsInitialized()) return false;
  }
  return true;
}

void IllegalCarWarn::Swap(IllegalCarWarn* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IllegalCarWarn::InternalSwap(IllegalCarWarn* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&array_)->InternalSwap(CastToBase(&other->array_));
  swap(time_, other->time_);
  swap(id_, other->id_);
}

::google::protobuf::Metadata IllegalCarWarn::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Visibility::InitAsDefaultInstance() {
}
class Visibility::HasBitSetters {
 public:
  static void set_has_id(Visibility* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_distance(Visibility* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_level(Visibility* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Visibility::kIdFieldNumber;
const int Visibility::kDistanceFieldNumber;
const int Visibility::kLevelFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Visibility::Visibility()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.Visibility)
}
Visibility::Visibility(const Visibility& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&distance_, &from.distance_,
    static_cast<size_t>(reinterpret_cast<char*>(&level_) -
    reinterpret_cast<char*>(&distance_)) + sizeof(level_));
  // @@protoc_insertion_point(copy_constructor:vision.Visibility)
}

void Visibility::SharedCtor() {
  ::memset(&distance_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&level_) -
      reinterpret_cast<char*>(&distance_)) + sizeof(level_));
}

Visibility::~Visibility() {
  // @@protoc_insertion_point(destructor:vision.Visibility)
  SharedDtor();
}

void Visibility::SharedDtor() {
}

void Visibility::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Visibility& Visibility::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Visibility_vision_2eproto.base);
  return *internal_default_instance();
}


void Visibility::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.Visibility)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&distance_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&level_) -
        reinterpret_cast<char*>(&distance_)) + sizeof(level_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Visibility::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // required double distance = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        set_distance(::google::protobuf::internal::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // required int32 level = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_level(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Visibility::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.Visibility)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required double distance = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          HasBitSetters::set_has_distance(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 level = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_level(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &level_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.Visibility)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.Visibility)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Visibility::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.Visibility)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // required double distance = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->distance(), output);
  }

  // required int32 level = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->level(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.Visibility)
}

::google::protobuf::uint8* Visibility::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.Visibility)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // required double distance = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->distance(), target);
  }

  // required int32 level = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->level(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.Visibility)
  return target;
}

size_t Visibility::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.Visibility)
  size_t total_size = 0;

  if (has_distance()) {
    // required double distance = 2;
    total_size += 1 + 8;
  }

  if (has_id()) {
    // required .vision.ID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }

  if (has_level()) {
    // required int32 level = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->level());
  }

  return total_size;
}
size_t Visibility::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.Visibility)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required double distance = 2;
    total_size += 1 + 8;

    // required .vision.ID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());

    // required int32 level = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->level());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Visibility::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.Visibility)
  GOOGLE_DCHECK_NE(&from, this);
  const Visibility* source =
      ::google::protobuf::DynamicCastToGenerated<Visibility>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.Visibility)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.Visibility)
    MergeFrom(*source);
  }
}

void Visibility::MergeFrom(const Visibility& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.Visibility)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      distance_ = from.distance_;
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      level_ = from.level_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Visibility::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.Visibility)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Visibility::CopyFrom(const Visibility& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.Visibility)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Visibility::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  return true;
}

void Visibility::Swap(Visibility* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Visibility::InternalSwap(Visibility* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(distance_, other->distance_);
  swap(id_, other->id_);
  swap(level_, other->level_);
}

::google::protobuf::Metadata Visibility::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SmokeWarn::InitAsDefaultInstance() {
}
class SmokeWarn::HasBitSetters {
 public:
  static void set_has_id(SmokeWarn* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_warn(SmokeWarn* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SmokeWarn::kIdFieldNumber;
const int SmokeWarn::kWarnFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SmokeWarn::SmokeWarn()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.SmokeWarn)
}
SmokeWarn::SmokeWarn(const SmokeWarn& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&warn_) -
    reinterpret_cast<char*>(&id_)) + sizeof(warn_));
  // @@protoc_insertion_point(copy_constructor:vision.SmokeWarn)
}

void SmokeWarn::SharedCtor() {
  ::memset(&id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&warn_) -
      reinterpret_cast<char*>(&id_)) + sizeof(warn_));
}

SmokeWarn::~SmokeWarn() {
  // @@protoc_insertion_point(destructor:vision.SmokeWarn)
  SharedDtor();
}

void SmokeWarn::SharedDtor() {
}

void SmokeWarn::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SmokeWarn& SmokeWarn::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SmokeWarn_vision_2eproto.base);
  return *internal_default_instance();
}


void SmokeWarn::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.SmokeWarn)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&warn_) -
        reinterpret_cast<char*>(&id_)) + sizeof(warn_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SmokeWarn::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // required bool warn = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        set_warn(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SmokeWarn::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.SmokeWarn)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bool warn = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_warn(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &warn_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.SmokeWarn)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.SmokeWarn)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SmokeWarn::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.SmokeWarn)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // required bool warn = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->warn(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.SmokeWarn)
}

::google::protobuf::uint8* SmokeWarn::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.SmokeWarn)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // required bool warn = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->warn(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.SmokeWarn)
  return target;
}

size_t SmokeWarn::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.SmokeWarn)
  size_t total_size = 0;

  if (has_id()) {
    // required .vision.ID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }

  if (has_warn()) {
    // required bool warn = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t SmokeWarn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.SmokeWarn)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .vision.ID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());

    // required bool warn = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SmokeWarn::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.SmokeWarn)
  GOOGLE_DCHECK_NE(&from, this);
  const SmokeWarn* source =
      ::google::protobuf::DynamicCastToGenerated<SmokeWarn>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.SmokeWarn)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.SmokeWarn)
    MergeFrom(*source);
  }
}

void SmokeWarn::MergeFrom(const SmokeWarn& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.SmokeWarn)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      warn_ = from.warn_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SmokeWarn::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.SmokeWarn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SmokeWarn::CopyFrom(const SmokeWarn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.SmokeWarn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SmokeWarn::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void SmokeWarn::Swap(SmokeWarn* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SmokeWarn::InternalSwap(SmokeWarn* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(id_, other->id_);
  swap(warn_, other->warn_);
}

::google::protobuf::Metadata SmokeWarn::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Timestamp::InitAsDefaultInstance() {
}
class Timestamp::HasBitSetters {
 public:
  static void set_has_seconds(Timestamp* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_nanos(Timestamp* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Timestamp::kSecondsFieldNumber;
const int Timestamp::kNanosFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Timestamp::Timestamp()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.Timestamp)
}
Timestamp::Timestamp(const Timestamp& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&seconds_, &from.seconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&nanos_) -
    reinterpret_cast<char*>(&seconds_)) + sizeof(nanos_));
  // @@protoc_insertion_point(copy_constructor:vision.Timestamp)
}

void Timestamp::SharedCtor() {
  ::memset(&seconds_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&nanos_) -
      reinterpret_cast<char*>(&seconds_)) + sizeof(nanos_));
}

Timestamp::~Timestamp() {
  // @@protoc_insertion_point(destructor:vision.Timestamp)
  SharedDtor();
}

void Timestamp::SharedDtor() {
}

void Timestamp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Timestamp& Timestamp::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Timestamp_vision_2eproto.base);
  return *internal_default_instance();
}


void Timestamp::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.Timestamp)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&seconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nanos_) -
        reinterpret_cast<char*>(&seconds_)) + sizeof(nanos_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Timestamp::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int64 seconds = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_seconds(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 nanos = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        set_nanos(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Timestamp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.Timestamp)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 seconds = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_seconds(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &seconds_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 nanos = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_nanos(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nanos_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.Timestamp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.Timestamp)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Timestamp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.Timestamp)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 seconds = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->seconds(), output);
  }

  // required int32 nanos = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->nanos(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.Timestamp)
}

::google::protobuf::uint8* Timestamp::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.Timestamp)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 seconds = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->seconds(), target);
  }

  // required int32 nanos = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->nanos(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.Timestamp)
  return target;
}

size_t Timestamp::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.Timestamp)
  size_t total_size = 0;

  if (has_seconds()) {
    // required int64 seconds = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->seconds());
  }

  if (has_nanos()) {
    // required int32 nanos = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->nanos());
  }

  return total_size;
}
size_t Timestamp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.Timestamp)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int64 seconds = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->seconds());

    // required int32 nanos = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->nanos());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Timestamp::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.Timestamp)
  GOOGLE_DCHECK_NE(&from, this);
  const Timestamp* source =
      ::google::protobuf::DynamicCastToGenerated<Timestamp>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.Timestamp)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.Timestamp)
    MergeFrom(*source);
  }
}

void Timestamp::MergeFrom(const Timestamp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.Timestamp)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      seconds_ = from.seconds_;
    }
    if (cached_has_bits & 0x00000002u) {
      nanos_ = from.nanos_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Timestamp::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.Timestamp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Timestamp::CopyFrom(const Timestamp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.Timestamp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Timestamp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void Timestamp::Swap(Timestamp* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Timestamp::InternalSwap(Timestamp* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(seconds_, other->seconds_);
  swap(nanos_, other->nanos_);
}

::google::protobuf::Metadata Timestamp::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Detectobject::InitAsDefaultInstance() {
}
class Detectobject::HasBitSetters {
 public:
  static void set_has_object_id(Detectobject* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_object_type(Detectobject* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_longitudinalx(Detectobject* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_lateraly(Detectobject* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_velocity(Detectobject* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_camera(Detectobject* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_if_at_lane(Detectobject* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_lane_id(Detectobject* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_heading(Detectobject* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static void set_has_lane_type(Detectobject* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Detectobject::kObjectIdFieldNumber;
const int Detectobject::kObjectTypeFieldNumber;
const int Detectobject::kLongitudinalXFieldNumber;
const int Detectobject::kLateralYFieldNumber;
const int Detectobject::kVelocityFieldNumber;
const int Detectobject::kCameraFieldNumber;
const int Detectobject::kIfAtLaneFieldNumber;
const int Detectobject::kLaneIdFieldNumber;
const int Detectobject::kHeadingFieldNumber;
const int Detectobject::kLaneTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Detectobject::Detectobject()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.Detectobject)
}
Detectobject::Detectobject(const Detectobject& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&object_id_, &from.object_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&lane_type_) -
    reinterpret_cast<char*>(&object_id_)) + sizeof(lane_type_));
  // @@protoc_insertion_point(copy_constructor:vision.Detectobject)
}

void Detectobject::SharedCtor() {
  ::memset(&object_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lane_type_) -
      reinterpret_cast<char*>(&object_id_)) + sizeof(lane_type_));
}

Detectobject::~Detectobject() {
  // @@protoc_insertion_point(destructor:vision.Detectobject)
  SharedDtor();
}

void Detectobject::SharedDtor() {
}

void Detectobject::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Detectobject& Detectobject::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Detectobject_vision_2eproto.base);
  return *internal_default_instance();
}


void Detectobject::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.Detectobject)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&object_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lane_id_) -
        reinterpret_cast<char*>(&object_id_)) + sizeof(lane_id_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&heading_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lane_type_) -
        reinterpret_cast<char*>(&heading_)) + sizeof(lane_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Detectobject::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_object_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required .vision.TYPE object_type = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::TYPE_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(2, val, mutable_unknown_fields());
          break;
        }
        set_object_type(static_cast<::vision::TYPE>(val));
        break;
      }
      // required int32 longitudinalX = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_longitudinalx(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lateralY = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        set_lateraly(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 velocity = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        set_velocity(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 camera = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        set_camera(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 if_at_lane = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        set_if_at_lane(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_id = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 64) goto handle_unusual;
        set_lane_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 heading = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 72) goto handle_unusual;
        set_heading(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_type = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 80) goto handle_unusual;
        set_lane_type(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Detectobject::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.Detectobject)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_object_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .vision.TYPE object_type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::TYPE_IsValid(value)) {
            set_object_type(static_cast< ::vision::TYPE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 longitudinalX = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_longitudinalx(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &longitudinalx_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lateralY = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_lateraly(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lateraly_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 velocity = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_velocity(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &velocity_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 camera = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_camera(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &camera_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 if_at_lane = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_if_at_lane(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &if_at_lane_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_id = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_lane_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 heading = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_type = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (80 & 0xFF)) {
          HasBitSetters::set_has_lane_type(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_type_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.Detectobject)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.Detectobject)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Detectobject::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.Detectobject)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->object_id(), output);
  }

  // required .vision.TYPE object_type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->object_type(), output);
  }

  // required int32 longitudinalX = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->longitudinalx(), output);
  }

  // required int32 lateralY = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->lateraly(), output);
  }

  // required int32 velocity = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->velocity(), output);
  }

  // required int32 camera = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->camera(), output);
  }

  // optional int32 if_at_lane = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->if_at_lane(), output);
  }

  // optional int32 lane_id = 8;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->lane_id(), output);
  }

  // optional int32 heading = 9;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->heading(), output);
  }

  // optional int32 lane_type = 10;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->lane_type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.Detectobject)
}

::google::protobuf::uint8* Detectobject::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.Detectobject)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->object_id(), target);
  }

  // required .vision.TYPE object_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->object_type(), target);
  }

  // required int32 longitudinalX = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->longitudinalx(), target);
  }

  // required int32 lateralY = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->lateraly(), target);
  }

  // required int32 velocity = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->velocity(), target);
  }

  // required int32 camera = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->camera(), target);
  }

  // optional int32 if_at_lane = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->if_at_lane(), target);
  }

  // optional int32 lane_id = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->lane_id(), target);
  }

  // optional int32 heading = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->heading(), target);
  }

  // optional int32 lane_type = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->lane_type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.Detectobject)
  return target;
}

size_t Detectobject::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.Detectobject)
  size_t total_size = 0;

  if (has_object_id()) {
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());
  }

  if (has_object_type()) {
    // required .vision.TYPE object_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->object_type());
  }

  if (has_longitudinalx()) {
    // required int32 longitudinalX = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->longitudinalx());
  }

  if (has_lateraly()) {
    // required int32 lateralY = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lateraly());
  }

  if (has_velocity()) {
    // required int32 velocity = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->velocity());
  }

  if (has_camera()) {
    // required int32 camera = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());
  }

  return total_size;
}
size_t Detectobject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.Detectobject)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());

    // required .vision.TYPE object_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->object_type());

    // required int32 longitudinalX = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->longitudinalx());

    // required int32 lateralY = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lateraly());

    // required int32 velocity = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->velocity());

    // required int32 camera = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000c0u) {
    // optional int32 if_at_lane = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->if_at_lane());
    }

    // optional int32 lane_id = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lane_id());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional int32 heading = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->heading());
    }

    // optional int32 lane_type = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lane_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Detectobject::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.Detectobject)
  GOOGLE_DCHECK_NE(&from, this);
  const Detectobject* source =
      ::google::protobuf::DynamicCastToGenerated<Detectobject>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.Detectobject)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.Detectobject)
    MergeFrom(*source);
  }
}

void Detectobject::MergeFrom(const Detectobject& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.Detectobject)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      object_id_ = from.object_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      object_type_ = from.object_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      longitudinalx_ = from.longitudinalx_;
    }
    if (cached_has_bits & 0x00000008u) {
      lateraly_ = from.lateraly_;
    }
    if (cached_has_bits & 0x00000010u) {
      velocity_ = from.velocity_;
    }
    if (cached_has_bits & 0x00000020u) {
      camera_ = from.camera_;
    }
    if (cached_has_bits & 0x00000040u) {
      if_at_lane_ = from.if_at_lane_;
    }
    if (cached_has_bits & 0x00000080u) {
      lane_id_ = from.lane_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      heading_ = from.heading_;
    }
    if (cached_has_bits & 0x00000200u) {
      lane_type_ = from.lane_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Detectobject::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.Detectobject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Detectobject::CopyFrom(const Detectobject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.Detectobject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Detectobject::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;
  return true;
}

void Detectobject::Swap(Detectobject* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Detectobject::InternalSwap(Detectobject* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(object_id_, other->object_id_);
  swap(object_type_, other->object_type_);
  swap(longitudinalx_, other->longitudinalx_);
  swap(lateraly_, other->lateraly_);
  swap(velocity_, other->velocity_);
  swap(camera_, other->camera_);
  swap(if_at_lane_, other->if_at_lane_);
  swap(lane_id_, other->lane_id_);
  swap(heading_, other->heading_);
  swap(lane_type_, other->lane_type_);
}

::google::protobuf::Metadata Detectobject::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Detectobjects::InitAsDefaultInstance() {
  ::vision::_Detectobjects_default_instance_._instance.get_mutable()->time_ = const_cast< ::vision::Timestamp*>(
      ::vision::Timestamp::internal_default_instance());
}
class Detectobjects::HasBitSetters {
 public:
  static void set_has_id(Detectobjects* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::vision::Timestamp& time(const Detectobjects* msg);
  static void set_has_time(Detectobjects* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

const ::vision::Timestamp&
Detectobjects::HasBitSetters::time(const Detectobjects* msg) {
  return *msg->time_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Detectobjects::kIdFieldNumber;
const int Detectobjects::kObjectFieldNumber;
const int Detectobjects::kTimeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Detectobjects::Detectobjects()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.Detectobjects)
}
Detectobjects::Detectobjects(const Detectobjects& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      object_(from.object_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_time()) {
    time_ = new ::vision::Timestamp(*from.time_);
  } else {
    time_ = nullptr;
  }
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:vision.Detectobjects)
}

void Detectobjects::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Detectobjects_vision_2eproto.base);
  ::memset(&time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&id_) -
      reinterpret_cast<char*>(&time_)) + sizeof(id_));
}

Detectobjects::~Detectobjects() {
  // @@protoc_insertion_point(destructor:vision.Detectobjects)
  SharedDtor();
}

void Detectobjects::SharedDtor() {
  if (this != internal_default_instance()) delete time_;
}

void Detectobjects::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Detectobjects& Detectobjects::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Detectobjects_vision_2eproto.base);
  return *internal_default_instance();
}


void Detectobjects::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.Detectobjects)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  object_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(time_ != nullptr);
    time_->Clear();
  }
  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Detectobjects::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // repeated .vision.Detectobject object = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_object(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      // optional .vision.Timestamp time = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ctx->ParseMessage(mutable_time(), ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Detectobjects::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.Detectobjects)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .vision.Detectobject object = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_object()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .vision.Timestamp time = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_time()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.Detectobjects)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.Detectobjects)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Detectobjects::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.Detectobjects)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // repeated .vision.Detectobject object = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->object_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->object(static_cast<int>(i)),
      output);
  }

  // optional .vision.Timestamp time = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::time(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.Detectobjects)
}

::google::protobuf::uint8* Detectobjects::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.Detectobjects)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // repeated .vision.Detectobject object = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->object_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->object(static_cast<int>(i)), target);
  }

  // optional .vision.Timestamp time = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::time(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.Detectobjects)
  return target;
}

size_t Detectobjects::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.Detectobjects)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .vision.ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vision.Detectobject object = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->object_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->object(static_cast<int>(i)));
    }
  }

  // optional .vision.Timestamp time = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *time_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Detectobjects::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.Detectobjects)
  GOOGLE_DCHECK_NE(&from, this);
  const Detectobjects* source =
      ::google::protobuf::DynamicCastToGenerated<Detectobjects>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.Detectobjects)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.Detectobjects)
    MergeFrom(*source);
  }
}

void Detectobjects::MergeFrom(const Detectobjects& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.Detectobjects)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  object_.MergeFrom(from.object_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_time()->::vision::Timestamp::MergeFrom(from.time());
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Detectobjects::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.Detectobjects)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Detectobjects::CopyFrom(const Detectobjects& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.Detectobjects)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Detectobjects::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->object())) return false;
  if (has_time()) {
    if (!this->time_->IsInitialized()) return false;
  }
  return true;
}

void Detectobjects::Swap(Detectobjects* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Detectobjects::InternalSwap(Detectobjects* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&object_)->InternalSwap(CastToBase(&other->object_));
  swap(time_, other->time_);
  swap(id_, other->id_);
}

::google::protobuf::Metadata Detectobjects::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void TrafficJam::InitAsDefaultInstance() {
  ::vision::_TrafficJam_default_instance_._instance.get_mutable()->time_ = const_cast< ::vision::data_time*>(
      ::vision::data_time::internal_default_instance());
}
class TrafficJam::HasBitSetters {
 public:
  static void set_has_id(TrafficJam* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::vision::data_time& time(const TrafficJam* msg);
  static void set_has_time(TrafficJam* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

const ::vision::data_time&
TrafficJam::HasBitSetters::time(const TrafficJam* msg) {
  return *msg->time_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TrafficJam::kIdFieldNumber;
const int TrafficJam::kJamFieldNumber;
const int TrafficJam::kTimeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TrafficJam::TrafficJam()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.TrafficJam)
}
TrafficJam::TrafficJam(const TrafficJam& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      jam_(from.jam_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_time()) {
    time_ = new ::vision::data_time(*from.time_);
  } else {
    time_ = nullptr;
  }
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:vision.TrafficJam)
}

void TrafficJam::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_TrafficJam_vision_2eproto.base);
  ::memset(&time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&id_) -
      reinterpret_cast<char*>(&time_)) + sizeof(id_));
}

TrafficJam::~TrafficJam() {
  // @@protoc_insertion_point(destructor:vision.TrafficJam)
  SharedDtor();
}

void TrafficJam::SharedDtor() {
  if (this != internal_default_instance()) delete time_;
}

void TrafficJam::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TrafficJam& TrafficJam::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_TrafficJam_vision_2eproto.base);
  return *internal_default_instance();
}


void TrafficJam::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.TrafficJam)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  jam_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(time_ != nullptr);
    time_->Clear();
  }
  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TrafficJam::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // repeated .vision.JamInfo jam = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_jam(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      // optional .vision.data_time time = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ctx->ParseMessage(mutable_time(), ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TrafficJam::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.TrafficJam)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .vision.JamInfo jam = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_jam()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .vision.data_time time = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_time()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.TrafficJam)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.TrafficJam)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TrafficJam::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.TrafficJam)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // repeated .vision.JamInfo jam = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->jam_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->jam(static_cast<int>(i)),
      output);
  }

  // optional .vision.data_time time = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::time(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.TrafficJam)
}

::google::protobuf::uint8* TrafficJam::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.TrafficJam)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // repeated .vision.JamInfo jam = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->jam_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->jam(static_cast<int>(i)), target);
  }

  // optional .vision.data_time time = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::time(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.TrafficJam)
  return target;
}

size_t TrafficJam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.TrafficJam)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .vision.ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vision.JamInfo jam = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->jam_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->jam(static_cast<int>(i)));
    }
  }

  // optional .vision.data_time time = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *time_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TrafficJam::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.TrafficJam)
  GOOGLE_DCHECK_NE(&from, this);
  const TrafficJam* source =
      ::google::protobuf::DynamicCastToGenerated<TrafficJam>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.TrafficJam)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.TrafficJam)
    MergeFrom(*source);
  }
}

void TrafficJam::MergeFrom(const TrafficJam& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.TrafficJam)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  jam_.MergeFrom(from.jam_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_time()->::vision::data_time::MergeFrom(from.time());
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TrafficJam::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.TrafficJam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrafficJam::CopyFrom(const TrafficJam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.TrafficJam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrafficJam::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->jam())) return false;
  if (has_time()) {
    if (!this->time_->IsInitialized()) return false;
  }
  return true;
}

void TrafficJam::Swap(TrafficJam* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TrafficJam::InternalSwap(TrafficJam* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&jam_)->InternalSwap(CastToBase(&other->jam_));
  swap(time_, other->time_);
  swap(id_, other->id_);
}

::google::protobuf::Metadata TrafficJam::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void TrafficFlow::InitAsDefaultInstance() {
  ::vision::_TrafficFlow_default_instance_._instance.get_mutable()->time_ = const_cast< ::vision::data_time*>(
      ::vision::data_time::internal_default_instance());
}
class TrafficFlow::HasBitSetters {
 public:
  static void set_has_id(TrafficFlow* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::vision::data_time& time(const TrafficFlow* msg);
  static void set_has_time(TrafficFlow* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

const ::vision::data_time&
TrafficFlow::HasBitSetters::time(const TrafficFlow* msg) {
  return *msg->time_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TrafficFlow::kIdFieldNumber;
const int TrafficFlow::kFlowFieldNumber;
const int TrafficFlow::kTimeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TrafficFlow::TrafficFlow()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.TrafficFlow)
}
TrafficFlow::TrafficFlow(const TrafficFlow& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      flow_(from.flow_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_time()) {
    time_ = new ::vision::data_time(*from.time_);
  } else {
    time_ = nullptr;
  }
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:vision.TrafficFlow)
}

void TrafficFlow::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_TrafficFlow_vision_2eproto.base);
  ::memset(&time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&id_) -
      reinterpret_cast<char*>(&time_)) + sizeof(id_));
}

TrafficFlow::~TrafficFlow() {
  // @@protoc_insertion_point(destructor:vision.TrafficFlow)
  SharedDtor();
}

void TrafficFlow::SharedDtor() {
  if (this != internal_default_instance()) delete time_;
}

void TrafficFlow::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TrafficFlow& TrafficFlow::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_TrafficFlow_vision_2eproto.base);
  return *internal_default_instance();
}


void TrafficFlow::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.TrafficFlow)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  flow_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(time_ != nullptr);
    time_->Clear();
  }
  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TrafficFlow::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // repeated .vision.FlowInfo flow = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_flow(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      // optional .vision.data_time time = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ctx->ParseMessage(mutable_time(), ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TrafficFlow::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.TrafficFlow)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .vision.FlowInfo flow = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_flow()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .vision.data_time time = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_time()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.TrafficFlow)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.TrafficFlow)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TrafficFlow::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.TrafficFlow)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // repeated .vision.FlowInfo flow = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->flow_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->flow(static_cast<int>(i)),
      output);
  }

  // optional .vision.data_time time = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::time(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.TrafficFlow)
}

::google::protobuf::uint8* TrafficFlow::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.TrafficFlow)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // repeated .vision.FlowInfo flow = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->flow_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->flow(static_cast<int>(i)), target);
  }

  // optional .vision.data_time time = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::time(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.TrafficFlow)
  return target;
}

size_t TrafficFlow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.TrafficFlow)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .vision.ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vision.FlowInfo flow = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->flow_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->flow(static_cast<int>(i)));
    }
  }

  // optional .vision.data_time time = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *time_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TrafficFlow::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.TrafficFlow)
  GOOGLE_DCHECK_NE(&from, this);
  const TrafficFlow* source =
      ::google::protobuf::DynamicCastToGenerated<TrafficFlow>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.TrafficFlow)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.TrafficFlow)
    MergeFrom(*source);
  }
}

void TrafficFlow::MergeFrom(const TrafficFlow& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.TrafficFlow)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  flow_.MergeFrom(from.flow_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_time()->::vision::data_time::MergeFrom(from.time());
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TrafficFlow::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.TrafficFlow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrafficFlow::CopyFrom(const TrafficFlow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.TrafficFlow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrafficFlow::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (has_time()) {
    if (!this->time_->IsInitialized()) return false;
  }
  return true;
}

void TrafficFlow::Swap(TrafficFlow* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TrafficFlow::InternalSwap(TrafficFlow* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&flow_)->InternalSwap(CastToBase(&other->flow_));
  swap(time_, other->time_);
  swap(id_, other->id_);
}

::google::protobuf::Metadata TrafficFlow::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void IceWarn::InitAsDefaultInstance() {
}
class IceWarn::HasBitSetters {
 public:
  static void set_has_id(IceWarn* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_warn(IceWarn* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IceWarn::kIdFieldNumber;
const int IceWarn::kWarnFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IceWarn::IceWarn()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.IceWarn)
}
IceWarn::IceWarn(const IceWarn& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&warn_) -
    reinterpret_cast<char*>(&id_)) + sizeof(warn_));
  // @@protoc_insertion_point(copy_constructor:vision.IceWarn)
}

void IceWarn::SharedCtor() {
  ::memset(&id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&warn_) -
      reinterpret_cast<char*>(&id_)) + sizeof(warn_));
}

IceWarn::~IceWarn() {
  // @@protoc_insertion_point(destructor:vision.IceWarn)
  SharedDtor();
}

void IceWarn::SharedDtor() {
}

void IceWarn::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IceWarn& IceWarn::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_IceWarn_vision_2eproto.base);
  return *internal_default_instance();
}


void IceWarn::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.IceWarn)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&warn_) -
        reinterpret_cast<char*>(&id_)) + sizeof(warn_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IceWarn::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // required bool warn = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        set_warn(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IceWarn::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.IceWarn)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bool warn = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_warn(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &warn_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.IceWarn)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.IceWarn)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IceWarn::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.IceWarn)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // required bool warn = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->warn(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.IceWarn)
}

::google::protobuf::uint8* IceWarn::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.IceWarn)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // required bool warn = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->warn(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.IceWarn)
  return target;
}

size_t IceWarn::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.IceWarn)
  size_t total_size = 0;

  if (has_id()) {
    // required .vision.ID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }

  if (has_warn()) {
    // required bool warn = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t IceWarn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.IceWarn)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .vision.ID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());

    // required bool warn = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IceWarn::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.IceWarn)
  GOOGLE_DCHECK_NE(&from, this);
  const IceWarn* source =
      ::google::protobuf::DynamicCastToGenerated<IceWarn>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.IceWarn)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.IceWarn)
    MergeFrom(*source);
  }
}

void IceWarn::MergeFrom(const IceWarn& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.IceWarn)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      warn_ = from.warn_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IceWarn::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.IceWarn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IceWarn::CopyFrom(const IceWarn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.IceWarn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IceWarn::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void IceWarn::Swap(IceWarn* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IceWarn::InternalSwap(IceWarn* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(id_, other->id_);
  swap(warn_, other->warn_);
}

::google::protobuf::Metadata IceWarn::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void LaneWare::InitAsDefaultInstance() {
}
class LaneWare::HasBitSetters {
 public:
  static void set_has_id(LaneWare* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_ware_type(LaneWare* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lng1(LaneWare* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_lat1(LaneWare* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_lng2(LaneWare* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_lat2(LaneWare* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_heading(LaneWare* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LaneWare::kIdFieldNumber;
const int LaneWare::kWareTypeFieldNumber;
const int LaneWare::kLng1FieldNumber;
const int LaneWare::kLat1FieldNumber;
const int LaneWare::kLng2FieldNumber;
const int LaneWare::kLat2FieldNumber;
const int LaneWare::kHeadingFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LaneWare::LaneWare()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.LaneWare)
}
LaneWare::LaneWare(const LaneWare& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&heading_) -
    reinterpret_cast<char*>(&id_)) + sizeof(heading_));
  // @@protoc_insertion_point(copy_constructor:vision.LaneWare)
}

void LaneWare::SharedCtor() {
  ::memset(&id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&heading_) -
      reinterpret_cast<char*>(&id_)) + sizeof(heading_));
}

LaneWare::~LaneWare() {
  // @@protoc_insertion_point(destructor:vision.LaneWare)
  SharedDtor();
}

void LaneWare::SharedDtor() {
}

void LaneWare::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LaneWare& LaneWare::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_LaneWare_vision_2eproto.base);
  return *internal_default_instance();
}


void LaneWare::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.LaneWare)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&heading_) -
        reinterpret_cast<char*>(&id_)) + sizeof(heading_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* LaneWare::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // required .vision.LaneWare.WARETYPE ware_type = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::LaneWare_WARETYPE_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(2, val, mutable_unknown_fields());
          break;
        }
        set_ware_type(static_cast<::vision::LaneWare_WARETYPE>(val));
        break;
      }
      // required int32 lng1 = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_lng1(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lat1 = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        set_lat1(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lng2 = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        set_lng2(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lat2 = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        set_lat2(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 heading = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        set_heading(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool LaneWare::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.LaneWare)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .vision.LaneWare.WARETYPE ware_type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::LaneWare_WARETYPE_IsValid(value)) {
            set_ware_type(static_cast< ::vision::LaneWare_WARETYPE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lng1 = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_lng1(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lng1_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lat1 = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_lat1(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lat1_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lng2 = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_lng2(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lng2_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lat2 = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_lat2(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lat2_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 heading = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.LaneWare)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.LaneWare)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void LaneWare::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.LaneWare)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // required .vision.LaneWare.WARETYPE ware_type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->ware_type(), output);
  }

  // required int32 lng1 = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lng1(), output);
  }

  // required int32 lat1 = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->lat1(), output);
  }

  // required int32 lng2 = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->lng2(), output);
  }

  // required int32 lat2 = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->lat2(), output);
  }

  // optional int32 heading = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->heading(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.LaneWare)
}

::google::protobuf::uint8* LaneWare::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.LaneWare)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // required .vision.LaneWare.WARETYPE ware_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->ware_type(), target);
  }

  // required int32 lng1 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->lng1(), target);
  }

  // required int32 lat1 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->lat1(), target);
  }

  // required int32 lng2 = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->lng2(), target);
  }

  // required int32 lat2 = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->lat2(), target);
  }

  // optional int32 heading = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->heading(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.LaneWare)
  return target;
}

size_t LaneWare::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.LaneWare)
  size_t total_size = 0;

  if (has_id()) {
    // required .vision.ID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }

  if (has_ware_type()) {
    // required .vision.LaneWare.WARETYPE ware_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->ware_type());
  }

  if (has_lng1()) {
    // required int32 lng1 = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng1());
  }

  if (has_lat1()) {
    // required int32 lat1 = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat1());
  }

  if (has_lng2()) {
    // required int32 lng2 = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng2());
  }

  if (has_lat2()) {
    // required int32 lat2 = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat2());
  }

  return total_size;
}
size_t LaneWare::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.LaneWare)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required .vision.ID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());

    // required .vision.LaneWare.WARETYPE ware_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->ware_type());

    // required int32 lng1 = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng1());

    // required int32 lat1 = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat1());

    // required int32 lng2 = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng2());

    // required int32 lat2 = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat2());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 heading = 7;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000040u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->heading());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LaneWare::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.LaneWare)
  GOOGLE_DCHECK_NE(&from, this);
  const LaneWare* source =
      ::google::protobuf::DynamicCastToGenerated<LaneWare>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.LaneWare)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.LaneWare)
    MergeFrom(*source);
  }
}

void LaneWare::MergeFrom(const LaneWare& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.LaneWare)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      ware_type_ = from.ware_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      lng1_ = from.lng1_;
    }
    if (cached_has_bits & 0x00000008u) {
      lat1_ = from.lat1_;
    }
    if (cached_has_bits & 0x00000010u) {
      lng2_ = from.lng2_;
    }
    if (cached_has_bits & 0x00000020u) {
      lat2_ = from.lat2_;
    }
    if (cached_has_bits & 0x00000040u) {
      heading_ = from.heading_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LaneWare::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.LaneWare)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LaneWare::CopyFrom(const LaneWare& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.LaneWare)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaneWare::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;
  return true;
}

void LaneWare::Swap(LaneWare* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LaneWare::InternalSwap(LaneWare* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(id_, other->id_);
  swap(ware_type_, other->ware_type_);
  swap(lng1_, other->lng1_);
  swap(lat1_, other->lat1_);
  swap(lng2_, other->lng2_);
  swap(lat2_, other->lat2_);
  swap(heading_, other->heading_);
}

::google::protobuf::Metadata LaneWare::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SpecialCarMsg::InitAsDefaultInstance() {
  ::vision::_SpecialCarMsg_default_instance_._instance.get_mutable()->time_ = const_cast< ::vision::data_time*>(
      ::vision::data_time::internal_default_instance());
}
class SpecialCarMsg::HasBitSetters {
 public:
  static void set_has_id(SpecialCarMsg* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::vision::data_time& time(const SpecialCarMsg* msg);
  static void set_has_time(SpecialCarMsg* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

const ::vision::data_time&
SpecialCarMsg::HasBitSetters::time(const SpecialCarMsg* msg) {
  return *msg->time_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SpecialCarMsg::kIdFieldNumber;
const int SpecialCarMsg::kArrayFieldNumber;
const int SpecialCarMsg::kTimeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SpecialCarMsg::SpecialCarMsg()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.SpecialCarMsg)
}
SpecialCarMsg::SpecialCarMsg(const SpecialCarMsg& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      array_(from.array_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_time()) {
    time_ = new ::vision::data_time(*from.time_);
  } else {
    time_ = nullptr;
  }
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:vision.SpecialCarMsg)
}

void SpecialCarMsg::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_SpecialCarMsg_vision_2eproto.base);
  ::memset(&time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&id_) -
      reinterpret_cast<char*>(&time_)) + sizeof(id_));
}

SpecialCarMsg::~SpecialCarMsg() {
  // @@protoc_insertion_point(destructor:vision.SpecialCarMsg)
  SharedDtor();
}

void SpecialCarMsg::SharedDtor() {
  if (this != internal_default_instance()) delete time_;
}

void SpecialCarMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SpecialCarMsg& SpecialCarMsg::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SpecialCarMsg_vision_2eproto.base);
  return *internal_default_instance();
}


void SpecialCarMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.SpecialCarMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  array_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(time_ != nullptr);
    time_->Clear();
  }
  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SpecialCarMsg::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // repeated .vision.SpecialCar array = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_array(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      // optional .vision.data_time time = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ctx->ParseMessage(mutable_time(), ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SpecialCarMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.SpecialCarMsg)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .vision.SpecialCar array = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_array()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .vision.data_time time = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_time()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.SpecialCarMsg)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.SpecialCarMsg)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SpecialCarMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.SpecialCarMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // repeated .vision.SpecialCar array = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->array_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->array(static_cast<int>(i)),
      output);
  }

  // optional .vision.data_time time = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::time(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.SpecialCarMsg)
}

::google::protobuf::uint8* SpecialCarMsg::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.SpecialCarMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // repeated .vision.SpecialCar array = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->array_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->array(static_cast<int>(i)), target);
  }

  // optional .vision.data_time time = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::time(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.SpecialCarMsg)
  return target;
}

size_t SpecialCarMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.SpecialCarMsg)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .vision.ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vision.SpecialCar array = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->array_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->array(static_cast<int>(i)));
    }
  }

  // optional .vision.data_time time = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *time_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SpecialCarMsg::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.SpecialCarMsg)
  GOOGLE_DCHECK_NE(&from, this);
  const SpecialCarMsg* source =
      ::google::protobuf::DynamicCastToGenerated<SpecialCarMsg>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.SpecialCarMsg)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.SpecialCarMsg)
    MergeFrom(*source);
  }
}

void SpecialCarMsg::MergeFrom(const SpecialCarMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.SpecialCarMsg)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  array_.MergeFrom(from.array_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_time()->::vision::data_time::MergeFrom(from.time());
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SpecialCarMsg::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.SpecialCarMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SpecialCarMsg::CopyFrom(const SpecialCarMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.SpecialCarMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpecialCarMsg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->array())) return false;
  if (has_time()) {
    if (!this->time_->IsInitialized()) return false;
  }
  return true;
}

void SpecialCarMsg::Swap(SpecialCarMsg* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SpecialCarMsg::InternalSwap(SpecialCarMsg* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&array_)->InternalSwap(CastToBase(&other->array_));
  swap(time_, other->time_);
  swap(id_, other->id_);
}

::google::protobuf::Metadata SpecialCarMsg::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace vision
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::vision::data_time* Arena::CreateMaybeMessage< ::vision::data_time >(Arena* arena) {
  return Arena::CreateInternal< ::vision::data_time >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::Pedestrian* Arena::CreateMaybeMessage< ::vision::Pedestrian >(Arena* arena) {
  return Arena::CreateInternal< ::vision::Pedestrian >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::Obstacle* Arena::CreateMaybeMessage< ::vision::Obstacle >(Arena* arena) {
  return Arena::CreateInternal< ::vision::Obstacle >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::AbnormalCar* Arena::CreateMaybeMessage< ::vision::AbnormalCar >(Arena* arena) {
  return Arena::CreateInternal< ::vision::AbnormalCar >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::SpecialCar* Arena::CreateMaybeMessage< ::vision::SpecialCar >(Arena* arena) {
  return Arena::CreateInternal< ::vision::SpecialCar >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::AvailableArea* Arena::CreateMaybeMessage< ::vision::AvailableArea >(Arena* arena) {
  return Arena::CreateInternal< ::vision::AvailableArea >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::JamInfo* Arena::CreateMaybeMessage< ::vision::JamInfo >(Arena* arena) {
  return Arena::CreateInternal< ::vision::JamInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::FlowInfo* Arena::CreateMaybeMessage< ::vision::FlowInfo >(Arena* arena) {
  return Arena::CreateInternal< ::vision::FlowInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::Base* Arena::CreateMaybeMessage< ::vision::Base >(Arena* arena) {
  return Arena::CreateInternal< ::vision::Base >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::Crowd* Arena::CreateMaybeMessage< ::vision::Crowd >(Arena* arena) {
  return Arena::CreateInternal< ::vision::Crowd >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::Obstacles* Arena::CreateMaybeMessage< ::vision::Obstacles >(Arena* arena) {
  return Arena::CreateInternal< ::vision::Obstacles >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::AvailableAreas* Arena::CreateMaybeMessage< ::vision::AvailableAreas >(Arena* arena) {
  return Arena::CreateInternal< ::vision::AvailableAreas >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::IllegalCarWarn* Arena::CreateMaybeMessage< ::vision::IllegalCarWarn >(Arena* arena) {
  return Arena::CreateInternal< ::vision::IllegalCarWarn >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::Visibility* Arena::CreateMaybeMessage< ::vision::Visibility >(Arena* arena) {
  return Arena::CreateInternal< ::vision::Visibility >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::SmokeWarn* Arena::CreateMaybeMessage< ::vision::SmokeWarn >(Arena* arena) {
  return Arena::CreateInternal< ::vision::SmokeWarn >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::Timestamp* Arena::CreateMaybeMessage< ::vision::Timestamp >(Arena* arena) {
  return Arena::CreateInternal< ::vision::Timestamp >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::Detectobject* Arena::CreateMaybeMessage< ::vision::Detectobject >(Arena* arena) {
  return Arena::CreateInternal< ::vision::Detectobject >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::Detectobjects* Arena::CreateMaybeMessage< ::vision::Detectobjects >(Arena* arena) {
  return Arena::CreateInternal< ::vision::Detectobjects >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::TrafficJam* Arena::CreateMaybeMessage< ::vision::TrafficJam >(Arena* arena) {
  return Arena::CreateInternal< ::vision::TrafficJam >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::TrafficFlow* Arena::CreateMaybeMessage< ::vision::TrafficFlow >(Arena* arena) {
  return Arena::CreateInternal< ::vision::TrafficFlow >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::IceWarn* Arena::CreateMaybeMessage< ::vision::IceWarn >(Arena* arena) {
  return Arena::CreateInternal< ::vision::IceWarn >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::LaneWare* Arena::CreateMaybeMessage< ::vision::LaneWare >(Arena* arena) {
  return Arena::CreateInternal< ::vision::LaneWare >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::SpecialCarMsg* Arena::CreateMaybeMessage< ::vision::SpecialCarMsg >(Arena* arena) {
  return Arena::CreateInternal< ::vision::SpecialCarMsg >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
