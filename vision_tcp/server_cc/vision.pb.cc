// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vision.proto

#include "vision.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_vision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_AvailableArea_vision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_vision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Obstacle_vision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_vision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Pedestrian_vision_2eproto;
class PedestrianDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Pedestrian> _instance;
} _Pedestrian_default_instance_;
class ObstacleDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Obstacle> _instance;
} _Obstacle_default_instance_;
class AvailableAreaDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<AvailableArea> _instance;
} _AvailableArea_default_instance_;
class BaseDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Base> _instance;
} _Base_default_instance_;
class CrowdDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Crowd> _instance;
} _Crowd_default_instance_;
class ObstaclesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Obstacles> _instance;
} _Obstacles_default_instance_;
class AvailableAreasDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<AvailableAreas> _instance;
} _AvailableAreas_default_instance_;
static void InitDefaultsPedestrian_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_Pedestrian_default_instance_;
    new (ptr) ::Pedestrian();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Pedestrian::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Pedestrian_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsPedestrian_vision_2eproto}, {}};

static void InitDefaultsObstacle_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_Obstacle_default_instance_;
    new (ptr) ::Obstacle();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Obstacle::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Obstacle_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsObstacle_vision_2eproto}, {}};

static void InitDefaultsAvailableArea_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_AvailableArea_default_instance_;
    new (ptr) ::AvailableArea();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AvailableArea::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_AvailableArea_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsAvailableArea_vision_2eproto}, {}};

static void InitDefaultsBase_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_Base_default_instance_;
    new (ptr) ::Base();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Base::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Base_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsBase_vision_2eproto}, {}};

static void InitDefaultsCrowd_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_Crowd_default_instance_;
    new (ptr) ::Crowd();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Crowd::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Crowd_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCrowd_vision_2eproto}, {
      &scc_info_Pedestrian_vision_2eproto.base,}};

static void InitDefaultsObstacles_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_Obstacles_default_instance_;
    new (ptr) ::Obstacles();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Obstacles::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Obstacles_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsObstacles_vision_2eproto}, {
      &scc_info_Obstacle_vision_2eproto.base,}};

static void InitDefaultsAvailableAreas_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_AvailableAreas_default_instance_;
    new (ptr) ::AvailableAreas();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AvailableAreas::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_AvailableAreas_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsAvailableAreas_vision_2eproto}, {
      &scc_info_AvailableArea_vision_2eproto.base,}};

void InitDefaults_vision_2eproto() {
  ::google::protobuf::internal::InitSCC(&scc_info_Pedestrian_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Obstacle_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_AvailableArea_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Base_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Crowd_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Obstacles_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_AvailableAreas_vision_2eproto.base);
}

static ::google::protobuf::Metadata file_level_metadata_vision_2eproto[7];
static const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors_vision_2eproto[2];
static constexpr ::google::protobuf::ServiceDescriptor const** file_level_service_descriptors_vision_2eproto = nullptr;

const ::google::protobuf::uint32 TableStruct_vision_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::Pedestrian, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Pedestrian, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Pedestrian, object_id_),
  PROTOBUF_FIELD_OFFSET(::Pedestrian, object_type_),
  PROTOBUF_FIELD_OFFSET(::Pedestrian, x_),
  PROTOBUF_FIELD_OFFSET(::Pedestrian, y_),
  PROTOBUF_FIELD_OFFSET(::Pedestrian, camera_),
  PROTOBUF_FIELD_OFFSET(::Pedestrian, if_at_lane_),
  PROTOBUF_FIELD_OFFSET(::Pedestrian, lane_id_),
  PROTOBUF_FIELD_OFFSET(::Pedestrian, heading_),
  0,
  7,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::Obstacle, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Obstacle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Obstacle, object_id_),
  PROTOBUF_FIELD_OFFSET(::Obstacle, x_),
  PROTOBUF_FIELD_OFFSET(::Obstacle, y_),
  PROTOBUF_FIELD_OFFSET(::Obstacle, camera_),
  PROTOBUF_FIELD_OFFSET(::Obstacle, if_at_lane_),
  PROTOBUF_FIELD_OFFSET(::Obstacle, lane_id_),
  PROTOBUF_FIELD_OFFSET(::Obstacle, heading_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::AvailableArea, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::AvailableArea, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AvailableArea, object_id_),
  PROTOBUF_FIELD_OFFSET(::AvailableArea, x1_),
  PROTOBUF_FIELD_OFFSET(::AvailableArea, y1_),
  PROTOBUF_FIELD_OFFSET(::AvailableArea, x2_),
  PROTOBUF_FIELD_OFFSET(::AvailableArea, y2_),
  PROTOBUF_FIELD_OFFSET(::AvailableArea, camera_),
  PROTOBUF_FIELD_OFFSET(::AvailableArea, lane_id_),
  PROTOBUF_FIELD_OFFSET(::AvailableArea, heading_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::Base, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Base, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Base, id_),
  0,
  PROTOBUF_FIELD_OFFSET(::Crowd, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Crowd, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Crowd, id_),
  PROTOBUF_FIELD_OFFSET(::Crowd, pedestrian_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::Obstacles, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Obstacles, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Obstacles, id_),
  PROTOBUF_FIELD_OFFSET(::Obstacles, obstacle_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::AvailableAreas, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::AvailableAreas, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AvailableAreas, id_),
  PROTOBUF_FIELD_OFFSET(::AvailableAreas, area_),
  0,
  ~0u,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 13, sizeof(::Pedestrian)},
  { 21, 33, sizeof(::Obstacle)},
  { 40, 53, sizeof(::AvailableArea)},
  { 61, 67, sizeof(::Base)},
  { 68, 75, sizeof(::Crowd)},
  { 77, 84, sizeof(::Obstacles)},
  { 86, 93, sizeof(::AvailableAreas)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::_Pedestrian_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::_Obstacle_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::_AvailableArea_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::_Base_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::_Crowd_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::_Obstacles_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::_AvailableAreas_default_instance_),
};

static ::google::protobuf::internal::AssignDescriptorsTable assign_descriptors_table_vision_2eproto = {
  {}, AddDescriptors_vision_2eproto, "vision.proto", schemas,
  file_default_instances, TableStruct_vision_2eproto::offsets,
  file_level_metadata_vision_2eproto, 7, file_level_enum_descriptors_vision_2eproto, file_level_service_descriptors_vision_2eproto,
};

const char descriptor_table_protodef_vision_2eproto[] =
  "\n\014vision.proto\"\227\001\n\nPedestrian\022\021\n\tobject_"
  "id\030\001 \002(\005\022\032\n\013object_type\030\002 \002(\0162\005.TYPE\022\t\n\001"
  "x\030\003 \002(\005\022\t\n\001y\030\004 \002(\005\022\016\n\006camera\030\005 \002(\005\022\022\n\nif"
  "_at_lane\030\006 \001(\005\022\017\n\007lane_id\030\007 \001(\005\022\017\n\007headi"
  "ng\030\010 \001(\005\"y\n\010Obstacle\022\021\n\tobject_id\030\001 \002(\005\022"
  "\t\n\001x\030\002 \002(\005\022\t\n\001y\030\003 \002(\005\022\016\n\006camera\030\004 \002(\005\022\022\n"
  "\nif_at_lane\030\005 \001(\005\022\017\n\007lane_id\030\006 \001(\005\022\017\n\007he"
  "ading\030\007 \001(\005\"\204\001\n\rAvailableArea\022\021\n\tobject_"
  "id\030\001 \002(\005\022\n\n\002x1\030\002 \002(\005\022\n\n\002y1\030\003 \002(\005\022\n\n\002x2\030\004"
  " \002(\005\022\n\n\002y2\030\005 \002(\005\022\016\n\006camera\030\006 \002(\005\022\017\n\007lane"
  "_id\030\007 \001(\005\022\017\n\007heading\030\010 \001(\005\"\027\n\004Base\022\017\n\002id"
  "\030\001 \002(\0162\003.ID\"9\n\005Crowd\022\017\n\002id\030\001 \002(\0162\003.ID\022\037\n"
  "\npedestrian\030\002 \003(\0132\013.Pedestrian\"9\n\tObstac"
  "les\022\017\n\002id\030\001 \002(\0162\003.ID\022\033\n\010obstacle\030\002 \003(\0132\t"
  ".Obstacle\"\?\n\016AvailableAreas\022\017\n\002id\030\001 \002(\0162"
  "\003.ID\022\034\n\004area\030\002 \003(\0132\016.AvailableArea*x\n\002ID"
  "\022\020\n\014PEDESTRIAN_D\020\001\022\016\n\nILLEGAL_V1\020\002\022\016\n\nCA"
  "MERA_CAL\020\003\022\016\n\nROCKFALL_D\020\004\022\014\n\010SEEING_D\020\005"
  "\022\022\n\016AVAILABLE_AREA\020\006\022\016\n\nOBSTACLE_D\020\007*.\n\004"
  "TYPE\022\t\n\005HUMAN\020\001\022\013\n\007VEHICLE\020\002\022\016\n\nMOTORCYC"
  "LE\020\003"
  ;
static ::google::protobuf::internal::DescriptorTable descriptor_table_vision_2eproto = {
  false, InitDefaults_vision_2eproto, 
  descriptor_table_protodef_vision_2eproto,
  "vision.proto", &assign_descriptors_table_vision_2eproto, 804,
};

void AddDescriptors_vision_2eproto() {
  static constexpr ::google::protobuf::internal::InitFunc deps[1] =
  {
  };
 ::google::protobuf::internal::AddDescriptors(&descriptor_table_vision_2eproto, deps, 0);
}

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_vision_2eproto = []() { AddDescriptors_vision_2eproto(); return true; }();
const ::google::protobuf::EnumDescriptor* ID_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_vision_2eproto);
  return file_level_enum_descriptors_vision_2eproto[0];
}
bool ID_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TYPE_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_vision_2eproto);
  return file_level_enum_descriptors_vision_2eproto[1];
}
bool TYPE_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void Pedestrian::InitAsDefaultInstance() {
}
class Pedestrian::HasBitSetters {
 public:
  static void set_has_object_id(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_object_type(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_x(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_y(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_camera(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_if_at_lane(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_lane_id(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_heading(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Pedestrian::kObjectIdFieldNumber;
const int Pedestrian::kObjectTypeFieldNumber;
const int Pedestrian::kXFieldNumber;
const int Pedestrian::kYFieldNumber;
const int Pedestrian::kCameraFieldNumber;
const int Pedestrian::kIfAtLaneFieldNumber;
const int Pedestrian::kLaneIdFieldNumber;
const int Pedestrian::kHeadingFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Pedestrian::Pedestrian()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Pedestrian)
}
Pedestrian::Pedestrian(const Pedestrian& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&object_id_, &from.object_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&object_type_) -
    reinterpret_cast<char*>(&object_id_)) + sizeof(object_type_));
  // @@protoc_insertion_point(copy_constructor:Pedestrian)
}

void Pedestrian::SharedCtor() {
  ::memset(&object_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&heading_) -
      reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
  object_type_ = 1;
}

Pedestrian::~Pedestrian() {
  // @@protoc_insertion_point(destructor:Pedestrian)
  SharedDtor();
}

void Pedestrian::SharedDtor() {
}

void Pedestrian::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Pedestrian& Pedestrian::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Pedestrian_vision_2eproto.base);
  return *internal_default_instance();
}


void Pedestrian::Clear() {
// @@protoc_insertion_point(message_clear_start:Pedestrian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&object_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&heading_) -
        reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
    object_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Pedestrian::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_object_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required .TYPE object_type = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::TYPE_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(2, val, mutable_unknown_fields());
          break;
        }
        set_object_type(static_cast<::TYPE>(val));
        break;
      }
      // required int32 x = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_x(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 y = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        set_y(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 camera = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        set_camera(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 if_at_lane = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        set_if_at_lane(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_id = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        set_lane_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 heading = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 64) goto handle_unusual;
        set_heading(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Pedestrian::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Pedestrian)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_object_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .TYPE object_type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TYPE_IsValid(value)) {
            set_object_type(static_cast< ::TYPE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 x = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_x(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 y = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_y(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 camera = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_camera(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &camera_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 if_at_lane = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_if_at_lane(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &if_at_lane_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_id = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_lane_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 heading = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Pedestrian)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Pedestrian)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Pedestrian::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Pedestrian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->object_id(), output);
  }

  // required .TYPE object_type = 2;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->object_type(), output);
  }

  // required int32 x = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->x(), output);
  }

  // required int32 y = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->y(), output);
  }

  // required int32 camera = 5;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->camera(), output);
  }

  // optional int32 if_at_lane = 6;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->if_at_lane(), output);
  }

  // optional int32 lane_id = 7;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->lane_id(), output);
  }

  // optional int32 heading = 8;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->heading(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Pedestrian)
}

::google::protobuf::uint8* Pedestrian::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Pedestrian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->object_id(), target);
  }

  // required .TYPE object_type = 2;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->object_type(), target);
  }

  // required int32 x = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->x(), target);
  }

  // required int32 y = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->y(), target);
  }

  // required int32 camera = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->camera(), target);
  }

  // optional int32 if_at_lane = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->if_at_lane(), target);
  }

  // optional int32 lane_id = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->lane_id(), target);
  }

  // optional int32 heading = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->heading(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Pedestrian)
  return target;
}

size_t Pedestrian::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Pedestrian)
  size_t total_size = 0;

  if (has_object_id()) {
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());
  }

  if (has_x()) {
    // required int32 x = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());
  }

  if (has_y()) {
    // required int32 y = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());
  }

  if (has_camera()) {
    // required int32 camera = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());
  }

  if (has_object_type()) {
    // required .TYPE object_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->object_type());
  }

  return total_size;
}
size_t Pedestrian::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Pedestrian)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000008f) ^ 0x0000008f) == 0) {  // All required fields are present.
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());

    // required int32 x = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());

    // required int32 y = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());

    // required int32 camera = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());

    // required .TYPE object_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->object_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000070u) {
    // optional int32 if_at_lane = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->if_at_lane());
    }

    // optional int32 lane_id = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lane_id());
    }

    // optional int32 heading = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->heading());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Pedestrian::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Pedestrian)
  GOOGLE_DCHECK_NE(&from, this);
  const Pedestrian* source =
      ::google::protobuf::DynamicCastToGenerated<Pedestrian>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Pedestrian)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Pedestrian)
    MergeFrom(*source);
  }
}

void Pedestrian::MergeFrom(const Pedestrian& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Pedestrian)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      object_id_ = from.object_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000004u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000008u) {
      camera_ = from.camera_;
    }
    if (cached_has_bits & 0x00000010u) {
      if_at_lane_ = from.if_at_lane_;
    }
    if (cached_has_bits & 0x00000020u) {
      lane_id_ = from.lane_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      heading_ = from.heading_;
    }
    if (cached_has_bits & 0x00000080u) {
      object_type_ = from.object_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Pedestrian::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Pedestrian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Pedestrian::CopyFrom(const Pedestrian& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Pedestrian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pedestrian::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000008f) != 0x0000008f) return false;
  return true;
}

void Pedestrian::Swap(Pedestrian* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Pedestrian::InternalSwap(Pedestrian* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(object_id_, other->object_id_);
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(camera_, other->camera_);
  swap(if_at_lane_, other->if_at_lane_);
  swap(lane_id_, other->lane_id_);
  swap(heading_, other->heading_);
  swap(object_type_, other->object_type_);
}

::google::protobuf::Metadata Pedestrian::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Obstacle::InitAsDefaultInstance() {
}
class Obstacle::HasBitSetters {
 public:
  static void set_has_object_id(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_x(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_y(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_camera(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_if_at_lane(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_lane_id(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_heading(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Obstacle::kObjectIdFieldNumber;
const int Obstacle::kXFieldNumber;
const int Obstacle::kYFieldNumber;
const int Obstacle::kCameraFieldNumber;
const int Obstacle::kIfAtLaneFieldNumber;
const int Obstacle::kLaneIdFieldNumber;
const int Obstacle::kHeadingFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Obstacle::Obstacle()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Obstacle)
}
Obstacle::Obstacle(const Obstacle& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&object_id_, &from.object_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&heading_) -
    reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
  // @@protoc_insertion_point(copy_constructor:Obstacle)
}

void Obstacle::SharedCtor() {
  ::memset(&object_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&heading_) -
      reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
}

Obstacle::~Obstacle() {
  // @@protoc_insertion_point(destructor:Obstacle)
  SharedDtor();
}

void Obstacle::SharedDtor() {
}

void Obstacle::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Obstacle& Obstacle::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Obstacle_vision_2eproto.base);
  return *internal_default_instance();
}


void Obstacle::Clear() {
// @@protoc_insertion_point(message_clear_start:Obstacle)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&object_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&heading_) -
        reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Obstacle::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_object_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 x = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        set_x(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 y = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_y(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 camera = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        set_camera(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 if_at_lane = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        set_if_at_lane(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_id = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        set_lane_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 heading = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        set_heading(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Obstacle::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Obstacle)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_object_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 x = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_x(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 y = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_y(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 camera = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_camera(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &camera_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 if_at_lane = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_if_at_lane(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &if_at_lane_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_id = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_lane_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 heading = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Obstacle)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Obstacle)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Obstacle::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Obstacle)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->object_id(), output);
  }

  // required int32 x = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->x(), output);
  }

  // required int32 y = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->y(), output);
  }

  // required int32 camera = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->camera(), output);
  }

  // optional int32 if_at_lane = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->if_at_lane(), output);
  }

  // optional int32 lane_id = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->lane_id(), output);
  }

  // optional int32 heading = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->heading(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Obstacle)
}

::google::protobuf::uint8* Obstacle::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Obstacle)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->object_id(), target);
  }

  // required int32 x = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->x(), target);
  }

  // required int32 y = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->y(), target);
  }

  // required int32 camera = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->camera(), target);
  }

  // optional int32 if_at_lane = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->if_at_lane(), target);
  }

  // optional int32 lane_id = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->lane_id(), target);
  }

  // optional int32 heading = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->heading(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Obstacle)
  return target;
}

size_t Obstacle::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Obstacle)
  size_t total_size = 0;

  if (has_object_id()) {
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());
  }

  if (has_x()) {
    // required int32 x = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());
  }

  if (has_y()) {
    // required int32 y = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());
  }

  if (has_camera()) {
    // required int32 camera = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());
  }

  return total_size;
}
size_t Obstacle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Obstacle)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());

    // required int32 x = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());

    // required int32 y = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());

    // required int32 camera = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000070u) {
    // optional int32 if_at_lane = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->if_at_lane());
    }

    // optional int32 lane_id = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lane_id());
    }

    // optional int32 heading = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->heading());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Obstacle::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Obstacle)
  GOOGLE_DCHECK_NE(&from, this);
  const Obstacle* source =
      ::google::protobuf::DynamicCastToGenerated<Obstacle>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Obstacle)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Obstacle)
    MergeFrom(*source);
  }
}

void Obstacle::MergeFrom(const Obstacle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Obstacle)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      object_id_ = from.object_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000004u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000008u) {
      camera_ = from.camera_;
    }
    if (cached_has_bits & 0x00000010u) {
      if_at_lane_ = from.if_at_lane_;
    }
    if (cached_has_bits & 0x00000020u) {
      lane_id_ = from.lane_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      heading_ = from.heading_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Obstacle::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Obstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Obstacle::CopyFrom(const Obstacle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Obstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Obstacle::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  return true;
}

void Obstacle::Swap(Obstacle* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Obstacle::InternalSwap(Obstacle* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(object_id_, other->object_id_);
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(camera_, other->camera_);
  swap(if_at_lane_, other->if_at_lane_);
  swap(lane_id_, other->lane_id_);
  swap(heading_, other->heading_);
}

::google::protobuf::Metadata Obstacle::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void AvailableArea::InitAsDefaultInstance() {
}
class AvailableArea::HasBitSetters {
 public:
  static void set_has_object_id(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_x1(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_y1(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_x2(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_y2(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_camera(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_lane_id(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_heading(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AvailableArea::kObjectIdFieldNumber;
const int AvailableArea::kX1FieldNumber;
const int AvailableArea::kY1FieldNumber;
const int AvailableArea::kX2FieldNumber;
const int AvailableArea::kY2FieldNumber;
const int AvailableArea::kCameraFieldNumber;
const int AvailableArea::kLaneIdFieldNumber;
const int AvailableArea::kHeadingFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AvailableArea::AvailableArea()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AvailableArea)
}
AvailableArea::AvailableArea(const AvailableArea& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&object_id_, &from.object_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&heading_) -
    reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
  // @@protoc_insertion_point(copy_constructor:AvailableArea)
}

void AvailableArea::SharedCtor() {
  ::memset(&object_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&heading_) -
      reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
}

AvailableArea::~AvailableArea() {
  // @@protoc_insertion_point(destructor:AvailableArea)
  SharedDtor();
}

void AvailableArea::SharedDtor() {
}

void AvailableArea::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AvailableArea& AvailableArea::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_AvailableArea_vision_2eproto.base);
  return *internal_default_instance();
}


void AvailableArea::Clear() {
// @@protoc_insertion_point(message_clear_start:AvailableArea)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&object_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&heading_) -
        reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AvailableArea::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_object_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 x1 = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        set_x1(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 y1 = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_y1(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 x2 = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        set_x2(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 y2 = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        set_y2(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 camera = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        set_camera(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_id = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        set_lane_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 heading = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 64) goto handle_unusual;
        set_heading(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AvailableArea::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:AvailableArea)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_object_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 x1 = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_x1(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x1_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 y1 = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_y1(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y1_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 x2 = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_x2(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x2_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 y2 = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_y2(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y2_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 camera = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_camera(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &camera_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_id = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_lane_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 heading = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:AvailableArea)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:AvailableArea)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AvailableArea::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:AvailableArea)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->object_id(), output);
  }

  // required int32 x1 = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->x1(), output);
  }

  // required int32 y1 = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->y1(), output);
  }

  // required int32 x2 = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->x2(), output);
  }

  // required int32 y2 = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->y2(), output);
  }

  // required int32 camera = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->camera(), output);
  }

  // optional int32 lane_id = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->lane_id(), output);
  }

  // optional int32 heading = 8;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->heading(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:AvailableArea)
}

::google::protobuf::uint8* AvailableArea::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:AvailableArea)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->object_id(), target);
  }

  // required int32 x1 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->x1(), target);
  }

  // required int32 y1 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->y1(), target);
  }

  // required int32 x2 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->x2(), target);
  }

  // required int32 y2 = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->y2(), target);
  }

  // required int32 camera = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->camera(), target);
  }

  // optional int32 lane_id = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->lane_id(), target);
  }

  // optional int32 heading = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->heading(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AvailableArea)
  return target;
}

size_t AvailableArea::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:AvailableArea)
  size_t total_size = 0;

  if (has_object_id()) {
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());
  }

  if (has_x1()) {
    // required int32 x1 = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x1());
  }

  if (has_y1()) {
    // required int32 y1 = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y1());
  }

  if (has_x2()) {
    // required int32 x2 = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x2());
  }

  if (has_y2()) {
    // required int32 y2 = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y2());
  }

  if (has_camera()) {
    // required int32 camera = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());
  }

  return total_size;
}
size_t AvailableArea::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AvailableArea)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());

    // required int32 x1 = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x1());

    // required int32 y1 = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y1());

    // required int32 x2 = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x2());

    // required int32 y2 = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y2());

    // required int32 camera = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000c0u) {
    // optional int32 lane_id = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lane_id());
    }

    // optional int32 heading = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->heading());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AvailableArea::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AvailableArea)
  GOOGLE_DCHECK_NE(&from, this);
  const AvailableArea* source =
      ::google::protobuf::DynamicCastToGenerated<AvailableArea>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AvailableArea)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AvailableArea)
    MergeFrom(*source);
  }
}

void AvailableArea::MergeFrom(const AvailableArea& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AvailableArea)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      object_id_ = from.object_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      x1_ = from.x1_;
    }
    if (cached_has_bits & 0x00000004u) {
      y1_ = from.y1_;
    }
    if (cached_has_bits & 0x00000008u) {
      x2_ = from.x2_;
    }
    if (cached_has_bits & 0x00000010u) {
      y2_ = from.y2_;
    }
    if (cached_has_bits & 0x00000020u) {
      camera_ = from.camera_;
    }
    if (cached_has_bits & 0x00000040u) {
      lane_id_ = from.lane_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      heading_ = from.heading_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AvailableArea::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AvailableArea)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AvailableArea::CopyFrom(const AvailableArea& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AvailableArea)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvailableArea::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;
  return true;
}

void AvailableArea::Swap(AvailableArea* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AvailableArea::InternalSwap(AvailableArea* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(object_id_, other->object_id_);
  swap(x1_, other->x1_);
  swap(y1_, other->y1_);
  swap(x2_, other->x2_);
  swap(y2_, other->y2_);
  swap(camera_, other->camera_);
  swap(lane_id_, other->lane_id_);
  swap(heading_, other->heading_);
}

::google::protobuf::Metadata AvailableArea::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Base::InitAsDefaultInstance() {
}
class Base::HasBitSetters {
 public:
  static void set_has_id(Base* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Base::kIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Base::Base()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Base)
}
Base::Base(const Base& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:Base)
}

void Base::SharedCtor() {
  id_ = 1;
}

Base::~Base() {
  // @@protoc_insertion_point(destructor:Base)
  SharedDtor();
}

void Base::SharedDtor() {
}

void Base::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Base& Base::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Base_vision_2eproto.base);
  return *internal_default_instance();
}


void Base::Clear() {
// @@protoc_insertion_point(message_clear_start:Base)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  id_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Base::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::ID>(val));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Base::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Base)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ID_IsValid(value)) {
            set_id(static_cast< ::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Base)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Base)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Base::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Base)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Base)
}

::google::protobuf::uint8* Base::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Base)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Base)
  return target;
}

size_t Base::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Base)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Base::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Base)
  GOOGLE_DCHECK_NE(&from, this);
  const Base* source =
      ::google::protobuf::DynamicCastToGenerated<Base>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Base)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Base)
    MergeFrom(*source);
  }
}

void Base::MergeFrom(const Base& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Base)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_id()) {
    set_id(from.id());
  }
}

void Base::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Base)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Base::CopyFrom(const Base& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Base)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Base::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Base::Swap(Base* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Base::InternalSwap(Base* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(id_, other->id_);
}

::google::protobuf::Metadata Base::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Crowd::InitAsDefaultInstance() {
}
class Crowd::HasBitSetters {
 public:
  static void set_has_id(Crowd* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Crowd::kIdFieldNumber;
const int Crowd::kPedestrianFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Crowd::Crowd()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Crowd)
}
Crowd::Crowd(const Crowd& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      pedestrian_(from.pedestrian_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:Crowd)
}

void Crowd::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Crowd_vision_2eproto.base);
  id_ = 1;
}

Crowd::~Crowd() {
  // @@protoc_insertion_point(destructor:Crowd)
  SharedDtor();
}

void Crowd::SharedDtor() {
}

void Crowd::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Crowd& Crowd::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Crowd_vision_2eproto.base);
  return *internal_default_instance();
}


void Crowd::Clear() {
// @@protoc_insertion_point(message_clear_start:Crowd)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  pedestrian_.Clear();
  id_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Crowd::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::ID>(val));
        break;
      }
      // repeated .Pedestrian pedestrian = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_pedestrian(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Crowd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Crowd)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ID_IsValid(value)) {
            set_id(static_cast< ::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Pedestrian pedestrian = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_pedestrian()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Crowd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Crowd)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Crowd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Crowd)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // repeated .Pedestrian pedestrian = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->pedestrian_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->pedestrian(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Crowd)
}

::google::protobuf::uint8* Crowd::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Crowd)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // repeated .Pedestrian pedestrian = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->pedestrian_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->pedestrian(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Crowd)
  return target;
}

size_t Crowd::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Crowd)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Pedestrian pedestrian = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->pedestrian_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->pedestrian(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Crowd::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Crowd)
  GOOGLE_DCHECK_NE(&from, this);
  const Crowd* source =
      ::google::protobuf::DynamicCastToGenerated<Crowd>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Crowd)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Crowd)
    MergeFrom(*source);
  }
}

void Crowd::MergeFrom(const Crowd& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Crowd)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  pedestrian_.MergeFrom(from.pedestrian_);
  if (from.has_id()) {
    set_id(from.id());
  }
}

void Crowd::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Crowd)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Crowd::CopyFrom(const Crowd& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Crowd)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Crowd::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->pedestrian())) return false;
  return true;
}

void Crowd::Swap(Crowd* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Crowd::InternalSwap(Crowd* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&pedestrian_)->InternalSwap(CastToBase(&other->pedestrian_));
  swap(id_, other->id_);
}

::google::protobuf::Metadata Crowd::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Obstacles::InitAsDefaultInstance() {
}
class Obstacles::HasBitSetters {
 public:
  static void set_has_id(Obstacles* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Obstacles::kIdFieldNumber;
const int Obstacles::kObstacleFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Obstacles::Obstacles()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Obstacles)
}
Obstacles::Obstacles(const Obstacles& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      obstacle_(from.obstacle_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:Obstacles)
}

void Obstacles::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Obstacles_vision_2eproto.base);
  id_ = 1;
}

Obstacles::~Obstacles() {
  // @@protoc_insertion_point(destructor:Obstacles)
  SharedDtor();
}

void Obstacles::SharedDtor() {
}

void Obstacles::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Obstacles& Obstacles::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Obstacles_vision_2eproto.base);
  return *internal_default_instance();
}


void Obstacles::Clear() {
// @@protoc_insertion_point(message_clear_start:Obstacles)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  obstacle_.Clear();
  id_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Obstacles::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::ID>(val));
        break;
      }
      // repeated .Obstacle obstacle = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_obstacle(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Obstacles::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Obstacles)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ID_IsValid(value)) {
            set_id(static_cast< ::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Obstacle obstacle = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_obstacle()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Obstacles)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Obstacles)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Obstacles::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Obstacles)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // repeated .Obstacle obstacle = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->obstacle_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->obstacle(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Obstacles)
}

::google::protobuf::uint8* Obstacles::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Obstacles)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // repeated .Obstacle obstacle = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->obstacle_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->obstacle(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Obstacles)
  return target;
}

size_t Obstacles::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Obstacles)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Obstacle obstacle = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->obstacle_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->obstacle(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Obstacles::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Obstacles)
  GOOGLE_DCHECK_NE(&from, this);
  const Obstacles* source =
      ::google::protobuf::DynamicCastToGenerated<Obstacles>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Obstacles)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Obstacles)
    MergeFrom(*source);
  }
}

void Obstacles::MergeFrom(const Obstacles& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Obstacles)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  obstacle_.MergeFrom(from.obstacle_);
  if (from.has_id()) {
    set_id(from.id());
  }
}

void Obstacles::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Obstacles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Obstacles::CopyFrom(const Obstacles& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Obstacles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Obstacles::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->obstacle())) return false;
  return true;
}

void Obstacles::Swap(Obstacles* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Obstacles::InternalSwap(Obstacles* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&obstacle_)->InternalSwap(CastToBase(&other->obstacle_));
  swap(id_, other->id_);
}

::google::protobuf::Metadata Obstacles::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void AvailableAreas::InitAsDefaultInstance() {
}
class AvailableAreas::HasBitSetters {
 public:
  static void set_has_id(AvailableAreas* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AvailableAreas::kIdFieldNumber;
const int AvailableAreas::kAreaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AvailableAreas::AvailableAreas()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AvailableAreas)
}
AvailableAreas::AvailableAreas(const AvailableAreas& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      area_(from.area_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:AvailableAreas)
}

void AvailableAreas::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_AvailableAreas_vision_2eproto.base);
  id_ = 1;
}

AvailableAreas::~AvailableAreas() {
  // @@protoc_insertion_point(destructor:AvailableAreas)
  SharedDtor();
}

void AvailableAreas::SharedDtor() {
}

void AvailableAreas::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AvailableAreas& AvailableAreas::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_AvailableAreas_vision_2eproto.base);
  return *internal_default_instance();
}


void AvailableAreas::Clear() {
// @@protoc_insertion_point(message_clear_start:AvailableAreas)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  area_.Clear();
  id_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AvailableAreas::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::ID>(val));
        break;
      }
      // repeated .AvailableArea area = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_area(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AvailableAreas::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:AvailableAreas)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ID_IsValid(value)) {
            set_id(static_cast< ::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .AvailableArea area = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_area()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:AvailableAreas)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:AvailableAreas)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AvailableAreas::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:AvailableAreas)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // repeated .AvailableArea area = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->area_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->area(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:AvailableAreas)
}

::google::protobuf::uint8* AvailableAreas::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:AvailableAreas)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // repeated .AvailableArea area = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->area_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->area(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AvailableAreas)
  return target;
}

size_t AvailableAreas::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AvailableAreas)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .AvailableArea area = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->area_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->area(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AvailableAreas::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AvailableAreas)
  GOOGLE_DCHECK_NE(&from, this);
  const AvailableAreas* source =
      ::google::protobuf::DynamicCastToGenerated<AvailableAreas>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AvailableAreas)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AvailableAreas)
    MergeFrom(*source);
  }
}

void AvailableAreas::MergeFrom(const AvailableAreas& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AvailableAreas)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  area_.MergeFrom(from.area_);
  if (from.has_id()) {
    set_id(from.id());
  }
}

void AvailableAreas::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AvailableAreas)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AvailableAreas::CopyFrom(const AvailableAreas& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AvailableAreas)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvailableAreas::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->area())) return false;
  return true;
}

void AvailableAreas::Swap(AvailableAreas* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AvailableAreas::InternalSwap(AvailableAreas* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&area_)->InternalSwap(CastToBase(&other->area_));
  swap(id_, other->id_);
}

::google::protobuf::Metadata AvailableAreas::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::Pedestrian* Arena::CreateMaybeMessage< ::Pedestrian >(Arena* arena) {
  return Arena::CreateInternal< ::Pedestrian >(arena);
}
template<> PROTOBUF_NOINLINE ::Obstacle* Arena::CreateMaybeMessage< ::Obstacle >(Arena* arena) {
  return Arena::CreateInternal< ::Obstacle >(arena);
}
template<> PROTOBUF_NOINLINE ::AvailableArea* Arena::CreateMaybeMessage< ::AvailableArea >(Arena* arena) {
  return Arena::CreateInternal< ::AvailableArea >(arena);
}
template<> PROTOBUF_NOINLINE ::Base* Arena::CreateMaybeMessage< ::Base >(Arena* arena) {
  return Arena::CreateInternal< ::Base >(arena);
}
template<> PROTOBUF_NOINLINE ::Crowd* Arena::CreateMaybeMessage< ::Crowd >(Arena* arena) {
  return Arena::CreateInternal< ::Crowd >(arena);
}
template<> PROTOBUF_NOINLINE ::Obstacles* Arena::CreateMaybeMessage< ::Obstacles >(Arena* arena) {
  return Arena::CreateInternal< ::Obstacles >(arena);
}
template<> PROTOBUF_NOINLINE ::AvailableAreas* Arena::CreateMaybeMessage< ::AvailableAreas >(Arena* arena) {
  return Arena::CreateInternal< ::AvailableAreas >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
