// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vision.proto

#include "vision.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_vision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_AbnormalCar_vision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_vision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_AvailableArea_vision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_vision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Obstacle_vision_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_vision_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Pedestrian_vision_2eproto;
namespace vision {
class PedestrianDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Pedestrian> _instance;
} _Pedestrian_default_instance_;
class ObstacleDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Obstacle> _instance;
} _Obstacle_default_instance_;
class AbnormalCarDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<AbnormalCar> _instance;
} _AbnormalCar_default_instance_;
class AvailableAreaDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<AvailableArea> _instance;
} _AvailableArea_default_instance_;
class BaseDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Base> _instance;
} _Base_default_instance_;
class CrowdDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Crowd> _instance;
} _Crowd_default_instance_;
class ObstaclesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Obstacles> _instance;
} _Obstacles_default_instance_;
class AvailableAreasDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<AvailableAreas> _instance;
} _AvailableAreas_default_instance_;
class IllegalCarWarnDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IllegalCarWarn> _instance;
} _IllegalCarWarn_default_instance_;
class VisibilityDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Visibility> _instance;
} _Visibility_default_instance_;
class SmokeWarnDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SmokeWarn> _instance;
} _SmokeWarn_default_instance_;
}  // namespace vision
static void InitDefaultsPedestrian_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_Pedestrian_default_instance_;
    new (ptr) ::vision::Pedestrian();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::Pedestrian::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Pedestrian_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsPedestrian_vision_2eproto}, {}};

static void InitDefaultsObstacle_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_Obstacle_default_instance_;
    new (ptr) ::vision::Obstacle();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::Obstacle::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Obstacle_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsObstacle_vision_2eproto}, {}};

static void InitDefaultsAbnormalCar_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_AbnormalCar_default_instance_;
    new (ptr) ::vision::AbnormalCar();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::AbnormalCar::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_AbnormalCar_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsAbnormalCar_vision_2eproto}, {}};

static void InitDefaultsAvailableArea_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_AvailableArea_default_instance_;
    new (ptr) ::vision::AvailableArea();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::AvailableArea::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_AvailableArea_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsAvailableArea_vision_2eproto}, {}};

static void InitDefaultsBase_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_Base_default_instance_;
    new (ptr) ::vision::Base();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::Base::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Base_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsBase_vision_2eproto}, {}};

static void InitDefaultsCrowd_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_Crowd_default_instance_;
    new (ptr) ::vision::Crowd();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::Crowd::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Crowd_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCrowd_vision_2eproto}, {
      &scc_info_Pedestrian_vision_2eproto.base,}};

static void InitDefaultsObstacles_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_Obstacles_default_instance_;
    new (ptr) ::vision::Obstacles();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::Obstacles::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Obstacles_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsObstacles_vision_2eproto}, {
      &scc_info_Obstacle_vision_2eproto.base,}};

static void InitDefaultsAvailableAreas_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_AvailableAreas_default_instance_;
    new (ptr) ::vision::AvailableAreas();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::AvailableAreas::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_AvailableAreas_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsAvailableAreas_vision_2eproto}, {
      &scc_info_AvailableArea_vision_2eproto.base,}};

static void InitDefaultsIllegalCarWarn_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_IllegalCarWarn_default_instance_;
    new (ptr) ::vision::IllegalCarWarn();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::IllegalCarWarn::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_IllegalCarWarn_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsIllegalCarWarn_vision_2eproto}, {
      &scc_info_AbnormalCar_vision_2eproto.base,}};

static void InitDefaultsVisibility_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_Visibility_default_instance_;
    new (ptr) ::vision::Visibility();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::Visibility::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Visibility_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsVisibility_vision_2eproto}, {}};

static void InitDefaultsSmokeWarn_vision_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::vision::_SmokeWarn_default_instance_;
    new (ptr) ::vision::SmokeWarn();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::vision::SmokeWarn::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_SmokeWarn_vision_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsSmokeWarn_vision_2eproto}, {}};

void InitDefaults_vision_2eproto() {
  ::google::protobuf::internal::InitSCC(&scc_info_Pedestrian_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Obstacle_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_AbnormalCar_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_AvailableArea_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Base_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Crowd_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Obstacles_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_AvailableAreas_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IllegalCarWarn_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Visibility_vision_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_SmokeWarn_vision_2eproto.base);
}

static ::google::protobuf::Metadata file_level_metadata_vision_2eproto[11];
static const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors_vision_2eproto[2];
static constexpr ::google::protobuf::ServiceDescriptor const** file_level_service_descriptors_vision_2eproto = nullptr;

const ::google::protobuf::uint32 TableStruct_vision_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, object_id_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, object_type_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, lng_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, lat_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, camera_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, if_at_lane_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, lane_id_),
  PROTOBUF_FIELD_OFFSET(::vision::Pedestrian, heading_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, object_id_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, lng_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, lat_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, camera_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, if_at_lane_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, lane_id_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacle, heading_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::vision::AbnormalCar, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::AbnormalCar, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::AbnormalCar, object_id_),
  PROTOBUF_FIELD_OFFSET(::vision::AbnormalCar, lng_),
  PROTOBUF_FIELD_OFFSET(::vision::AbnormalCar, lat_),
  PROTOBUF_FIELD_OFFSET(::vision::AbnormalCar, lane_id_),
  PROTOBUF_FIELD_OFFSET(::vision::AbnormalCar, camera_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, object_id_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, lng1_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, lat1_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, lng2_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, lat2_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, lng3_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, lat3_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, lng4_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, lat4_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, camera_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, lane_id_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableArea, heading_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  PROTOBUF_FIELD_OFFSET(::vision::Base, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::Base, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::Base, id_),
  0,
  PROTOBUF_FIELD_OFFSET(::vision::Crowd, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::Crowd, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::Crowd, id_),
  PROTOBUF_FIELD_OFFSET(::vision::Crowd, pedestrian_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::vision::Obstacles, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacles, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::Obstacles, id_),
  PROTOBUF_FIELD_OFFSET(::vision::Obstacles, array_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::vision::AvailableAreas, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableAreas, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::AvailableAreas, id_),
  PROTOBUF_FIELD_OFFSET(::vision::AvailableAreas, area_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::vision::IllegalCarWarn, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::IllegalCarWarn, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::IllegalCarWarn, id_),
  PROTOBUF_FIELD_OFFSET(::vision::IllegalCarWarn, array_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::vision::Visibility, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::Visibility, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::Visibility, id_),
  PROTOBUF_FIELD_OFFSET(::vision::Visibility, distance_),
  PROTOBUF_FIELD_OFFSET(::vision::Visibility, level_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::vision::SmokeWarn, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vision::SmokeWarn, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::vision::SmokeWarn, id_),
  PROTOBUF_FIELD_OFFSET(::vision::SmokeWarn, warn_),
  0,
  1,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 13, sizeof(::vision::Pedestrian)},
  { 21, 33, sizeof(::vision::Obstacle)},
  { 40, 50, sizeof(::vision::AbnormalCar)},
  { 55, 72, sizeof(::vision::AvailableArea)},
  { 84, 90, sizeof(::vision::Base)},
  { 91, 98, sizeof(::vision::Crowd)},
  { 100, 107, sizeof(::vision::Obstacles)},
  { 109, 116, sizeof(::vision::AvailableAreas)},
  { 118, 125, sizeof(::vision::IllegalCarWarn)},
  { 127, 135, sizeof(::vision::Visibility)},
  { 138, 145, sizeof(::vision::SmokeWarn)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_Pedestrian_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_Obstacle_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_AbnormalCar_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_AvailableArea_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_Base_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_Crowd_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_Obstacles_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_AvailableAreas_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_IllegalCarWarn_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_Visibility_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::vision::_SmokeWarn_default_instance_),
};

static ::google::protobuf::internal::AssignDescriptorsTable assign_descriptors_table_vision_2eproto = {
  {}, AddDescriptors_vision_2eproto, "vision.proto", schemas,
  file_default_instances, TableStruct_vision_2eproto::offsets,
  file_level_metadata_vision_2eproto, 11, file_level_enum_descriptors_vision_2eproto, file_level_service_descriptors_vision_2eproto,
};

const char descriptor_table_protodef_vision_2eproto[] =
  "\n\014vision.proto\022\006vision\"\242\001\n\nPedestrian\022\021\n"
  "\tobject_id\030\001 \002(\005\022!\n\013object_type\030\002 \002(\0162\014."
  "vision.TYPE\022\013\n\003lng\030\003 \002(\005\022\013\n\003lat\030\004 \002(\005\022\016\n"
  "\006camera\030\005 \002(\005\022\022\n\nif_at_lane\030\006 \001(\005\022\017\n\007lan"
  "e_id\030\007 \001(\005\022\017\n\007heading\030\010 \001(\005\"}\n\010Obstacle\022"
  "\021\n\tobject_id\030\001 \002(\005\022\013\n\003lng\030\002 \002(\005\022\013\n\003lat\030\003"
  " \002(\005\022\016\n\006camera\030\004 \002(\005\022\022\n\nif_at_lane\030\005 \001(\005"
  "\022\017\n\007lane_id\030\006 \001(\005\022\017\n\007heading\030\007 \001(\005\"[\n\013Ab"
  "normalCar\022\021\n\tobject_id\030\001 \002(\005\022\013\n\003lng\030\002 \002("
  "\005\022\013\n\003lat\030\003 \002(\005\022\017\n\007lane_id\030\004 \001(\005\022\016\n\006camer"
  "a\030\005 \001(\005\"\304\001\n\rAvailableArea\022\021\n\tobject_id\030\001"
  " \002(\005\022\014\n\004lng1\030\002 \002(\005\022\014\n\004lat1\030\003 \002(\005\022\014\n\004lng2"
  "\030\004 \002(\005\022\014\n\004lat2\030\005 \002(\005\022\014\n\004lng3\030\006 \002(\005\022\014\n\004la"
  "t3\030\007 \002(\005\022\014\n\004lng4\030\010 \002(\005\022\014\n\004lat4\030\t \002(\005\022\016\n\006"
  "camera\030\n \002(\005\022\017\n\007lane_id\030\013 \001(\005\022\017\n\007heading"
  "\030\014 \001(\005\"\036\n\004Base\022\026\n\002id\030\001 \002(\0162\n.vision.ID\"G"
  "\n\005Crowd\022\026\n\002id\030\001 \002(\0162\n.vision.ID\022&\n\npedes"
  "trian\030\002 \003(\0132\022.vision.Pedestrian\"D\n\tObsta"
  "cles\022\026\n\002id\030\001 \002(\0162\n.vision.ID\022\037\n\005array\030\002 "
  "\003(\0132\020.vision.Obstacle\"M\n\016AvailableAreas\022"
  "\026\n\002id\030\001 \002(\0162\n.vision.ID\022#\n\004area\030\002 \003(\0132\025."
  "vision.AvailableArea\"L\n\016IllegalCarWarn\022\026"
  "\n\002id\030\001 \002(\0162\n.vision.ID\022\"\n\005array\030\002 \003(\0132\023."
  "vision.AbnormalCar\"E\n\nVisibility\022\026\n\002id\030\001"
  " \002(\0162\n.vision.ID\022\020\n\010distance\030\002 \002(\001\022\r\n\005le"
  "vel\030\003 \002(\005\"1\n\tSmokeWarn\022\026\n\002id\030\001 \002(\0162\n.vis"
  "ion.ID\022\014\n\004warn\030\002 \002(\010*\304\001\n\002ID\022\013\n\007DEFAULT\020\000"
  "\022\020\n\014PEDESTRIAN_D\020\001\022\016\n\nILLEGAL_V1\020\002\022\016\n\nVI"
  "SIBILITY\020\003\022\022\n\016AVAILABLE_AREA\020\004\022\020\n\014ABNORM"
  "AL_CAR\020\005\022\016\n\nILLEGAL_V2\020\006\022\022\n\016TRAFFIC_STAT"
  "US\020\007\022\024\n\020BACKWARD_DRIVING\020\010\022\017\n\013ROAD_DANGE"
  "R\020\t\022\016\n\nFIRE_SMOKE\020\n*:\n\004TYPE\022\n\n\006OTHERS\020\000\022"
  "\t\n\005HUMAN\020\001\022\013\n\007VEHICLE\020\002\022\016\n\nMOTORCYCLE\020\003"
  ;
static ::google::protobuf::internal::DescriptorTable descriptor_table_vision_2eproto = {
  false, InitDefaults_vision_2eproto, 
  descriptor_table_protodef_vision_2eproto,
  "vision.proto", &assign_descriptors_table_vision_2eproto, 1319,
};

void AddDescriptors_vision_2eproto() {
  static constexpr ::google::protobuf::internal::InitFunc deps[1] =
  {
  };
 ::google::protobuf::internal::AddDescriptors(&descriptor_table_vision_2eproto, deps, 0);
}

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_vision_2eproto = []() { AddDescriptors_vision_2eproto(); return true; }();
namespace vision {
const ::google::protobuf::EnumDescriptor* ID_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_vision_2eproto);
  return file_level_enum_descriptors_vision_2eproto[0];
}
bool ID_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TYPE_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_vision_2eproto);
  return file_level_enum_descriptors_vision_2eproto[1];
}
bool TYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void Pedestrian::InitAsDefaultInstance() {
}
class Pedestrian::HasBitSetters {
 public:
  static void set_has_object_id(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_object_type(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lng(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_lat(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_camera(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_if_at_lane(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_lane_id(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_heading(Pedestrian* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Pedestrian::kObjectIdFieldNumber;
const int Pedestrian::kObjectTypeFieldNumber;
const int Pedestrian::kLngFieldNumber;
const int Pedestrian::kLatFieldNumber;
const int Pedestrian::kCameraFieldNumber;
const int Pedestrian::kIfAtLaneFieldNumber;
const int Pedestrian::kLaneIdFieldNumber;
const int Pedestrian::kHeadingFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Pedestrian::Pedestrian()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.Pedestrian)
}
Pedestrian::Pedestrian(const Pedestrian& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&object_id_, &from.object_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&heading_) -
    reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
  // @@protoc_insertion_point(copy_constructor:vision.Pedestrian)
}

void Pedestrian::SharedCtor() {
  ::memset(&object_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&heading_) -
      reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
}

Pedestrian::~Pedestrian() {
  // @@protoc_insertion_point(destructor:vision.Pedestrian)
  SharedDtor();
}

void Pedestrian::SharedDtor() {
}

void Pedestrian::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Pedestrian& Pedestrian::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Pedestrian_vision_2eproto.base);
  return *internal_default_instance();
}


void Pedestrian::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.Pedestrian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&object_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&heading_) -
        reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Pedestrian::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_object_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required .vision.TYPE object_type = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::TYPE_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(2, val, mutable_unknown_fields());
          break;
        }
        set_object_type(static_cast<::vision::TYPE>(val));
        break;
      }
      // required int32 lng = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_lng(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lat = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        set_lat(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 camera = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        set_camera(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 if_at_lane = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        set_if_at_lane(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_id = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        set_lane_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 heading = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 64) goto handle_unusual;
        set_heading(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Pedestrian::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.Pedestrian)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_object_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .vision.TYPE object_type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::TYPE_IsValid(value)) {
            set_object_type(static_cast< ::vision::TYPE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lng = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_lng(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lng_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lat = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_lat(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lat_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 camera = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_camera(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &camera_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 if_at_lane = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_if_at_lane(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &if_at_lane_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_id = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_lane_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 heading = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.Pedestrian)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.Pedestrian)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Pedestrian::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.Pedestrian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->object_id(), output);
  }

  // required .vision.TYPE object_type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->object_type(), output);
  }

  // required int32 lng = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lng(), output);
  }

  // required int32 lat = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->lat(), output);
  }

  // required int32 camera = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->camera(), output);
  }

  // optional int32 if_at_lane = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->if_at_lane(), output);
  }

  // optional int32 lane_id = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->lane_id(), output);
  }

  // optional int32 heading = 8;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->heading(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.Pedestrian)
}

::google::protobuf::uint8* Pedestrian::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.Pedestrian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->object_id(), target);
  }

  // required .vision.TYPE object_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->object_type(), target);
  }

  // required int32 lng = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->lng(), target);
  }

  // required int32 lat = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->lat(), target);
  }

  // required int32 camera = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->camera(), target);
  }

  // optional int32 if_at_lane = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->if_at_lane(), target);
  }

  // optional int32 lane_id = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->lane_id(), target);
  }

  // optional int32 heading = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->heading(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.Pedestrian)
  return target;
}

size_t Pedestrian::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.Pedestrian)
  size_t total_size = 0;

  if (has_object_id()) {
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());
  }

  if (has_object_type()) {
    // required .vision.TYPE object_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->object_type());
  }

  if (has_lng()) {
    // required int32 lng = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng());
  }

  if (has_lat()) {
    // required int32 lat = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat());
  }

  if (has_camera()) {
    // required int32 camera = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());
  }

  return total_size;
}
size_t Pedestrian::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.Pedestrian)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());

    // required .vision.TYPE object_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->object_type());

    // required int32 lng = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng());

    // required int32 lat = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat());

    // required int32 camera = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000e0u) {
    // optional int32 if_at_lane = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->if_at_lane());
    }

    // optional int32 lane_id = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lane_id());
    }

    // optional int32 heading = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->heading());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Pedestrian::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.Pedestrian)
  GOOGLE_DCHECK_NE(&from, this);
  const Pedestrian* source =
      ::google::protobuf::DynamicCastToGenerated<Pedestrian>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.Pedestrian)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.Pedestrian)
    MergeFrom(*source);
  }
}

void Pedestrian::MergeFrom(const Pedestrian& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.Pedestrian)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      object_id_ = from.object_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      object_type_ = from.object_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      lng_ = from.lng_;
    }
    if (cached_has_bits & 0x00000008u) {
      lat_ = from.lat_;
    }
    if (cached_has_bits & 0x00000010u) {
      camera_ = from.camera_;
    }
    if (cached_has_bits & 0x00000020u) {
      if_at_lane_ = from.if_at_lane_;
    }
    if (cached_has_bits & 0x00000040u) {
      lane_id_ = from.lane_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      heading_ = from.heading_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Pedestrian::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.Pedestrian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Pedestrian::CopyFrom(const Pedestrian& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.Pedestrian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pedestrian::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  return true;
}

void Pedestrian::Swap(Pedestrian* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Pedestrian::InternalSwap(Pedestrian* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(object_id_, other->object_id_);
  swap(object_type_, other->object_type_);
  swap(lng_, other->lng_);
  swap(lat_, other->lat_);
  swap(camera_, other->camera_);
  swap(if_at_lane_, other->if_at_lane_);
  swap(lane_id_, other->lane_id_);
  swap(heading_, other->heading_);
}

::google::protobuf::Metadata Pedestrian::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Obstacle::InitAsDefaultInstance() {
}
class Obstacle::HasBitSetters {
 public:
  static void set_has_object_id(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_lng(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lat(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_camera(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_if_at_lane(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_lane_id(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_heading(Obstacle* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Obstacle::kObjectIdFieldNumber;
const int Obstacle::kLngFieldNumber;
const int Obstacle::kLatFieldNumber;
const int Obstacle::kCameraFieldNumber;
const int Obstacle::kIfAtLaneFieldNumber;
const int Obstacle::kLaneIdFieldNumber;
const int Obstacle::kHeadingFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Obstacle::Obstacle()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.Obstacle)
}
Obstacle::Obstacle(const Obstacle& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&object_id_, &from.object_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&heading_) -
    reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
  // @@protoc_insertion_point(copy_constructor:vision.Obstacle)
}

void Obstacle::SharedCtor() {
  ::memset(&object_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&heading_) -
      reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
}

Obstacle::~Obstacle() {
  // @@protoc_insertion_point(destructor:vision.Obstacle)
  SharedDtor();
}

void Obstacle::SharedDtor() {
}

void Obstacle::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Obstacle& Obstacle::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Obstacle_vision_2eproto.base);
  return *internal_default_instance();
}


void Obstacle::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.Obstacle)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&object_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&heading_) -
        reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Obstacle::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_object_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lng = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        set_lng(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lat = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_lat(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 camera = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        set_camera(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 if_at_lane = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        set_if_at_lane(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_id = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        set_lane_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 heading = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        set_heading(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Obstacle::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.Obstacle)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_object_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lng = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_lng(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lng_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lat = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_lat(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lat_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 camera = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_camera(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &camera_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 if_at_lane = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_if_at_lane(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &if_at_lane_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_id = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_lane_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 heading = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.Obstacle)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.Obstacle)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Obstacle::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.Obstacle)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->object_id(), output);
  }

  // required int32 lng = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->lng(), output);
  }

  // required int32 lat = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lat(), output);
  }

  // required int32 camera = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->camera(), output);
  }

  // optional int32 if_at_lane = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->if_at_lane(), output);
  }

  // optional int32 lane_id = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->lane_id(), output);
  }

  // optional int32 heading = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->heading(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.Obstacle)
}

::google::protobuf::uint8* Obstacle::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.Obstacle)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->object_id(), target);
  }

  // required int32 lng = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->lng(), target);
  }

  // required int32 lat = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->lat(), target);
  }

  // required int32 camera = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->camera(), target);
  }

  // optional int32 if_at_lane = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->if_at_lane(), target);
  }

  // optional int32 lane_id = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->lane_id(), target);
  }

  // optional int32 heading = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->heading(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.Obstacle)
  return target;
}

size_t Obstacle::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.Obstacle)
  size_t total_size = 0;

  if (has_object_id()) {
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());
  }

  if (has_lng()) {
    // required int32 lng = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng());
  }

  if (has_lat()) {
    // required int32 lat = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat());
  }

  if (has_camera()) {
    // required int32 camera = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());
  }

  return total_size;
}
size_t Obstacle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.Obstacle)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());

    // required int32 lng = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng());

    // required int32 lat = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat());

    // required int32 camera = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000070u) {
    // optional int32 if_at_lane = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->if_at_lane());
    }

    // optional int32 lane_id = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lane_id());
    }

    // optional int32 heading = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->heading());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Obstacle::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.Obstacle)
  GOOGLE_DCHECK_NE(&from, this);
  const Obstacle* source =
      ::google::protobuf::DynamicCastToGenerated<Obstacle>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.Obstacle)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.Obstacle)
    MergeFrom(*source);
  }
}

void Obstacle::MergeFrom(const Obstacle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.Obstacle)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      object_id_ = from.object_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      lng_ = from.lng_;
    }
    if (cached_has_bits & 0x00000004u) {
      lat_ = from.lat_;
    }
    if (cached_has_bits & 0x00000008u) {
      camera_ = from.camera_;
    }
    if (cached_has_bits & 0x00000010u) {
      if_at_lane_ = from.if_at_lane_;
    }
    if (cached_has_bits & 0x00000020u) {
      lane_id_ = from.lane_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      heading_ = from.heading_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Obstacle::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.Obstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Obstacle::CopyFrom(const Obstacle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.Obstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Obstacle::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  return true;
}

void Obstacle::Swap(Obstacle* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Obstacle::InternalSwap(Obstacle* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(object_id_, other->object_id_);
  swap(lng_, other->lng_);
  swap(lat_, other->lat_);
  swap(camera_, other->camera_);
  swap(if_at_lane_, other->if_at_lane_);
  swap(lane_id_, other->lane_id_);
  swap(heading_, other->heading_);
}

::google::protobuf::Metadata Obstacle::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void AbnormalCar::InitAsDefaultInstance() {
}
class AbnormalCar::HasBitSetters {
 public:
  static void set_has_object_id(AbnormalCar* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_lng(AbnormalCar* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lat(AbnormalCar* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_lane_id(AbnormalCar* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_camera(AbnormalCar* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AbnormalCar::kObjectIdFieldNumber;
const int AbnormalCar::kLngFieldNumber;
const int AbnormalCar::kLatFieldNumber;
const int AbnormalCar::kLaneIdFieldNumber;
const int AbnormalCar::kCameraFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AbnormalCar::AbnormalCar()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.AbnormalCar)
}
AbnormalCar::AbnormalCar(const AbnormalCar& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&object_id_, &from.object_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&camera_) -
    reinterpret_cast<char*>(&object_id_)) + sizeof(camera_));
  // @@protoc_insertion_point(copy_constructor:vision.AbnormalCar)
}

void AbnormalCar::SharedCtor() {
  ::memset(&object_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&camera_) -
      reinterpret_cast<char*>(&object_id_)) + sizeof(camera_));
}

AbnormalCar::~AbnormalCar() {
  // @@protoc_insertion_point(destructor:vision.AbnormalCar)
  SharedDtor();
}

void AbnormalCar::SharedDtor() {
}

void AbnormalCar::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AbnormalCar& AbnormalCar::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_AbnormalCar_vision_2eproto.base);
  return *internal_default_instance();
}


void AbnormalCar::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.AbnormalCar)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&object_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&camera_) -
        reinterpret_cast<char*>(&object_id_)) + sizeof(camera_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AbnormalCar::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_object_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lng = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        set_lng(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lat = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_lat(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_id = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        set_lane_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 camera = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        set_camera(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AbnormalCar::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.AbnormalCar)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_object_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lng = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_lng(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lng_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lat = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_lat(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lat_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_id = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_lane_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 camera = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_camera(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &camera_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.AbnormalCar)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.AbnormalCar)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AbnormalCar::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.AbnormalCar)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->object_id(), output);
  }

  // required int32 lng = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->lng(), output);
  }

  // required int32 lat = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lat(), output);
  }

  // optional int32 lane_id = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->lane_id(), output);
  }

  // optional int32 camera = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->camera(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.AbnormalCar)
}

::google::protobuf::uint8* AbnormalCar::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.AbnormalCar)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->object_id(), target);
  }

  // required int32 lng = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->lng(), target);
  }

  // required int32 lat = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->lat(), target);
  }

  // optional int32 lane_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->lane_id(), target);
  }

  // optional int32 camera = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->camera(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.AbnormalCar)
  return target;
}

size_t AbnormalCar::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.AbnormalCar)
  size_t total_size = 0;

  if (has_object_id()) {
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());
  }

  if (has_lng()) {
    // required int32 lng = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng());
  }

  if (has_lat()) {
    // required int32 lat = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat());
  }

  return total_size;
}
size_t AbnormalCar::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.AbnormalCar)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());

    // required int32 lng = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng());

    // required int32 lat = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000018u) {
    // optional int32 lane_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lane_id());
    }

    // optional int32 camera = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->camera());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AbnormalCar::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.AbnormalCar)
  GOOGLE_DCHECK_NE(&from, this);
  const AbnormalCar* source =
      ::google::protobuf::DynamicCastToGenerated<AbnormalCar>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.AbnormalCar)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.AbnormalCar)
    MergeFrom(*source);
  }
}

void AbnormalCar::MergeFrom(const AbnormalCar& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.AbnormalCar)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      object_id_ = from.object_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      lng_ = from.lng_;
    }
    if (cached_has_bits & 0x00000004u) {
      lat_ = from.lat_;
    }
    if (cached_has_bits & 0x00000008u) {
      lane_id_ = from.lane_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      camera_ = from.camera_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AbnormalCar::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.AbnormalCar)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AbnormalCar::CopyFrom(const AbnormalCar& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.AbnormalCar)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AbnormalCar::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  return true;
}

void AbnormalCar::Swap(AbnormalCar* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AbnormalCar::InternalSwap(AbnormalCar* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(object_id_, other->object_id_);
  swap(lng_, other->lng_);
  swap(lat_, other->lat_);
  swap(lane_id_, other->lane_id_);
  swap(camera_, other->camera_);
}

::google::protobuf::Metadata AbnormalCar::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void AvailableArea::InitAsDefaultInstance() {
}
class AvailableArea::HasBitSetters {
 public:
  static void set_has_object_id(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_lng1(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lat1(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_lng2(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_lat2(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_lng3(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_lat3(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_lng4(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_lat4(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static void set_has_camera(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
  static void set_has_lane_id(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000400u;
  }
  static void set_has_heading(AvailableArea* msg) {
    msg->_has_bits_[0] |= 0x00000800u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AvailableArea::kObjectIdFieldNumber;
const int AvailableArea::kLng1FieldNumber;
const int AvailableArea::kLat1FieldNumber;
const int AvailableArea::kLng2FieldNumber;
const int AvailableArea::kLat2FieldNumber;
const int AvailableArea::kLng3FieldNumber;
const int AvailableArea::kLat3FieldNumber;
const int AvailableArea::kLng4FieldNumber;
const int AvailableArea::kLat4FieldNumber;
const int AvailableArea::kCameraFieldNumber;
const int AvailableArea::kLaneIdFieldNumber;
const int AvailableArea::kHeadingFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AvailableArea::AvailableArea()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.AvailableArea)
}
AvailableArea::AvailableArea(const AvailableArea& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&object_id_, &from.object_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&heading_) -
    reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
  // @@protoc_insertion_point(copy_constructor:vision.AvailableArea)
}

void AvailableArea::SharedCtor() {
  ::memset(&object_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&heading_) -
      reinterpret_cast<char*>(&object_id_)) + sizeof(heading_));
}

AvailableArea::~AvailableArea() {
  // @@protoc_insertion_point(destructor:vision.AvailableArea)
  SharedDtor();
}

void AvailableArea::SharedDtor() {
}

void AvailableArea::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AvailableArea& AvailableArea::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_AvailableArea_vision_2eproto.base);
  return *internal_default_instance();
}


void AvailableArea::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.AvailableArea)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&object_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lng4_) -
        reinterpret_cast<char*>(&object_id_)) + sizeof(lng4_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&lat4_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&heading_) -
        reinterpret_cast<char*>(&lat4_)) + sizeof(heading_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AvailableArea::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_object_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lng1 = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        set_lng1(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lat1 = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_lat1(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lng2 = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        set_lng2(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lat2 = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        set_lat2(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lng3 = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        set_lng3(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lat3 = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        set_lat3(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lng4 = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 64) goto handle_unusual;
        set_lng4(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lat4 = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 72) goto handle_unusual;
        set_lat4(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 camera = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 80) goto handle_unusual;
        set_camera(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_id = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 88) goto handle_unusual;
        set_lane_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 heading = 12;
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 96) goto handle_unusual;
        set_heading(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AvailableArea::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.AvailableArea)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 object_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_object_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lng1 = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_lng1(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lng1_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lat1 = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_lat1(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lat1_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lng2 = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_lng2(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lng2_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lat2 = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_lat2(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lat2_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lng3 = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_lng3(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lng3_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lat3 = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_lat3(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lat3_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lng4 = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_lng4(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lng4_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lat4 = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_lat4(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lat4_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 camera = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (80 & 0xFF)) {
          HasBitSetters::set_has_camera(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &camera_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_id = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (88 & 0xFF)) {
          HasBitSetters::set_has_lane_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 heading = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (96 & 0xFF)) {
          HasBitSetters::set_has_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.AvailableArea)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.AvailableArea)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AvailableArea::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.AvailableArea)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->object_id(), output);
  }

  // required int32 lng1 = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->lng1(), output);
  }

  // required int32 lat1 = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lat1(), output);
  }

  // required int32 lng2 = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->lng2(), output);
  }

  // required int32 lat2 = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->lat2(), output);
  }

  // required int32 lng3 = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->lng3(), output);
  }

  // required int32 lat3 = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->lat3(), output);
  }

  // required int32 lng4 = 8;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->lng4(), output);
  }

  // required int32 lat4 = 9;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->lat4(), output);
  }

  // required int32 camera = 10;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->camera(), output);
  }

  // optional int32 lane_id = 11;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->lane_id(), output);
  }

  // optional int32 heading = 12;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->heading(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.AvailableArea)
}

::google::protobuf::uint8* AvailableArea::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.AvailableArea)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->object_id(), target);
  }

  // required int32 lng1 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->lng1(), target);
  }

  // required int32 lat1 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->lat1(), target);
  }

  // required int32 lng2 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->lng2(), target);
  }

  // required int32 lat2 = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->lat2(), target);
  }

  // required int32 lng3 = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->lng3(), target);
  }

  // required int32 lat3 = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->lat3(), target);
  }

  // required int32 lng4 = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->lng4(), target);
  }

  // required int32 lat4 = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->lat4(), target);
  }

  // required int32 camera = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->camera(), target);
  }

  // optional int32 lane_id = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->lane_id(), target);
  }

  // optional int32 heading = 12;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(12, this->heading(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.AvailableArea)
  return target;
}

size_t AvailableArea::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.AvailableArea)
  size_t total_size = 0;

  if (has_object_id()) {
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());
  }

  if (has_lng1()) {
    // required int32 lng1 = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng1());
  }

  if (has_lat1()) {
    // required int32 lat1 = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat1());
  }

  if (has_lng2()) {
    // required int32 lng2 = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng2());
  }

  if (has_lat2()) {
    // required int32 lat2 = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat2());
  }

  if (has_lng3()) {
    // required int32 lng3 = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng3());
  }

  if (has_lat3()) {
    // required int32 lat3 = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat3());
  }

  if (has_lng4()) {
    // required int32 lng4 = 8;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng4());
  }

  if (has_lat4()) {
    // required int32 lat4 = 9;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat4());
  }

  if (has_camera()) {
    // required int32 camera = 10;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());
  }

  return total_size;
}
size_t AvailableArea::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.AvailableArea)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x000003ff) ^ 0x000003ff) == 0) {  // All required fields are present.
    // required int32 object_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->object_id());

    // required int32 lng1 = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng1());

    // required int32 lat1 = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat1());

    // required int32 lng2 = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng2());

    // required int32 lat2 = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat2());

    // required int32 lng3 = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng3());

    // required int32 lat3 = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat3());

    // required int32 lng4 = 8;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lng4());

    // required int32 lat4 = 9;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat4());

    // required int32 camera = 10;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000c00u) {
    // optional int32 lane_id = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lane_id());
    }

    // optional int32 heading = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->heading());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AvailableArea::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.AvailableArea)
  GOOGLE_DCHECK_NE(&from, this);
  const AvailableArea* source =
      ::google::protobuf::DynamicCastToGenerated<AvailableArea>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.AvailableArea)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.AvailableArea)
    MergeFrom(*source);
  }
}

void AvailableArea::MergeFrom(const AvailableArea& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.AvailableArea)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      object_id_ = from.object_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      lng1_ = from.lng1_;
    }
    if (cached_has_bits & 0x00000004u) {
      lat1_ = from.lat1_;
    }
    if (cached_has_bits & 0x00000008u) {
      lng2_ = from.lng2_;
    }
    if (cached_has_bits & 0x00000010u) {
      lat2_ = from.lat2_;
    }
    if (cached_has_bits & 0x00000020u) {
      lng3_ = from.lng3_;
    }
    if (cached_has_bits & 0x00000040u) {
      lat3_ = from.lat3_;
    }
    if (cached_has_bits & 0x00000080u) {
      lng4_ = from.lng4_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      lat4_ = from.lat4_;
    }
    if (cached_has_bits & 0x00000200u) {
      camera_ = from.camera_;
    }
    if (cached_has_bits & 0x00000400u) {
      lane_id_ = from.lane_id_;
    }
    if (cached_has_bits & 0x00000800u) {
      heading_ = from.heading_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AvailableArea::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.AvailableArea)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AvailableArea::CopyFrom(const AvailableArea& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.AvailableArea)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvailableArea::IsInitialized() const {
  if ((_has_bits_[0] & 0x000003ff) != 0x000003ff) return false;
  return true;
}

void AvailableArea::Swap(AvailableArea* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AvailableArea::InternalSwap(AvailableArea* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(object_id_, other->object_id_);
  swap(lng1_, other->lng1_);
  swap(lat1_, other->lat1_);
  swap(lng2_, other->lng2_);
  swap(lat2_, other->lat2_);
  swap(lng3_, other->lng3_);
  swap(lat3_, other->lat3_);
  swap(lng4_, other->lng4_);
  swap(lat4_, other->lat4_);
  swap(camera_, other->camera_);
  swap(lane_id_, other->lane_id_);
  swap(heading_, other->heading_);
}

::google::protobuf::Metadata AvailableArea::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Base::InitAsDefaultInstance() {
}
class Base::HasBitSetters {
 public:
  static void set_has_id(Base* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Base::kIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Base::Base()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.Base)
}
Base::Base(const Base& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:vision.Base)
}

void Base::SharedCtor() {
  id_ = 0;
}

Base::~Base() {
  // @@protoc_insertion_point(destructor:vision.Base)
  SharedDtor();
}

void Base::SharedDtor() {
}

void Base::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Base& Base::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Base_vision_2eproto.base);
  return *internal_default_instance();
}


void Base::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.Base)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Base::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Base::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.Base)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.Base)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.Base)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Base::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.Base)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.Base)
}

::google::protobuf::uint8* Base::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.Base)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.Base)
  return target;
}

size_t Base::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.Base)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .vision.ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Base::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.Base)
  GOOGLE_DCHECK_NE(&from, this);
  const Base* source =
      ::google::protobuf::DynamicCastToGenerated<Base>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.Base)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.Base)
    MergeFrom(*source);
  }
}

void Base::MergeFrom(const Base& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.Base)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_id()) {
    set_id(from.id());
  }
}

void Base::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.Base)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Base::CopyFrom(const Base& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.Base)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Base::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Base::Swap(Base* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Base::InternalSwap(Base* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(id_, other->id_);
}

::google::protobuf::Metadata Base::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Crowd::InitAsDefaultInstance() {
}
class Crowd::HasBitSetters {
 public:
  static void set_has_id(Crowd* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Crowd::kIdFieldNumber;
const int Crowd::kPedestrianFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Crowd::Crowd()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.Crowd)
}
Crowd::Crowd(const Crowd& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      pedestrian_(from.pedestrian_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:vision.Crowd)
}

void Crowd::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Crowd_vision_2eproto.base);
  id_ = 0;
}

Crowd::~Crowd() {
  // @@protoc_insertion_point(destructor:vision.Crowd)
  SharedDtor();
}

void Crowd::SharedDtor() {
}

void Crowd::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Crowd& Crowd::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Crowd_vision_2eproto.base);
  return *internal_default_instance();
}


void Crowd::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.Crowd)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  pedestrian_.Clear();
  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Crowd::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // repeated .vision.Pedestrian pedestrian = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_pedestrian(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Crowd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.Crowd)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .vision.Pedestrian pedestrian = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_pedestrian()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.Crowd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.Crowd)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Crowd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.Crowd)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // repeated .vision.Pedestrian pedestrian = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->pedestrian_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->pedestrian(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.Crowd)
}

::google::protobuf::uint8* Crowd::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.Crowd)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // repeated .vision.Pedestrian pedestrian = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->pedestrian_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->pedestrian(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.Crowd)
  return target;
}

size_t Crowd::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.Crowd)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .vision.ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vision.Pedestrian pedestrian = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->pedestrian_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->pedestrian(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Crowd::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.Crowd)
  GOOGLE_DCHECK_NE(&from, this);
  const Crowd* source =
      ::google::protobuf::DynamicCastToGenerated<Crowd>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.Crowd)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.Crowd)
    MergeFrom(*source);
  }
}

void Crowd::MergeFrom(const Crowd& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.Crowd)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  pedestrian_.MergeFrom(from.pedestrian_);
  if (from.has_id()) {
    set_id(from.id());
  }
}

void Crowd::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.Crowd)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Crowd::CopyFrom(const Crowd& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.Crowd)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Crowd::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->pedestrian())) return false;
  return true;
}

void Crowd::Swap(Crowd* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Crowd::InternalSwap(Crowd* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&pedestrian_)->InternalSwap(CastToBase(&other->pedestrian_));
  swap(id_, other->id_);
}

::google::protobuf::Metadata Crowd::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Obstacles::InitAsDefaultInstance() {
}
class Obstacles::HasBitSetters {
 public:
  static void set_has_id(Obstacles* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Obstacles::kIdFieldNumber;
const int Obstacles::kArrayFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Obstacles::Obstacles()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.Obstacles)
}
Obstacles::Obstacles(const Obstacles& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      array_(from.array_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:vision.Obstacles)
}

void Obstacles::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Obstacles_vision_2eproto.base);
  id_ = 0;
}

Obstacles::~Obstacles() {
  // @@protoc_insertion_point(destructor:vision.Obstacles)
  SharedDtor();
}

void Obstacles::SharedDtor() {
}

void Obstacles::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Obstacles& Obstacles::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Obstacles_vision_2eproto.base);
  return *internal_default_instance();
}


void Obstacles::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.Obstacles)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  array_.Clear();
  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Obstacles::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // repeated .vision.Obstacle array = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_array(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Obstacles::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.Obstacles)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .vision.Obstacle array = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_array()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.Obstacles)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.Obstacles)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Obstacles::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.Obstacles)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // repeated .vision.Obstacle array = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->array_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->array(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.Obstacles)
}

::google::protobuf::uint8* Obstacles::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.Obstacles)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // repeated .vision.Obstacle array = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->array_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->array(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.Obstacles)
  return target;
}

size_t Obstacles::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.Obstacles)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .vision.ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vision.Obstacle array = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->array_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->array(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Obstacles::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.Obstacles)
  GOOGLE_DCHECK_NE(&from, this);
  const Obstacles* source =
      ::google::protobuf::DynamicCastToGenerated<Obstacles>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.Obstacles)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.Obstacles)
    MergeFrom(*source);
  }
}

void Obstacles::MergeFrom(const Obstacles& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.Obstacles)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  array_.MergeFrom(from.array_);
  if (from.has_id()) {
    set_id(from.id());
  }
}

void Obstacles::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.Obstacles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Obstacles::CopyFrom(const Obstacles& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.Obstacles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Obstacles::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->array())) return false;
  return true;
}

void Obstacles::Swap(Obstacles* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Obstacles::InternalSwap(Obstacles* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&array_)->InternalSwap(CastToBase(&other->array_));
  swap(id_, other->id_);
}

::google::protobuf::Metadata Obstacles::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void AvailableAreas::InitAsDefaultInstance() {
}
class AvailableAreas::HasBitSetters {
 public:
  static void set_has_id(AvailableAreas* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AvailableAreas::kIdFieldNumber;
const int AvailableAreas::kAreaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AvailableAreas::AvailableAreas()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.AvailableAreas)
}
AvailableAreas::AvailableAreas(const AvailableAreas& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      area_(from.area_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:vision.AvailableAreas)
}

void AvailableAreas::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_AvailableAreas_vision_2eproto.base);
  id_ = 0;
}

AvailableAreas::~AvailableAreas() {
  // @@protoc_insertion_point(destructor:vision.AvailableAreas)
  SharedDtor();
}

void AvailableAreas::SharedDtor() {
}

void AvailableAreas::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AvailableAreas& AvailableAreas::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_AvailableAreas_vision_2eproto.base);
  return *internal_default_instance();
}


void AvailableAreas::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.AvailableAreas)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  area_.Clear();
  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AvailableAreas::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // repeated .vision.AvailableArea area = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_area(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AvailableAreas::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.AvailableAreas)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .vision.AvailableArea area = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_area()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.AvailableAreas)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.AvailableAreas)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AvailableAreas::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.AvailableAreas)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // repeated .vision.AvailableArea area = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->area_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->area(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.AvailableAreas)
}

::google::protobuf::uint8* AvailableAreas::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.AvailableAreas)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // repeated .vision.AvailableArea area = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->area_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->area(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.AvailableAreas)
  return target;
}

size_t AvailableAreas::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.AvailableAreas)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .vision.ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vision.AvailableArea area = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->area_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->area(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AvailableAreas::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.AvailableAreas)
  GOOGLE_DCHECK_NE(&from, this);
  const AvailableAreas* source =
      ::google::protobuf::DynamicCastToGenerated<AvailableAreas>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.AvailableAreas)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.AvailableAreas)
    MergeFrom(*source);
  }
}

void AvailableAreas::MergeFrom(const AvailableAreas& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.AvailableAreas)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  area_.MergeFrom(from.area_);
  if (from.has_id()) {
    set_id(from.id());
  }
}

void AvailableAreas::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.AvailableAreas)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AvailableAreas::CopyFrom(const AvailableAreas& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.AvailableAreas)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvailableAreas::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->area())) return false;
  return true;
}

void AvailableAreas::Swap(AvailableAreas* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AvailableAreas::InternalSwap(AvailableAreas* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&area_)->InternalSwap(CastToBase(&other->area_));
  swap(id_, other->id_);
}

::google::protobuf::Metadata AvailableAreas::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void IllegalCarWarn::InitAsDefaultInstance() {
}
class IllegalCarWarn::HasBitSetters {
 public:
  static void set_has_id(IllegalCarWarn* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IllegalCarWarn::kIdFieldNumber;
const int IllegalCarWarn::kArrayFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IllegalCarWarn::IllegalCarWarn()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.IllegalCarWarn)
}
IllegalCarWarn::IllegalCarWarn(const IllegalCarWarn& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      array_(from.array_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:vision.IllegalCarWarn)
}

void IllegalCarWarn::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_IllegalCarWarn_vision_2eproto.base);
  id_ = 0;
}

IllegalCarWarn::~IllegalCarWarn() {
  // @@protoc_insertion_point(destructor:vision.IllegalCarWarn)
  SharedDtor();
}

void IllegalCarWarn::SharedDtor() {
}

void IllegalCarWarn::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IllegalCarWarn& IllegalCarWarn::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_IllegalCarWarn_vision_2eproto.base);
  return *internal_default_instance();
}


void IllegalCarWarn::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.IllegalCarWarn)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  array_.Clear();
  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* IllegalCarWarn::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // repeated .vision.AbnormalCar array = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_array(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool IllegalCarWarn::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.IllegalCarWarn)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .vision.AbnormalCar array = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_array()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.IllegalCarWarn)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.IllegalCarWarn)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void IllegalCarWarn::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.IllegalCarWarn)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // repeated .vision.AbnormalCar array = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->array_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->array(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.IllegalCarWarn)
}

::google::protobuf::uint8* IllegalCarWarn::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.IllegalCarWarn)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // repeated .vision.AbnormalCar array = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->array_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->array(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.IllegalCarWarn)
  return target;
}

size_t IllegalCarWarn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.IllegalCarWarn)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .vision.ID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vision.AbnormalCar array = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->array_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->array(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IllegalCarWarn::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.IllegalCarWarn)
  GOOGLE_DCHECK_NE(&from, this);
  const IllegalCarWarn* source =
      ::google::protobuf::DynamicCastToGenerated<IllegalCarWarn>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.IllegalCarWarn)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.IllegalCarWarn)
    MergeFrom(*source);
  }
}

void IllegalCarWarn::MergeFrom(const IllegalCarWarn& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.IllegalCarWarn)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  array_.MergeFrom(from.array_);
  if (from.has_id()) {
    set_id(from.id());
  }
}

void IllegalCarWarn::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.IllegalCarWarn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IllegalCarWarn::CopyFrom(const IllegalCarWarn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.IllegalCarWarn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IllegalCarWarn::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->array())) return false;
  return true;
}

void IllegalCarWarn::Swap(IllegalCarWarn* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IllegalCarWarn::InternalSwap(IllegalCarWarn* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&array_)->InternalSwap(CastToBase(&other->array_));
  swap(id_, other->id_);
}

::google::protobuf::Metadata IllegalCarWarn::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Visibility::InitAsDefaultInstance() {
}
class Visibility::HasBitSetters {
 public:
  static void set_has_id(Visibility* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_distance(Visibility* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_level(Visibility* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Visibility::kIdFieldNumber;
const int Visibility::kDistanceFieldNumber;
const int Visibility::kLevelFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Visibility::Visibility()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.Visibility)
}
Visibility::Visibility(const Visibility& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&distance_, &from.distance_,
    static_cast<size_t>(reinterpret_cast<char*>(&level_) -
    reinterpret_cast<char*>(&distance_)) + sizeof(level_));
  // @@protoc_insertion_point(copy_constructor:vision.Visibility)
}

void Visibility::SharedCtor() {
  ::memset(&distance_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&level_) -
      reinterpret_cast<char*>(&distance_)) + sizeof(level_));
}

Visibility::~Visibility() {
  // @@protoc_insertion_point(destructor:vision.Visibility)
  SharedDtor();
}

void Visibility::SharedDtor() {
}

void Visibility::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Visibility& Visibility::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Visibility_vision_2eproto.base);
  return *internal_default_instance();
}


void Visibility::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.Visibility)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&distance_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&level_) -
        reinterpret_cast<char*>(&distance_)) + sizeof(level_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Visibility::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // required double distance = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        set_distance(::google::protobuf::internal::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // required int32 level = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_level(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Visibility::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.Visibility)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required double distance = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          HasBitSetters::set_has_distance(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 level = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_level(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &level_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.Visibility)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.Visibility)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Visibility::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.Visibility)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // required double distance = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->distance(), output);
  }

  // required int32 level = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->level(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.Visibility)
}

::google::protobuf::uint8* Visibility::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.Visibility)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // required double distance = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->distance(), target);
  }

  // required int32 level = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->level(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.Visibility)
  return target;
}

size_t Visibility::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.Visibility)
  size_t total_size = 0;

  if (has_distance()) {
    // required double distance = 2;
    total_size += 1 + 8;
  }

  if (has_id()) {
    // required .vision.ID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }

  if (has_level()) {
    // required int32 level = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->level());
  }

  return total_size;
}
size_t Visibility::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.Visibility)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required double distance = 2;
    total_size += 1 + 8;

    // required .vision.ID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());

    // required int32 level = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->level());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Visibility::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.Visibility)
  GOOGLE_DCHECK_NE(&from, this);
  const Visibility* source =
      ::google::protobuf::DynamicCastToGenerated<Visibility>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.Visibility)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.Visibility)
    MergeFrom(*source);
  }
}

void Visibility::MergeFrom(const Visibility& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.Visibility)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      distance_ = from.distance_;
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      level_ = from.level_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Visibility::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.Visibility)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Visibility::CopyFrom(const Visibility& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.Visibility)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Visibility::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  return true;
}

void Visibility::Swap(Visibility* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Visibility::InternalSwap(Visibility* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(distance_, other->distance_);
  swap(id_, other->id_);
  swap(level_, other->level_);
}

::google::protobuf::Metadata Visibility::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// ===================================================================

void SmokeWarn::InitAsDefaultInstance() {
}
class SmokeWarn::HasBitSetters {
 public:
  static void set_has_id(SmokeWarn* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_warn(SmokeWarn* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SmokeWarn::kIdFieldNumber;
const int SmokeWarn::kWarnFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SmokeWarn::SmokeWarn()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vision.SmokeWarn)
}
SmokeWarn::SmokeWarn(const SmokeWarn& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&warn_) -
    reinterpret_cast<char*>(&id_)) + sizeof(warn_));
  // @@protoc_insertion_point(copy_constructor:vision.SmokeWarn)
}

void SmokeWarn::SharedCtor() {
  ::memset(&id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&warn_) -
      reinterpret_cast<char*>(&id_)) + sizeof(warn_));
}

SmokeWarn::~SmokeWarn() {
  // @@protoc_insertion_point(destructor:vision.SmokeWarn)
  SharedDtor();
}

void SmokeWarn::SharedDtor() {
}

void SmokeWarn::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SmokeWarn& SmokeWarn::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_SmokeWarn_vision_2eproto.base);
  return *internal_default_instance();
}


void SmokeWarn::Clear() {
// @@protoc_insertion_point(message_clear_start:vision.SmokeWarn)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&warn_) -
        reinterpret_cast<char*>(&id_)) + sizeof(warn_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SmokeWarn::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::vision::ID_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_id(static_cast<::vision::ID>(val));
        break;
      }
      // required bool warn = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        set_warn(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SmokeWarn::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vision.SmokeWarn)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vision.ID id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vision::ID_IsValid(value)) {
            set_id(static_cast< ::vision::ID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bool warn = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_warn(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &warn_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vision.SmokeWarn)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vision.SmokeWarn)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SmokeWarn::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vision.SmokeWarn)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // required bool warn = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->warn(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vision.SmokeWarn)
}

::google::protobuf::uint8* SmokeWarn::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vision.SmokeWarn)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .vision.ID id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // required bool warn = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->warn(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vision.SmokeWarn)
  return target;
}

size_t SmokeWarn::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:vision.SmokeWarn)
  size_t total_size = 0;

  if (has_id()) {
    // required .vision.ID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }

  if (has_warn()) {
    // required bool warn = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t SmokeWarn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vision.SmokeWarn)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .vision.ID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());

    // required bool warn = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SmokeWarn::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:vision.SmokeWarn)
  GOOGLE_DCHECK_NE(&from, this);
  const SmokeWarn* source =
      ::google::protobuf::DynamicCastToGenerated<SmokeWarn>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:vision.SmokeWarn)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:vision.SmokeWarn)
    MergeFrom(*source);
  }
}

void SmokeWarn::MergeFrom(const SmokeWarn& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vision.SmokeWarn)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      warn_ = from.warn_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SmokeWarn::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:vision.SmokeWarn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SmokeWarn::CopyFrom(const SmokeWarn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vision.SmokeWarn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SmokeWarn::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void SmokeWarn::Swap(SmokeWarn* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SmokeWarn::InternalSwap(SmokeWarn* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(id_, other->id_);
  swap(warn_, other->warn_);
}

::google::protobuf::Metadata SmokeWarn::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_vision_2eproto);
  return ::file_level_metadata_vision_2eproto[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace vision
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::vision::Pedestrian* Arena::CreateMaybeMessage< ::vision::Pedestrian >(Arena* arena) {
  return Arena::CreateInternal< ::vision::Pedestrian >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::Obstacle* Arena::CreateMaybeMessage< ::vision::Obstacle >(Arena* arena) {
  return Arena::CreateInternal< ::vision::Obstacle >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::AbnormalCar* Arena::CreateMaybeMessage< ::vision::AbnormalCar >(Arena* arena) {
  return Arena::CreateInternal< ::vision::AbnormalCar >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::AvailableArea* Arena::CreateMaybeMessage< ::vision::AvailableArea >(Arena* arena) {
  return Arena::CreateInternal< ::vision::AvailableArea >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::Base* Arena::CreateMaybeMessage< ::vision::Base >(Arena* arena) {
  return Arena::CreateInternal< ::vision::Base >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::Crowd* Arena::CreateMaybeMessage< ::vision::Crowd >(Arena* arena) {
  return Arena::CreateInternal< ::vision::Crowd >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::Obstacles* Arena::CreateMaybeMessage< ::vision::Obstacles >(Arena* arena) {
  return Arena::CreateInternal< ::vision::Obstacles >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::AvailableAreas* Arena::CreateMaybeMessage< ::vision::AvailableAreas >(Arena* arena) {
  return Arena::CreateInternal< ::vision::AvailableAreas >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::IllegalCarWarn* Arena::CreateMaybeMessage< ::vision::IllegalCarWarn >(Arena* arena) {
  return Arena::CreateInternal< ::vision::IllegalCarWarn >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::Visibility* Arena::CreateMaybeMessage< ::vision::Visibility >(Arena* arena) {
  return Arena::CreateInternal< ::vision::Visibility >(arena);
}
template<> PROTOBUF_NOINLINE ::vision::SmokeWarn* Arena::CreateMaybeMessage< ::vision::SmokeWarn >(Arena* arena) {
  return Arena::CreateInternal< ::vision::SmokeWarn >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
