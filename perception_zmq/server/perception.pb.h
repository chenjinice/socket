// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perception.proto

#ifndef PROTOBUF_INCLUDED_perception_2eproto
#define PROTOBUF_INCLUDED_perception_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3006001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_perception_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_perception_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_perception_2eproto();
namespace perception {
class Flow;
class FlowDefaultTypeInternal;
extern FlowDefaultTypeInternal _Flow_default_instance_;
class FlowMsg;
class FlowMsgDefaultTypeInternal;
extern FlowMsgDefaultTypeInternal _FlowMsg_default_instance_;
class Jam;
class JamDefaultTypeInternal;
extern JamDefaultTypeInternal _Jam_default_instance_;
class JamMsg;
class JamMsgDefaultTypeInternal;
extern JamMsgDefaultTypeInternal _JamMsg_default_instance_;
class LaneArea;
class LaneAreaDefaultTypeInternal;
extern LaneAreaDefaultTypeInternal _LaneArea_default_instance_;
class LaneAreaMsg;
class LaneAreaMsgDefaultTypeInternal;
extern LaneAreaMsgDefaultTypeInternal _LaneAreaMsg_default_instance_;
class LaneInfoEx;
class LaneInfoExDefaultTypeInternal;
extern LaneInfoExDefaultTypeInternal _LaneInfoEx_default_instance_;
class PerceptionMsg;
class PerceptionMsgDefaultTypeInternal;
extern PerceptionMsgDefaultTypeInternal _PerceptionMsg_default_instance_;
class Position;
class PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class Size;
class SizeDefaultTypeInternal;
extern SizeDefaultTypeInternal _Size_default_instance_;
class Target;
class TargetDefaultTypeInternal;
extern TargetDefaultTypeInternal _Target_default_instance_;
class TargetMsg;
class TargetMsgDefaultTypeInternal;
extern TargetMsgDefaultTypeInternal _TargetMsg_default_instance_;
class Timestamp;
class TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
class VisibilityMsg;
class VisibilityMsgDefaultTypeInternal;
extern VisibilityMsgDefaultTypeInternal _VisibilityMsg_default_instance_;
class WarnMsg;
class WarnMsgDefaultTypeInternal;
extern WarnMsgDefaultTypeInternal _WarnMsg_default_instance_;
}  // namespace perception
namespace google {
namespace protobuf {
template<> ::perception::Flow* Arena::CreateMaybeMessage<::perception::Flow>(Arena*);
template<> ::perception::FlowMsg* Arena::CreateMaybeMessage<::perception::FlowMsg>(Arena*);
template<> ::perception::Jam* Arena::CreateMaybeMessage<::perception::Jam>(Arena*);
template<> ::perception::JamMsg* Arena::CreateMaybeMessage<::perception::JamMsg>(Arena*);
template<> ::perception::LaneArea* Arena::CreateMaybeMessage<::perception::LaneArea>(Arena*);
template<> ::perception::LaneAreaMsg* Arena::CreateMaybeMessage<::perception::LaneAreaMsg>(Arena*);
template<> ::perception::LaneInfoEx* Arena::CreateMaybeMessage<::perception::LaneInfoEx>(Arena*);
template<> ::perception::PerceptionMsg* Arena::CreateMaybeMessage<::perception::PerceptionMsg>(Arena*);
template<> ::perception::Position* Arena::CreateMaybeMessage<::perception::Position>(Arena*);
template<> ::perception::Size* Arena::CreateMaybeMessage<::perception::Size>(Arena*);
template<> ::perception::Target* Arena::CreateMaybeMessage<::perception::Target>(Arena*);
template<> ::perception::TargetMsg* Arena::CreateMaybeMessage<::perception::TargetMsg>(Arena*);
template<> ::perception::Timestamp* Arena::CreateMaybeMessage<::perception::Timestamp>(Arena*);
template<> ::perception::VisibilityMsg* Arena::CreateMaybeMessage<::perception::VisibilityMsg>(Arena*);
template<> ::perception::WarnMsg* Arena::CreateMaybeMessage<::perception::WarnMsg>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace perception {

enum Flow_TrafficSig {
  Flow_TrafficSig_UNKNOWN = 0,
  Flow_TrafficSig_Y2G = 1,
  Flow_TrafficSig_OVER = 2
};
bool Flow_TrafficSig_IsValid(int value);
constexpr Flow_TrafficSig Flow_TrafficSig_TrafficSig_MIN = Flow_TrafficSig_UNKNOWN;
constexpr Flow_TrafficSig Flow_TrafficSig_TrafficSig_MAX = Flow_TrafficSig_OVER;
constexpr int Flow_TrafficSig_TrafficSig_ARRAYSIZE = Flow_TrafficSig_TrafficSig_MAX + 1;

const ::google::protobuf::EnumDescriptor* Flow_TrafficSig_descriptor();
inline const ::std::string& Flow_TrafficSig_Name(Flow_TrafficSig value) {
  return ::google::protobuf::internal::NameOfEnum(
    Flow_TrafficSig_descriptor(), value);
}
inline bool Flow_TrafficSig_Parse(
    const ::std::string& name, Flow_TrafficSig* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Flow_TrafficSig>(
    Flow_TrafficSig_descriptor(), name, value);
}
enum Version {
  VERSION = 20200602
};
bool Version_IsValid(int value);
constexpr Version Version_MIN = VERSION;
constexpr Version Version_MAX = VERSION;
constexpr int Version_ARRAYSIZE = Version_MAX + 1;

const ::google::protobuf::EnumDescriptor* Version_descriptor();
inline const ::std::string& Version_Name(Version value) {
  return ::google::protobuf::internal::NameOfEnum(
    Version_descriptor(), value);
}
inline bool Version_Parse(
    const ::std::string& name, Version* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Version>(
    Version_descriptor(), name, value);
}
enum EventId {
  EVENT_NONE = 0,
  PEDESTRIAN = 1,
  ILLEGAL_V1 = 2,
  VISIBILITY = 3,
  AVAILABLE_AREA = 4,
  ABNORMAL_CAR = 5,
  ILLEGAL_V2 = 6,
  TRAFFIC_STATUS = 7,
  BACKWARD_DRIVING = 8,
  ROAD_DANGER = 9,
  FIRE_SMOKE = 10,
  TARGET_TO_FUSION = 11,
  TRAFFIC_JAM = 12,
  TRAFFIC_FLOW = 13,
  SPECIALCAR = 14,
  ACCIDENT = 15,
  ICEWARN = 16,
  LANE_WARE = 17,
  SPEEDING = 18,
  SNAP = 19
};
bool EventId_IsValid(int value);
constexpr EventId EventId_MIN = EVENT_NONE;
constexpr EventId EventId_MAX = SNAP;
constexpr int EventId_ARRAYSIZE = EventId_MAX + 1;

const ::google::protobuf::EnumDescriptor* EventId_descriptor();
inline const ::std::string& EventId_Name(EventId value) {
  return ::google::protobuf::internal::NameOfEnum(
    EventId_descriptor(), value);
}
inline bool EventId_Parse(
    const ::std::string& name, EventId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EventId>(
    EventId_descriptor(), name, value);
}
enum Source {
  None = 0,
  RADAR = 1,
  VISION = 2,
  LIDAR = 3,
  V2X = 4
};
bool Source_IsValid(int value);
constexpr Source Source_MIN = None;
constexpr Source Source_MAX = V2X;
constexpr int Source_ARRAYSIZE = Source_MAX + 1;

const ::google::protobuf::EnumDescriptor* Source_descriptor();
inline const ::std::string& Source_Name(Source value) {
  return ::google::protobuf::internal::NameOfEnum(
    Source_descriptor(), value);
}
inline bool Source_Parse(
    const ::std::string& name, Source* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Source>(
    Source_descriptor(), name, value);
}
enum TargetType {
  OTHERS = 0,
  HUMAN = 1,
  VEHICLE = 2,
  MOTORCYCLE = 3,
  ANIMAL = 4,
  OBSTACLE = 5
};
bool TargetType_IsValid(int value);
constexpr TargetType TargetType_MIN = OTHERS;
constexpr TargetType TargetType_MAX = OBSTACLE;
constexpr int TargetType_ARRAYSIZE = TargetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TargetType_descriptor();
inline const ::std::string& TargetType_Name(TargetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TargetType_descriptor(), value);
}
inline bool TargetType_Parse(
    const ::std::string& name, TargetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TargetType>(
    TargetType_descriptor(), name, value);
}
enum CarType {
  NORMAL = 0,
  AMBULANCE = 1,
  DANGERCAR = 2,
  FIREENGINE = 3,
  POLICECAR = 4
};
bool CarType_IsValid(int value);
constexpr CarType CarType_MIN = NORMAL;
constexpr CarType CarType_MAX = POLICECAR;
constexpr int CarType_ARRAYSIZE = CarType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CarType_descriptor();
inline const ::std::string& CarType_Name(CarType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CarType_descriptor(), value);
}
inline bool CarType_Parse(
    const ::std::string& name, CarType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CarType>(
    CarType_descriptor(), name, value);
}
enum CarStatus {
  STATUS_NORMAL = 0,
  RETROGRADE = 1,
  OVER_SPEEDING = 2,
  LOW_SPEEDING = 3,
  ILLEGAL_PARKING = 4,
  LANE_PARKING = 5,
  AREA_PARKING = 6,
  CONTINUOUS_DIVERSION = 7,
  LINE_PRESSING = 8
};
bool CarStatus_IsValid(int value);
constexpr CarStatus CarStatus_MIN = STATUS_NORMAL;
constexpr CarStatus CarStatus_MAX = LINE_PRESSING;
constexpr int CarStatus_ARRAYSIZE = CarStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* CarStatus_descriptor();
inline const ::std::string& CarStatus_Name(CarStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    CarStatus_descriptor(), value);
}
inline bool CarStatus_Parse(
    const ::std::string& name, CarStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CarStatus>(
    CarStatus_descriptor(), name, value);
}
enum WareType {
  WARE_NONE = 0,
  FULLLINE = 1,
  DOTTEDLINE = 2,
  DOUBLEYELLOWLINE = 3
};
bool WareType_IsValid(int value);
constexpr WareType WareType_MIN = WARE_NONE;
constexpr WareType WareType_MAX = DOUBLEYELLOWLINE;
constexpr int WareType_ARRAYSIZE = WareType_MAX + 1;

const ::google::protobuf::EnumDescriptor* WareType_descriptor();
inline const ::std::string& WareType_Name(WareType value) {
  return ::google::protobuf::internal::NameOfEnum(
    WareType_descriptor(), value);
}
inline bool WareType_Parse(
    const ::std::string& name, WareType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WareType>(
    WareType_descriptor(), name, value);
}
// ===================================================================

class Position final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:perception.Position) */ {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(Position&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Position& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Position* other);
  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Position* New() const final {
    return CreateMaybeMessage<Position>(nullptr);
  }

  Position* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::google::protobuf::StringPiece FullMessageName() {
    return "perception.Position";
  }
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 lon = 1;
  bool has_lon() const;
  void clear_lon();
  static const int kLonFieldNumber = 1;
  ::google::protobuf::int32 lon() const;
  void set_lon(::google::protobuf::int32 value);

  // required int32 lat = 2;
  bool has_lat() const;
  void clear_lat();
  static const int kLatFieldNumber = 2;
  ::google::protobuf::int32 lat() const;
  void set_lat(::google::protobuf::int32 value);

  // optional float elevation = 3;
  bool has_elevation() const;
  void clear_elevation();
  static const int kElevationFieldNumber = 3;
  float elevation() const;
  void set_elevation(float value);

  // @@protoc_insertion_point(class_scope:perception.Position)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 lon_;
  ::google::protobuf::int32 lat_;
  float elevation_;
  friend struct ::TableStruct_perception_2eproto;
};
// -------------------------------------------------------------------

class Timestamp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:perception.Timestamp) */ {
 public:
  Timestamp();
  virtual ~Timestamp();

  Timestamp(const Timestamp& from);

  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Timestamp(Timestamp&& from) noexcept
    : Timestamp() {
    *this = ::std::move(from);
  }

  inline Timestamp& operator=(Timestamp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Timestamp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Timestamp* internal_default_instance() {
    return reinterpret_cast<const Timestamp*>(
               &_Timestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Timestamp* other);
  friend void swap(Timestamp& a, Timestamp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Timestamp* New() const final {
    return CreateMaybeMessage<Timestamp>(nullptr);
  }

  Timestamp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Timestamp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Timestamp& from);
  void MergeFrom(const Timestamp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Timestamp* other);
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::google::protobuf::StringPiece FullMessageName() {
    return "perception.Timestamp";
  }
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 seconds = 1;
  bool has_seconds() const;
  void clear_seconds();
  static const int kSecondsFieldNumber = 1;
  ::google::protobuf::int64 seconds() const;
  void set_seconds(::google::protobuf::int64 value);

  // required int32 nanos = 2;
  bool has_nanos() const;
  void clear_nanos();
  static const int kNanosFieldNumber = 2;
  ::google::protobuf::int32 nanos() const;
  void set_nanos(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:perception.Timestamp)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 seconds_;
  ::google::protobuf::int32 nanos_;
  friend struct ::TableStruct_perception_2eproto;
};
// -------------------------------------------------------------------

class Size final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:perception.Size) */ {
 public:
  Size();
  virtual ~Size();

  Size(const Size& from);

  inline Size& operator=(const Size& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Size(Size&& from) noexcept
    : Size() {
    *this = ::std::move(from);
  }

  inline Size& operator=(Size&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Size& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Size* internal_default_instance() {
    return reinterpret_cast<const Size*>(
               &_Size_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Size* other);
  friend void swap(Size& a, Size& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Size* New() const final {
    return CreateMaybeMessage<Size>(nullptr);
  }

  Size* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Size>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Size& from);
  void MergeFrom(const Size& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Size* other);
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::google::protobuf::StringPiece FullMessageName() {
    return "perception.Size";
  }
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float length = 1;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 1;
  float length() const;
  void set_length(float value);

  // required float width = 2;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 2;
  float width() const;
  void set_width(float value);

  // required float height = 3;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  float height() const;
  void set_height(float value);

  // @@protoc_insertion_point(class_scope:perception.Size)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float length_;
  float width_;
  float height_;
  friend struct ::TableStruct_perception_2eproto;
};
// -------------------------------------------------------------------

class LaneInfoEx final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:perception.LaneInfoEx) */ {
 public:
  LaneInfoEx();
  virtual ~LaneInfoEx();

  LaneInfoEx(const LaneInfoEx& from);

  inline LaneInfoEx& operator=(const LaneInfoEx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneInfoEx(LaneInfoEx&& from) noexcept
    : LaneInfoEx() {
    *this = ::std::move(from);
  }

  inline LaneInfoEx& operator=(LaneInfoEx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LaneInfoEx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneInfoEx* internal_default_instance() {
    return reinterpret_cast<const LaneInfoEx*>(
               &_LaneInfoEx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(LaneInfoEx* other);
  friend void swap(LaneInfoEx& a, LaneInfoEx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneInfoEx* New() const final {
    return CreateMaybeMessage<LaneInfoEx>(nullptr);
  }

  LaneInfoEx* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneInfoEx>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneInfoEx& from);
  void MergeFrom(const LaneInfoEx& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneInfoEx* other);
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::google::protobuf::StringPiece FullMessageName() {
    return "perception.LaneInfoEx";
  }
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 lane_info = 1;
  bool has_lane_info() const;
  void clear_lane_info();
  static const int kLaneInfoFieldNumber = 1;
  ::google::protobuf::int32 lane_info() const;
  void set_lane_info(::google::protobuf::int32 value);

  // required int32 lane_id = 2;
  bool has_lane_id() const;
  void clear_lane_id();
  static const int kLaneIdFieldNumber = 2;
  ::google::protobuf::int32 lane_id() const;
  void set_lane_id(::google::protobuf::int32 value);

  // required int32 lane_count = 3;
  bool has_lane_count() const;
  void clear_lane_count();
  static const int kLaneCountFieldNumber = 3;
  ::google::protobuf::int32 lane_count() const;
  void set_lane_count(::google::protobuf::int32 value);

  // required float lane_heading = 4;
  bool has_lane_heading() const;
  void clear_lane_heading();
  static const int kLaneHeadingFieldNumber = 4;
  float lane_heading() const;
  void set_lane_heading(float value);

  // @@protoc_insertion_point(class_scope:perception.LaneInfoEx)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 lane_info_;
  ::google::protobuf::int32 lane_id_;
  ::google::protobuf::int32 lane_count_;
  float lane_heading_;
  friend struct ::TableStruct_perception_2eproto;
};
// -------------------------------------------------------------------

class LaneArea final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:perception.LaneArea) */ {
 public:
  LaneArea();
  virtual ~LaneArea();

  LaneArea(const LaneArea& from);

  inline LaneArea& operator=(const LaneArea& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneArea(LaneArea&& from) noexcept
    : LaneArea() {
    *this = ::std::move(from);
  }

  inline LaneArea& operator=(LaneArea&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LaneArea& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneArea* internal_default_instance() {
    return reinterpret_cast<const LaneArea*>(
               &_LaneArea_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(LaneArea* other);
  friend void swap(LaneArea& a, LaneArea& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneArea* New() const final {
    return CreateMaybeMessage<LaneArea>(nullptr);
  }

  LaneArea* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneArea>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneArea& from);
  void MergeFrom(const LaneArea& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneArea* other);
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::google::protobuf::StringPiece FullMessageName() {
    return "perception.LaneArea";
  }
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .perception.Position pos = 1;
  int pos_size() const;
  void clear_pos();
  static const int kPosFieldNumber = 1;
  ::perception::Position* mutable_pos(int index);
  ::google::protobuf::RepeatedPtrField< ::perception::Position >*
      mutable_pos();
  const ::perception::Position& pos(int index) const;
  ::perception::Position* add_pos();
  const ::google::protobuf::RepeatedPtrField< ::perception::Position >&
      pos() const;

  // optional int32 camera = 2;
  bool has_camera() const;
  void clear_camera();
  static const int kCameraFieldNumber = 2;
  ::google::protobuf::int32 camera() const;
  void set_camera(::google::protobuf::int32 value);

  // optional int32 lane_id = 3;
  bool has_lane_id() const;
  void clear_lane_id();
  static const int kLaneIdFieldNumber = 3;
  ::google::protobuf::int32 lane_id() const;
  void set_lane_id(::google::protobuf::int32 value);

  // optional float lane_heading = 4;
  bool has_lane_heading() const;
  void clear_lane_heading();
  static const int kLaneHeadingFieldNumber = 4;
  float lane_heading() const;
  void set_lane_heading(float value);

  // optional .perception.WareType ware = 5;
  bool has_ware() const;
  void clear_ware();
  static const int kWareFieldNumber = 5;
  ::perception::WareType ware() const;
  void set_ware(::perception::WareType value);

  // @@protoc_insertion_point(class_scope:perception.LaneArea)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perception::Position > pos_;
  ::google::protobuf::int32 camera_;
  ::google::protobuf::int32 lane_id_;
  float lane_heading_;
  int ware_;
  friend struct ::TableStruct_perception_2eproto;
};
// -------------------------------------------------------------------

class Jam final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:perception.Jam) */ {
 public:
  Jam();
  virtual ~Jam();

  Jam(const Jam& from);

  inline Jam& operator=(const Jam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Jam(Jam&& from) noexcept
    : Jam() {
    *this = ::std::move(from);
  }

  inline Jam& operator=(Jam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Jam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Jam* internal_default_instance() {
    return reinterpret_cast<const Jam*>(
               &_Jam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Jam* other);
  friend void swap(Jam& a, Jam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Jam* New() const final {
    return CreateMaybeMessage<Jam>(nullptr);
  }

  Jam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Jam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Jam& from);
  void MergeFrom(const Jam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Jam* other);
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::google::protobuf::StringPiece FullMessageName() {
    return "perception.Jam";
  }
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 vehicle_flow = 4;
  int vehicle_flow_size() const;
  void clear_vehicle_flow();
  static const int kVehicleFlowFieldNumber = 4;
  ::google::protobuf::int32 vehicle_flow(int index) const;
  void set_vehicle_flow(int index, ::google::protobuf::int32 value);
  void add_vehicle_flow(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      vehicle_flow() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_vehicle_flow();

  // required uint32 vehicle_num = 1;
  bool has_vehicle_num() const;
  void clear_vehicle_num();
  static const int kVehicleNumFieldNumber = 1;
  ::google::protobuf::uint32 vehicle_num() const;
  void set_vehicle_num(::google::protobuf::uint32 value);

  // required float vehicle_velocity = 2;
  bool has_vehicle_velocity() const;
  void clear_vehicle_velocity();
  static const int kVehicleVelocityFieldNumber = 2;
  float vehicle_velocity() const;
  void set_vehicle_velocity(float value);

  // required float lane_heading = 3;
  bool has_lane_heading() const;
  void clear_lane_heading();
  static const int kLaneHeadingFieldNumber = 3;
  float lane_heading() const;
  void set_lane_heading(float value);

  // optional int32 lane_id = 5;
  bool has_lane_id() const;
  void clear_lane_id();
  static const int kLaneIdFieldNumber = 5;
  ::google::protobuf::int32 lane_id() const;
  void set_lane_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:perception.Jam)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > vehicle_flow_;
  ::google::protobuf::uint32 vehicle_num_;
  float vehicle_velocity_;
  float lane_heading_;
  ::google::protobuf::int32 lane_id_;
  friend struct ::TableStruct_perception_2eproto;
};
// -------------------------------------------------------------------

class Flow final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:perception.Flow) */ {
 public:
  Flow();
  virtual ~Flow();

  Flow(const Flow& from);

  inline Flow& operator=(const Flow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Flow(Flow&& from) noexcept
    : Flow() {
    *this = ::std::move(from);
  }

  inline Flow& operator=(Flow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Flow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Flow* internal_default_instance() {
    return reinterpret_cast<const Flow*>(
               &_Flow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Flow* other);
  friend void swap(Flow& a, Flow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Flow* New() const final {
    return CreateMaybeMessage<Flow>(nullptr);
  }

  Flow* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Flow>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Flow& from);
  void MergeFrom(const Flow& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Flow* other);
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::google::protobuf::StringPiece FullMessageName() {
    return "perception.Flow";
  }
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Flow_TrafficSig TrafficSig;
  static constexpr TrafficSig UNKNOWN =
    Flow_TrafficSig_UNKNOWN;
  static constexpr TrafficSig Y2G =
    Flow_TrafficSig_Y2G;
  static constexpr TrafficSig OVER =
    Flow_TrafficSig_OVER;
  static inline bool TrafficSig_IsValid(int value) {
    return Flow_TrafficSig_IsValid(value);
  }
  static constexpr TrafficSig TrafficSig_MIN =
    Flow_TrafficSig_TrafficSig_MIN;
  static constexpr TrafficSig TrafficSig_MAX =
    Flow_TrafficSig_TrafficSig_MAX;
  static constexpr int TrafficSig_ARRAYSIZE =
    Flow_TrafficSig_TrafficSig_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TrafficSig_descriptor() {
    return Flow_TrafficSig_descriptor();
  }
  static inline const ::std::string& TrafficSig_Name(TrafficSig value) {
    return Flow_TrafficSig_Name(value);
  }
  static inline bool TrafficSig_Parse(const ::std::string& name,
      TrafficSig* value) {
    return Flow_TrafficSig_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated int32 vehicle_num = 2;
  int vehicle_num_size() const;
  void clear_vehicle_num();
  static const int kVehicleNumFieldNumber = 2;
  ::google::protobuf::int32 vehicle_num(int index) const;
  void set_vehicle_num(int index, ::google::protobuf::int32 value);
  void add_vehicle_num(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      vehicle_num() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_vehicle_num();

  // repeated int32 pass_num = 3;
  int pass_num_size() const;
  void clear_pass_num();
  static const int kPassNumFieldNumber = 3;
  ::google::protobuf::int32 pass_num(int index) const;
  void set_pass_num(int index, ::google::protobuf::int32 value);
  void add_pass_num(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      pass_num() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_pass_num();

  // optional int32 camera = 1;
  bool has_camera() const;
  void clear_camera();
  static const int kCameraFieldNumber = 1;
  ::google::protobuf::int32 camera() const;
  void set_camera(::google::protobuf::int32 value);

  // optional .perception.Flow.TrafficSig signal = 4;
  bool has_signal() const;
  void clear_signal();
  static const int kSignalFieldNumber = 4;
  ::perception::Flow_TrafficSig signal() const;
  void set_signal(::perception::Flow_TrafficSig value);

  // @@protoc_insertion_point(class_scope:perception.Flow)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > vehicle_num_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > pass_num_;
  ::google::protobuf::int32 camera_;
  int signal_;
  friend struct ::TableStruct_perception_2eproto;
};
// -------------------------------------------------------------------

class Target final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:perception.Target) */ {
 public:
  Target();
  virtual ~Target();

  Target(const Target& from);

  inline Target& operator=(const Target& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Target(Target&& from) noexcept
    : Target() {
    *this = ::std::move(from);
  }

  inline Target& operator=(Target&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Target& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Target* internal_default_instance() {
    return reinterpret_cast<const Target*>(
               &_Target_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Target* other);
  friend void swap(Target& a, Target& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Target* New() const final {
    return CreateMaybeMessage<Target>(nullptr);
  }

  Target* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Target>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Target& from);
  void MergeFrom(const Target& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Target* other);
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::google::protobuf::StringPiece FullMessageName() {
    return "perception.Target";
  }
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string license_plate = 17;
  bool has_license_plate() const;
  void clear_license_plate();
  static const int kLicensePlateFieldNumber = 17;
  const ::std::string& license_plate() const;
  void set_license_plate(const ::std::string& value);
  #if LANG_CXX11
  void set_license_plate(::std::string&& value);
  #endif
  void set_license_plate(const char* value);
  void set_license_plate(const char* value, size_t size);
  ::std::string* mutable_license_plate();
  ::std::string* release_license_plate();
  void set_allocated_license_plate(::std::string* license_plate);

  // required .perception.Position pos = 3;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 3;
  const ::perception::Position& pos() const;
  ::perception::Position* release_pos();
  ::perception::Position* mutable_pos();
  void set_allocated_pos(::perception::Position* pos);

  // optional .perception.Size size = 8;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 8;
  const ::perception::Size& size() const;
  ::perception::Size* release_size();
  ::perception::Size* mutable_size();
  void set_allocated_size(::perception::Size* size);

  // optional .perception.LaneInfoEx lane_ex = 16;
  bool has_lane_ex() const;
  void clear_lane_ex();
  static const int kLaneExFieldNumber = 16;
  const ::perception::LaneInfoEx& lane_ex() const;
  ::perception::LaneInfoEx* release_lane_ex();
  ::perception::LaneInfoEx* mutable_lane_ex();
  void set_allocated_lane_ex(::perception::LaneInfoEx* lane_ex);

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required .perception.TargetType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::perception::TargetType type() const;
  void set_type(::perception::TargetType value);

  // optional int32 camera = 4;
  bool has_camera() const;
  void clear_camera();
  static const int kCameraFieldNumber = 4;
  ::google::protobuf::int32 camera() const;
  void set_camera(::google::protobuf::int32 value);

  // optional float velocity = 5;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 5;
  float velocity() const;
  void set_velocity(float value);

  // optional float heading = 6;
  bool has_heading() const;
  void clear_heading();
  static const int kHeadingFieldNumber = 6;
  float heading() const;
  void set_heading(float value);

  // optional float distance = 7;
  bool has_distance() const;
  void clear_distance();
  static const int kDistanceFieldNumber = 7;
  float distance() const;
  void set_distance(float value);

  // optional int32 approach_judge = 9;
  bool has_approach_judge() const;
  void clear_approach_judge();
  static const int kApproachJudgeFieldNumber = 9;
  ::google::protobuf::int32 approach_judge() const;
  void set_approach_judge(::google::protobuf::int32 value);

  // optional .perception.Source source = 10;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 10;
  ::perception::Source source() const;
  void set_source(::perception::Source value);

  // optional int32 capture_id = 11;
  bool has_capture_id() const;
  void clear_capture_id();
  static const int kCaptureIdFieldNumber = 11;
  ::google::protobuf::int32 capture_id() const;
  void set_capture_id(::google::protobuf::int32 value);

  // optional bool in_lane = 12;
  bool has_in_lane() const;
  void clear_in_lane();
  static const int kInLaneFieldNumber = 12;
  bool in_lane() const;
  void set_in_lane(bool value);

  // optional int32 lane_id = 13;
  bool has_lane_id() const;
  void clear_lane_id();
  static const int kLaneIdFieldNumber = 13;
  ::google::protobuf::int32 lane_id() const;
  void set_lane_id(::google::protobuf::int32 value);

  // optional float lane_heading = 14;
  bool has_lane_heading() const;
  void clear_lane_heading();
  static const int kLaneHeadingFieldNumber = 14;
  float lane_heading() const;
  void set_lane_heading(float value);

  // optional int32 lane_type = 15;
  bool has_lane_type() const;
  void clear_lane_type();
  static const int kLaneTypeFieldNumber = 15;
  ::google::protobuf::int32 lane_type() const;
  void set_lane_type(::google::protobuf::int32 value);

  // optional .perception.CarType car_type = 18;
  bool has_car_type() const;
  void clear_car_type();
  static const int kCarTypeFieldNumber = 18;
  ::perception::CarType car_type() const;
  void set_car_type(::perception::CarType value);

  // optional .perception.CarStatus car_status = 19;
  bool has_car_status() const;
  void clear_car_status();
  static const int kCarStatusFieldNumber = 19;
  ::perception::CarStatus car_status() const;
  void set_car_status(::perception::CarStatus value);

  // optional float confidence = 20;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 20;
  float confidence() const;
  void set_confidence(float value);

  // optional float rcs = 21;
  bool has_rcs() const;
  void clear_rcs();
  static const int kRcsFieldNumber = 21;
  float rcs() const;
  void set_rcs(float value);

  // @@protoc_insertion_point(class_scope:perception.Target)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr license_plate_;
  ::perception::Position* pos_;
  ::perception::Size* size_;
  ::perception::LaneInfoEx* lane_ex_;
  ::google::protobuf::int32 id_;
  int type_;
  ::google::protobuf::int32 camera_;
  float velocity_;
  float heading_;
  float distance_;
  ::google::protobuf::int32 approach_judge_;
  int source_;
  ::google::protobuf::int32 capture_id_;
  bool in_lane_;
  ::google::protobuf::int32 lane_id_;
  float lane_heading_;
  ::google::protobuf::int32 lane_type_;
  int car_type_;
  int car_status_;
  float confidence_;
  float rcs_;
  friend struct ::TableStruct_perception_2eproto;
};
// -------------------------------------------------------------------

class VisibilityMsg final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:perception.VisibilityMsg) */ {
 public:
  VisibilityMsg();
  virtual ~VisibilityMsg();

  VisibilityMsg(const VisibilityMsg& from);

  inline VisibilityMsg& operator=(const VisibilityMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VisibilityMsg(VisibilityMsg&& from) noexcept
    : VisibilityMsg() {
    *this = ::std::move(from);
  }

  inline VisibilityMsg& operator=(VisibilityMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const VisibilityMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VisibilityMsg* internal_default_instance() {
    return reinterpret_cast<const VisibilityMsg*>(
               &_VisibilityMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(VisibilityMsg* other);
  friend void swap(VisibilityMsg& a, VisibilityMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VisibilityMsg* New() const final {
    return CreateMaybeMessage<VisibilityMsg>(nullptr);
  }

  VisibilityMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VisibilityMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VisibilityMsg& from);
  void MergeFrom(const VisibilityMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisibilityMsg* other);
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::google::protobuf::StringPiece FullMessageName() {
    return "perception.VisibilityMsg";
  }
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float distance = 2;
  bool has_distance() const;
  void clear_distance();
  static const int kDistanceFieldNumber = 2;
  float distance() const;
  void set_distance(float value);

  // required int32 level = 3;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 3;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:perception.VisibilityMsg)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float distance_;
  ::google::protobuf::int32 level_;
  friend struct ::TableStruct_perception_2eproto;
};
// -------------------------------------------------------------------

class LaneAreaMsg final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:perception.LaneAreaMsg) */ {
 public:
  LaneAreaMsg();
  virtual ~LaneAreaMsg();

  LaneAreaMsg(const LaneAreaMsg& from);

  inline LaneAreaMsg& operator=(const LaneAreaMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneAreaMsg(LaneAreaMsg&& from) noexcept
    : LaneAreaMsg() {
    *this = ::std::move(from);
  }

  inline LaneAreaMsg& operator=(LaneAreaMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LaneAreaMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneAreaMsg* internal_default_instance() {
    return reinterpret_cast<const LaneAreaMsg*>(
               &_LaneAreaMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(LaneAreaMsg* other);
  friend void swap(LaneAreaMsg& a, LaneAreaMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneAreaMsg* New() const final {
    return CreateMaybeMessage<LaneAreaMsg>(nullptr);
  }

  LaneAreaMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneAreaMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneAreaMsg& from);
  void MergeFrom(const LaneAreaMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneAreaMsg* other);
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::google::protobuf::StringPiece FullMessageName() {
    return "perception.LaneAreaMsg";
  }
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .perception.LaneArea area = 1;
  int area_size() const;
  void clear_area();
  static const int kAreaFieldNumber = 1;
  ::perception::LaneArea* mutable_area(int index);
  ::google::protobuf::RepeatedPtrField< ::perception::LaneArea >*
      mutable_area();
  const ::perception::LaneArea& area(int index) const;
  ::perception::LaneArea* add_area();
  const ::google::protobuf::RepeatedPtrField< ::perception::LaneArea >&
      area() const;

  // @@protoc_insertion_point(class_scope:perception.LaneAreaMsg)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perception::LaneArea > area_;
  friend struct ::TableStruct_perception_2eproto;
};
// -------------------------------------------------------------------

class JamMsg final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:perception.JamMsg) */ {
 public:
  JamMsg();
  virtual ~JamMsg();

  JamMsg(const JamMsg& from);

  inline JamMsg& operator=(const JamMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JamMsg(JamMsg&& from) noexcept
    : JamMsg() {
    *this = ::std::move(from);
  }

  inline JamMsg& operator=(JamMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const JamMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JamMsg* internal_default_instance() {
    return reinterpret_cast<const JamMsg*>(
               &_JamMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(JamMsg* other);
  friend void swap(JamMsg& a, JamMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JamMsg* New() const final {
    return CreateMaybeMessage<JamMsg>(nullptr);
  }

  JamMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JamMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JamMsg& from);
  void MergeFrom(const JamMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JamMsg* other);
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::google::protobuf::StringPiece FullMessageName() {
    return "perception.JamMsg";
  }
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .perception.Jam jam = 1;
  int jam_size() const;
  void clear_jam();
  static const int kJamFieldNumber = 1;
  ::perception::Jam* mutable_jam(int index);
  ::google::protobuf::RepeatedPtrField< ::perception::Jam >*
      mutable_jam();
  const ::perception::Jam& jam(int index) const;
  ::perception::Jam* add_jam();
  const ::google::protobuf::RepeatedPtrField< ::perception::Jam >&
      jam() const;

  // @@protoc_insertion_point(class_scope:perception.JamMsg)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perception::Jam > jam_;
  friend struct ::TableStruct_perception_2eproto;
};
// -------------------------------------------------------------------

class FlowMsg final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:perception.FlowMsg) */ {
 public:
  FlowMsg();
  virtual ~FlowMsg();

  FlowMsg(const FlowMsg& from);

  inline FlowMsg& operator=(const FlowMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FlowMsg(FlowMsg&& from) noexcept
    : FlowMsg() {
    *this = ::std::move(from);
  }

  inline FlowMsg& operator=(FlowMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FlowMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlowMsg* internal_default_instance() {
    return reinterpret_cast<const FlowMsg*>(
               &_FlowMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(FlowMsg* other);
  friend void swap(FlowMsg& a, FlowMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FlowMsg* New() const final {
    return CreateMaybeMessage<FlowMsg>(nullptr);
  }

  FlowMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FlowMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FlowMsg& from);
  void MergeFrom(const FlowMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowMsg* other);
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::google::protobuf::StringPiece FullMessageName() {
    return "perception.FlowMsg";
  }
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .perception.Flow flow = 1;
  int flow_size() const;
  void clear_flow();
  static const int kFlowFieldNumber = 1;
  ::perception::Flow* mutable_flow(int index);
  ::google::protobuf::RepeatedPtrField< ::perception::Flow >*
      mutable_flow();
  const ::perception::Flow& flow(int index) const;
  ::perception::Flow* add_flow();
  const ::google::protobuf::RepeatedPtrField< ::perception::Flow >&
      flow() const;

  // optional .perception.Timestamp time_begin = 2;
  bool has_time_begin() const;
  void clear_time_begin();
  static const int kTimeBeginFieldNumber = 2;
  const ::perception::Timestamp& time_begin() const;
  ::perception::Timestamp* release_time_begin();
  ::perception::Timestamp* mutable_time_begin();
  void set_allocated_time_begin(::perception::Timestamp* time_begin);

  // optional .perception.Timestamp time_end = 3;
  bool has_time_end() const;
  void clear_time_end();
  static const int kTimeEndFieldNumber = 3;
  const ::perception::Timestamp& time_end() const;
  ::perception::Timestamp* release_time_end();
  ::perception::Timestamp* mutable_time_end();
  void set_allocated_time_end(::perception::Timestamp* time_end);

  // @@protoc_insertion_point(class_scope:perception.FlowMsg)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perception::Flow > flow_;
  ::perception::Timestamp* time_begin_;
  ::perception::Timestamp* time_end_;
  friend struct ::TableStruct_perception_2eproto;
};
// -------------------------------------------------------------------

class TargetMsg final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:perception.TargetMsg) */ {
 public:
  TargetMsg();
  virtual ~TargetMsg();

  TargetMsg(const TargetMsg& from);

  inline TargetMsg& operator=(const TargetMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TargetMsg(TargetMsg&& from) noexcept
    : TargetMsg() {
    *this = ::std::move(from);
  }

  inline TargetMsg& operator=(TargetMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TargetMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TargetMsg* internal_default_instance() {
    return reinterpret_cast<const TargetMsg*>(
               &_TargetMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(TargetMsg* other);
  friend void swap(TargetMsg& a, TargetMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TargetMsg* New() const final {
    return CreateMaybeMessage<TargetMsg>(nullptr);
  }

  TargetMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TargetMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TargetMsg& from);
  void MergeFrom(const TargetMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetMsg* other);
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::google::protobuf::StringPiece FullMessageName() {
    return "perception.TargetMsg";
  }
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .perception.Target target = 2;
  int target_size() const;
  void clear_target();
  static const int kTargetFieldNumber = 2;
  ::perception::Target* mutable_target(int index);
  ::google::protobuf::RepeatedPtrField< ::perception::Target >*
      mutable_target();
  const ::perception::Target& target(int index) const;
  ::perception::Target* add_target();
  const ::google::protobuf::RepeatedPtrField< ::perception::Target >&
      target() const;

  // @@protoc_insertion_point(class_scope:perception.TargetMsg)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perception::Target > target_;
  friend struct ::TableStruct_perception_2eproto;
};
// -------------------------------------------------------------------

class WarnMsg final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:perception.WarnMsg) */ {
 public:
  WarnMsg();
  virtual ~WarnMsg();

  WarnMsg(const WarnMsg& from);

  inline WarnMsg& operator=(const WarnMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WarnMsg(WarnMsg&& from) noexcept
    : WarnMsg() {
    *this = ::std::move(from);
  }

  inline WarnMsg& operator=(WarnMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WarnMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WarnMsg* internal_default_instance() {
    return reinterpret_cast<const WarnMsg*>(
               &_WarnMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(WarnMsg* other);
  friend void swap(WarnMsg& a, WarnMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WarnMsg* New() const final {
    return CreateMaybeMessage<WarnMsg>(nullptr);
  }

  WarnMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WarnMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WarnMsg& from);
  void MergeFrom(const WarnMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WarnMsg* other);
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::google::protobuf::StringPiece FullMessageName() {
    return "perception.WarnMsg";
  }
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool warn = 1;
  bool has_warn() const;
  void clear_warn();
  static const int kWarnFieldNumber = 1;
  bool warn() const;
  void set_warn(bool value);

  // @@protoc_insertion_point(class_scope:perception.WarnMsg)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool warn_;
  friend struct ::TableStruct_perception_2eproto;
};
// -------------------------------------------------------------------

class PerceptionMsg final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:perception.PerceptionMsg) */ {
 public:
  PerceptionMsg();
  virtual ~PerceptionMsg();

  PerceptionMsg(const PerceptionMsg& from);

  inline PerceptionMsg& operator=(const PerceptionMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PerceptionMsg(PerceptionMsg&& from) noexcept
    : PerceptionMsg() {
    *this = ::std::move(from);
  }

  inline PerceptionMsg& operator=(PerceptionMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PerceptionMsg& default_instance();

  enum MsgTypeCase {
    kWarnMsg = 2,
    kVisibilityMsg = 3,
    kLaneAreaMsg = 4,
    kJamMsg = 5,
    kFlowMsg = 6,
    kTargetMsg = 7,
    MSGTYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PerceptionMsg* internal_default_instance() {
    return reinterpret_cast<const PerceptionMsg*>(
               &_PerceptionMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(PerceptionMsg* other);
  friend void swap(PerceptionMsg& a, PerceptionMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PerceptionMsg* New() const final {
    return CreateMaybeMessage<PerceptionMsg>(nullptr);
  }

  PerceptionMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PerceptionMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PerceptionMsg& from);
  void MergeFrom(const PerceptionMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerceptionMsg* other);
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::google::protobuf::StringPiece FullMessageName() {
    return "perception.PerceptionMsg";
  }
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perception.Timestamp time = 8;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 8;
  const ::perception::Timestamp& time() const;
  ::perception::Timestamp* release_time();
  ::perception::Timestamp* mutable_time();
  void set_allocated_time(::perception::Timestamp* time);

  // required .perception.EventId event = 1;
  bool has_event() const;
  void clear_event();
  static const int kEventFieldNumber = 1;
  ::perception::EventId event() const;
  void set_event(::perception::EventId value);

  // optional .perception.WarnMsg warn_msg = 2;
  bool has_warn_msg() const;
  void clear_warn_msg();
  static const int kWarnMsgFieldNumber = 2;
  const ::perception::WarnMsg& warn_msg() const;
  ::perception::WarnMsg* release_warn_msg();
  ::perception::WarnMsg* mutable_warn_msg();
  void set_allocated_warn_msg(::perception::WarnMsg* warn_msg);

  // optional .perception.VisibilityMsg visibility_msg = 3;
  bool has_visibility_msg() const;
  void clear_visibility_msg();
  static const int kVisibilityMsgFieldNumber = 3;
  const ::perception::VisibilityMsg& visibility_msg() const;
  ::perception::VisibilityMsg* release_visibility_msg();
  ::perception::VisibilityMsg* mutable_visibility_msg();
  void set_allocated_visibility_msg(::perception::VisibilityMsg* visibility_msg);

  // optional .perception.LaneAreaMsg lane_area_msg = 4;
  bool has_lane_area_msg() const;
  void clear_lane_area_msg();
  static const int kLaneAreaMsgFieldNumber = 4;
  const ::perception::LaneAreaMsg& lane_area_msg() const;
  ::perception::LaneAreaMsg* release_lane_area_msg();
  ::perception::LaneAreaMsg* mutable_lane_area_msg();
  void set_allocated_lane_area_msg(::perception::LaneAreaMsg* lane_area_msg);

  // optional .perception.JamMsg jam_msg = 5;
  bool has_jam_msg() const;
  void clear_jam_msg();
  static const int kJamMsgFieldNumber = 5;
  const ::perception::JamMsg& jam_msg() const;
  ::perception::JamMsg* release_jam_msg();
  ::perception::JamMsg* mutable_jam_msg();
  void set_allocated_jam_msg(::perception::JamMsg* jam_msg);

  // optional .perception.FlowMsg flow_msg = 6;
  bool has_flow_msg() const;
  void clear_flow_msg();
  static const int kFlowMsgFieldNumber = 6;
  const ::perception::FlowMsg& flow_msg() const;
  ::perception::FlowMsg* release_flow_msg();
  ::perception::FlowMsg* mutable_flow_msg();
  void set_allocated_flow_msg(::perception::FlowMsg* flow_msg);

  // optional .perception.TargetMsg target_msg = 7;
  bool has_target_msg() const;
  void clear_target_msg();
  static const int kTargetMsgFieldNumber = 7;
  const ::perception::TargetMsg& target_msg() const;
  ::perception::TargetMsg* release_target_msg();
  ::perception::TargetMsg* mutable_target_msg();
  void set_allocated_target_msg(::perception::TargetMsg* target_msg);

  void clear_MsgType();
  MsgTypeCase MsgType_case() const;
  // @@protoc_insertion_point(class_scope:perception.PerceptionMsg)
 private:
  class HasBitSetters;
  void set_has_warn_msg();
  void set_has_visibility_msg();
  void set_has_lane_area_msg();
  void set_has_jam_msg();
  void set_has_flow_msg();
  void set_has_target_msg();

  inline bool has_MsgType() const;
  inline void clear_has_MsgType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::perception::Timestamp* time_;
  int event_;
  union MsgTypeUnion {
    MsgTypeUnion() {}
    ::perception::WarnMsg* warn_msg_;
    ::perception::VisibilityMsg* visibility_msg_;
    ::perception::LaneAreaMsg* lane_area_msg_;
    ::perception::JamMsg* jam_msg_;
    ::perception::FlowMsg* flow_msg_;
    ::perception::TargetMsg* target_msg_;
  } MsgType_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_perception_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Position

// required int32 lon = 1;
inline bool Position::has_lon() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Position::clear_lon() {
  lon_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int32 Position::lon() const {
  // @@protoc_insertion_point(field_get:perception.Position.lon)
  return lon_;
}
inline void Position::set_lon(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  lon_ = value;
  // @@protoc_insertion_point(field_set:perception.Position.lon)
}

// required int32 lat = 2;
inline bool Position::has_lat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Position::clear_lat() {
  lat_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 Position::lat() const {
  // @@protoc_insertion_point(field_get:perception.Position.lat)
  return lat_;
}
inline void Position::set_lat(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  lat_ = value;
  // @@protoc_insertion_point(field_set:perception.Position.lat)
}

// optional float elevation = 3;
inline bool Position::has_elevation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Position::clear_elevation() {
  elevation_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Position::elevation() const {
  // @@protoc_insertion_point(field_get:perception.Position.elevation)
  return elevation_;
}
inline void Position::set_elevation(float value) {
  _has_bits_[0] |= 0x00000004u;
  elevation_ = value;
  // @@protoc_insertion_point(field_set:perception.Position.elevation)
}

// -------------------------------------------------------------------

// Timestamp

// required int64 seconds = 1;
inline bool Timestamp::has_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Timestamp::clear_seconds() {
  seconds_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int64 Timestamp::seconds() const {
  // @@protoc_insertion_point(field_get:perception.Timestamp.seconds)
  return seconds_;
}
inline void Timestamp::set_seconds(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  seconds_ = value;
  // @@protoc_insertion_point(field_set:perception.Timestamp.seconds)
}

// required int32 nanos = 2;
inline bool Timestamp::has_nanos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Timestamp::clear_nanos() {
  nanos_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 Timestamp::nanos() const {
  // @@protoc_insertion_point(field_get:perception.Timestamp.nanos)
  return nanos_;
}
inline void Timestamp::set_nanos(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  nanos_ = value;
  // @@protoc_insertion_point(field_set:perception.Timestamp.nanos)
}

// -------------------------------------------------------------------

// Size

// required float length = 1;
inline bool Size::has_length() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Size::clear_length() {
  length_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Size::length() const {
  // @@protoc_insertion_point(field_get:perception.Size.length)
  return length_;
}
inline void Size::set_length(float value) {
  _has_bits_[0] |= 0x00000001u;
  length_ = value;
  // @@protoc_insertion_point(field_set:perception.Size.length)
}

// required float width = 2;
inline bool Size::has_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Size::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Size::width() const {
  // @@protoc_insertion_point(field_get:perception.Size.width)
  return width_;
}
inline void Size::set_width(float value) {
  _has_bits_[0] |= 0x00000002u;
  width_ = value;
  // @@protoc_insertion_point(field_set:perception.Size.width)
}

// required float height = 3;
inline bool Size::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Size::clear_height() {
  height_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Size::height() const {
  // @@protoc_insertion_point(field_get:perception.Size.height)
  return height_;
}
inline void Size::set_height(float value) {
  _has_bits_[0] |= 0x00000004u;
  height_ = value;
  // @@protoc_insertion_point(field_set:perception.Size.height)
}

// -------------------------------------------------------------------

// LaneInfoEx

// required int32 lane_info = 1;
inline bool LaneInfoEx::has_lane_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneInfoEx::clear_lane_info() {
  lane_info_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int32 LaneInfoEx::lane_info() const {
  // @@protoc_insertion_point(field_get:perception.LaneInfoEx.lane_info)
  return lane_info_;
}
inline void LaneInfoEx::set_lane_info(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  lane_info_ = value;
  // @@protoc_insertion_point(field_set:perception.LaneInfoEx.lane_info)
}

// required int32 lane_id = 2;
inline bool LaneInfoEx::has_lane_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneInfoEx::clear_lane_id() {
  lane_id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 LaneInfoEx::lane_id() const {
  // @@protoc_insertion_point(field_get:perception.LaneInfoEx.lane_id)
  return lane_id_;
}
inline void LaneInfoEx::set_lane_id(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  lane_id_ = value;
  // @@protoc_insertion_point(field_set:perception.LaneInfoEx.lane_id)
}

// required int32 lane_count = 3;
inline bool LaneInfoEx::has_lane_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneInfoEx::clear_lane_count() {
  lane_count_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::int32 LaneInfoEx::lane_count() const {
  // @@protoc_insertion_point(field_get:perception.LaneInfoEx.lane_count)
  return lane_count_;
}
inline void LaneInfoEx::set_lane_count(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  lane_count_ = value;
  // @@protoc_insertion_point(field_set:perception.LaneInfoEx.lane_count)
}

// required float lane_heading = 4;
inline bool LaneInfoEx::has_lane_heading() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LaneInfoEx::clear_lane_heading() {
  lane_heading_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float LaneInfoEx::lane_heading() const {
  // @@protoc_insertion_point(field_get:perception.LaneInfoEx.lane_heading)
  return lane_heading_;
}
inline void LaneInfoEx::set_lane_heading(float value) {
  _has_bits_[0] |= 0x00000008u;
  lane_heading_ = value;
  // @@protoc_insertion_point(field_set:perception.LaneInfoEx.lane_heading)
}

// -------------------------------------------------------------------

// LaneArea

// repeated .perception.Position pos = 1;
inline int LaneArea::pos_size() const {
  return pos_.size();
}
inline void LaneArea::clear_pos() {
  pos_.Clear();
}
inline ::perception::Position* LaneArea::mutable_pos(int index) {
  // @@protoc_insertion_point(field_mutable:perception.LaneArea.pos)
  return pos_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::perception::Position >*
LaneArea::mutable_pos() {
  // @@protoc_insertion_point(field_mutable_list:perception.LaneArea.pos)
  return &pos_;
}
inline const ::perception::Position& LaneArea::pos(int index) const {
  // @@protoc_insertion_point(field_get:perception.LaneArea.pos)
  return pos_.Get(index);
}
inline ::perception::Position* LaneArea::add_pos() {
  // @@protoc_insertion_point(field_add:perception.LaneArea.pos)
  return pos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::perception::Position >&
LaneArea::pos() const {
  // @@protoc_insertion_point(field_list:perception.LaneArea.pos)
  return pos_;
}

// optional int32 camera = 2;
inline bool LaneArea::has_camera() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneArea::clear_camera() {
  camera_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int32 LaneArea::camera() const {
  // @@protoc_insertion_point(field_get:perception.LaneArea.camera)
  return camera_;
}
inline void LaneArea::set_camera(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  camera_ = value;
  // @@protoc_insertion_point(field_set:perception.LaneArea.camera)
}

// optional int32 lane_id = 3;
inline bool LaneArea::has_lane_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneArea::clear_lane_id() {
  lane_id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 LaneArea::lane_id() const {
  // @@protoc_insertion_point(field_get:perception.LaneArea.lane_id)
  return lane_id_;
}
inline void LaneArea::set_lane_id(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  lane_id_ = value;
  // @@protoc_insertion_point(field_set:perception.LaneArea.lane_id)
}

// optional float lane_heading = 4;
inline bool LaneArea::has_lane_heading() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneArea::clear_lane_heading() {
  lane_heading_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float LaneArea::lane_heading() const {
  // @@protoc_insertion_point(field_get:perception.LaneArea.lane_heading)
  return lane_heading_;
}
inline void LaneArea::set_lane_heading(float value) {
  _has_bits_[0] |= 0x00000004u;
  lane_heading_ = value;
  // @@protoc_insertion_point(field_set:perception.LaneArea.lane_heading)
}

// optional .perception.WareType ware = 5;
inline bool LaneArea::has_ware() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LaneArea::clear_ware() {
  ware_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::perception::WareType LaneArea::ware() const {
  // @@protoc_insertion_point(field_get:perception.LaneArea.ware)
  return static_cast< ::perception::WareType >(ware_);
}
inline void LaneArea::set_ware(::perception::WareType value) {
  assert(::perception::WareType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  ware_ = value;
  // @@protoc_insertion_point(field_set:perception.LaneArea.ware)
}

// -------------------------------------------------------------------

// Jam

// required uint32 vehicle_num = 1;
inline bool Jam::has_vehicle_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Jam::clear_vehicle_num() {
  vehicle_num_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 Jam::vehicle_num() const {
  // @@protoc_insertion_point(field_get:perception.Jam.vehicle_num)
  return vehicle_num_;
}
inline void Jam::set_vehicle_num(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  vehicle_num_ = value;
  // @@protoc_insertion_point(field_set:perception.Jam.vehicle_num)
}

// required float vehicle_velocity = 2;
inline bool Jam::has_vehicle_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Jam::clear_vehicle_velocity() {
  vehicle_velocity_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Jam::vehicle_velocity() const {
  // @@protoc_insertion_point(field_get:perception.Jam.vehicle_velocity)
  return vehicle_velocity_;
}
inline void Jam::set_vehicle_velocity(float value) {
  _has_bits_[0] |= 0x00000002u;
  vehicle_velocity_ = value;
  // @@protoc_insertion_point(field_set:perception.Jam.vehicle_velocity)
}

// required float lane_heading = 3;
inline bool Jam::has_lane_heading() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Jam::clear_lane_heading() {
  lane_heading_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Jam::lane_heading() const {
  // @@protoc_insertion_point(field_get:perception.Jam.lane_heading)
  return lane_heading_;
}
inline void Jam::set_lane_heading(float value) {
  _has_bits_[0] |= 0x00000004u;
  lane_heading_ = value;
  // @@protoc_insertion_point(field_set:perception.Jam.lane_heading)
}

// repeated int32 vehicle_flow = 4;
inline int Jam::vehicle_flow_size() const {
  return vehicle_flow_.size();
}
inline void Jam::clear_vehicle_flow() {
  vehicle_flow_.Clear();
}
inline ::google::protobuf::int32 Jam::vehicle_flow(int index) const {
  // @@protoc_insertion_point(field_get:perception.Jam.vehicle_flow)
  return vehicle_flow_.Get(index);
}
inline void Jam::set_vehicle_flow(int index, ::google::protobuf::int32 value) {
  vehicle_flow_.Set(index, value);
  // @@protoc_insertion_point(field_set:perception.Jam.vehicle_flow)
}
inline void Jam::add_vehicle_flow(::google::protobuf::int32 value) {
  vehicle_flow_.Add(value);
  // @@protoc_insertion_point(field_add:perception.Jam.vehicle_flow)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Jam::vehicle_flow() const {
  // @@protoc_insertion_point(field_list:perception.Jam.vehicle_flow)
  return vehicle_flow_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Jam::mutable_vehicle_flow() {
  // @@protoc_insertion_point(field_mutable_list:perception.Jam.vehicle_flow)
  return &vehicle_flow_;
}

// optional int32 lane_id = 5;
inline bool Jam::has_lane_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Jam::clear_lane_id() {
  lane_id_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::int32 Jam::lane_id() const {
  // @@protoc_insertion_point(field_get:perception.Jam.lane_id)
  return lane_id_;
}
inline void Jam::set_lane_id(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  lane_id_ = value;
  // @@protoc_insertion_point(field_set:perception.Jam.lane_id)
}

// -------------------------------------------------------------------

// Flow

// optional int32 camera = 1;
inline bool Flow::has_camera() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Flow::clear_camera() {
  camera_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int32 Flow::camera() const {
  // @@protoc_insertion_point(field_get:perception.Flow.camera)
  return camera_;
}
inline void Flow::set_camera(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  camera_ = value;
  // @@protoc_insertion_point(field_set:perception.Flow.camera)
}

// repeated int32 vehicle_num = 2;
inline int Flow::vehicle_num_size() const {
  return vehicle_num_.size();
}
inline void Flow::clear_vehicle_num() {
  vehicle_num_.Clear();
}
inline ::google::protobuf::int32 Flow::vehicle_num(int index) const {
  // @@protoc_insertion_point(field_get:perception.Flow.vehicle_num)
  return vehicle_num_.Get(index);
}
inline void Flow::set_vehicle_num(int index, ::google::protobuf::int32 value) {
  vehicle_num_.Set(index, value);
  // @@protoc_insertion_point(field_set:perception.Flow.vehicle_num)
}
inline void Flow::add_vehicle_num(::google::protobuf::int32 value) {
  vehicle_num_.Add(value);
  // @@protoc_insertion_point(field_add:perception.Flow.vehicle_num)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Flow::vehicle_num() const {
  // @@protoc_insertion_point(field_list:perception.Flow.vehicle_num)
  return vehicle_num_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Flow::mutable_vehicle_num() {
  // @@protoc_insertion_point(field_mutable_list:perception.Flow.vehicle_num)
  return &vehicle_num_;
}

// repeated int32 pass_num = 3;
inline int Flow::pass_num_size() const {
  return pass_num_.size();
}
inline void Flow::clear_pass_num() {
  pass_num_.Clear();
}
inline ::google::protobuf::int32 Flow::pass_num(int index) const {
  // @@protoc_insertion_point(field_get:perception.Flow.pass_num)
  return pass_num_.Get(index);
}
inline void Flow::set_pass_num(int index, ::google::protobuf::int32 value) {
  pass_num_.Set(index, value);
  // @@protoc_insertion_point(field_set:perception.Flow.pass_num)
}
inline void Flow::add_pass_num(::google::protobuf::int32 value) {
  pass_num_.Add(value);
  // @@protoc_insertion_point(field_add:perception.Flow.pass_num)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Flow::pass_num() const {
  // @@protoc_insertion_point(field_list:perception.Flow.pass_num)
  return pass_num_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Flow::mutable_pass_num() {
  // @@protoc_insertion_point(field_mutable_list:perception.Flow.pass_num)
  return &pass_num_;
}

// optional .perception.Flow.TrafficSig signal = 4;
inline bool Flow::has_signal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Flow::clear_signal() {
  signal_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::perception::Flow_TrafficSig Flow::signal() const {
  // @@protoc_insertion_point(field_get:perception.Flow.signal)
  return static_cast< ::perception::Flow_TrafficSig >(signal_);
}
inline void Flow::set_signal(::perception::Flow_TrafficSig value) {
  assert(::perception::Flow_TrafficSig_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  signal_ = value;
  // @@protoc_insertion_point(field_set:perception.Flow.signal)
}

// -------------------------------------------------------------------

// Target

// required int32 id = 1;
inline bool Target::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Target::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::int32 Target::id() const {
  // @@protoc_insertion_point(field_get:perception.Target.id)
  return id_;
}
inline void Target::set_id(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  id_ = value;
  // @@protoc_insertion_point(field_set:perception.Target.id)
}

// required .perception.TargetType type = 2;
inline bool Target::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Target::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::perception::TargetType Target::type() const {
  // @@protoc_insertion_point(field_get:perception.Target.type)
  return static_cast< ::perception::TargetType >(type_);
}
inline void Target::set_type(::perception::TargetType value) {
  assert(::perception::TargetType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  type_ = value;
  // @@protoc_insertion_point(field_set:perception.Target.type)
}

// required .perception.Position pos = 3;
inline bool Target::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Target::clear_pos() {
  if (pos_ != nullptr) pos_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::perception::Position& Target::pos() const {
  const ::perception::Position* p = pos_;
  // @@protoc_insertion_point(field_get:perception.Target.pos)
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::Position*>(
      &::perception::_Position_default_instance_);
}
inline ::perception::Position* Target::release_pos() {
  // @@protoc_insertion_point(field_release:perception.Target.pos)
  _has_bits_[0] &= ~0x00000002u;
  ::perception::Position* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::perception::Position* Target::mutable_pos() {
  _has_bits_[0] |= 0x00000002u;
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::Position>(GetArenaNoVirtual());
    pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:perception.Target.pos)
  return pos_;
}
inline void Target::set_allocated_pos(::perception::Position* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pos_;
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:perception.Target.pos)
}

// optional int32 camera = 4;
inline bool Target::has_camera() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Target::clear_camera() {
  camera_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::int32 Target::camera() const {
  // @@protoc_insertion_point(field_get:perception.Target.camera)
  return camera_;
}
inline void Target::set_camera(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  camera_ = value;
  // @@protoc_insertion_point(field_set:perception.Target.camera)
}

// optional float velocity = 5;
inline bool Target::has_velocity() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Target::clear_velocity() {
  velocity_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float Target::velocity() const {
  // @@protoc_insertion_point(field_get:perception.Target.velocity)
  return velocity_;
}
inline void Target::set_velocity(float value) {
  _has_bits_[0] |= 0x00000080u;
  velocity_ = value;
  // @@protoc_insertion_point(field_set:perception.Target.velocity)
}

// optional float heading = 6;
inline bool Target::has_heading() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Target::clear_heading() {
  heading_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float Target::heading() const {
  // @@protoc_insertion_point(field_get:perception.Target.heading)
  return heading_;
}
inline void Target::set_heading(float value) {
  _has_bits_[0] |= 0x00000100u;
  heading_ = value;
  // @@protoc_insertion_point(field_set:perception.Target.heading)
}

// optional float distance = 7;
inline bool Target::has_distance() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Target::clear_distance() {
  distance_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float Target::distance() const {
  // @@protoc_insertion_point(field_get:perception.Target.distance)
  return distance_;
}
inline void Target::set_distance(float value) {
  _has_bits_[0] |= 0x00000200u;
  distance_ = value;
  // @@protoc_insertion_point(field_set:perception.Target.distance)
}

// optional .perception.Size size = 8;
inline bool Target::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Target::clear_size() {
  if (size_ != nullptr) size_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::perception::Size& Target::size() const {
  const ::perception::Size* p = size_;
  // @@protoc_insertion_point(field_get:perception.Target.size)
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::Size*>(
      &::perception::_Size_default_instance_);
}
inline ::perception::Size* Target::release_size() {
  // @@protoc_insertion_point(field_release:perception.Target.size)
  _has_bits_[0] &= ~0x00000004u;
  ::perception::Size* temp = size_;
  size_ = nullptr;
  return temp;
}
inline ::perception::Size* Target::mutable_size() {
  _has_bits_[0] |= 0x00000004u;
  if (size_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::Size>(GetArenaNoVirtual());
    size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:perception.Target.size)
  return size_;
}
inline void Target::set_allocated_size(::perception::Size* size) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete size_;
  }
  if (size) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      size = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:perception.Target.size)
}

// optional int32 approach_judge = 9;
inline bool Target::has_approach_judge() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Target::clear_approach_judge() {
  approach_judge_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::google::protobuf::int32 Target::approach_judge() const {
  // @@protoc_insertion_point(field_get:perception.Target.approach_judge)
  return approach_judge_;
}
inline void Target::set_approach_judge(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000400u;
  approach_judge_ = value;
  // @@protoc_insertion_point(field_set:perception.Target.approach_judge)
}

// optional .perception.Source source = 10;
inline bool Target::has_source() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Target::clear_source() {
  source_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::perception::Source Target::source() const {
  // @@protoc_insertion_point(field_get:perception.Target.source)
  return static_cast< ::perception::Source >(source_);
}
inline void Target::set_source(::perception::Source value) {
  assert(::perception::Source_IsValid(value));
  _has_bits_[0] |= 0x00000800u;
  source_ = value;
  // @@protoc_insertion_point(field_set:perception.Target.source)
}

// optional int32 capture_id = 11;
inline bool Target::has_capture_id() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Target::clear_capture_id() {
  capture_id_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::google::protobuf::int32 Target::capture_id() const {
  // @@protoc_insertion_point(field_get:perception.Target.capture_id)
  return capture_id_;
}
inline void Target::set_capture_id(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00001000u;
  capture_id_ = value;
  // @@protoc_insertion_point(field_set:perception.Target.capture_id)
}

// optional bool in_lane = 12;
inline bool Target::has_in_lane() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Target::clear_in_lane() {
  in_lane_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool Target::in_lane() const {
  // @@protoc_insertion_point(field_get:perception.Target.in_lane)
  return in_lane_;
}
inline void Target::set_in_lane(bool value) {
  _has_bits_[0] |= 0x00002000u;
  in_lane_ = value;
  // @@protoc_insertion_point(field_set:perception.Target.in_lane)
}

// optional int32 lane_id = 13;
inline bool Target::has_lane_id() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Target::clear_lane_id() {
  lane_id_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::google::protobuf::int32 Target::lane_id() const {
  // @@protoc_insertion_point(field_get:perception.Target.lane_id)
  return lane_id_;
}
inline void Target::set_lane_id(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00004000u;
  lane_id_ = value;
  // @@protoc_insertion_point(field_set:perception.Target.lane_id)
}

// optional float lane_heading = 14;
inline bool Target::has_lane_heading() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Target::clear_lane_heading() {
  lane_heading_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline float Target::lane_heading() const {
  // @@protoc_insertion_point(field_get:perception.Target.lane_heading)
  return lane_heading_;
}
inline void Target::set_lane_heading(float value) {
  _has_bits_[0] |= 0x00008000u;
  lane_heading_ = value;
  // @@protoc_insertion_point(field_set:perception.Target.lane_heading)
}

// optional int32 lane_type = 15;
inline bool Target::has_lane_type() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Target::clear_lane_type() {
  lane_type_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::google::protobuf::int32 Target::lane_type() const {
  // @@protoc_insertion_point(field_get:perception.Target.lane_type)
  return lane_type_;
}
inline void Target::set_lane_type(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00010000u;
  lane_type_ = value;
  // @@protoc_insertion_point(field_set:perception.Target.lane_type)
}

// optional .perception.LaneInfoEx lane_ex = 16;
inline bool Target::has_lane_ex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Target::clear_lane_ex() {
  if (lane_ex_ != nullptr) lane_ex_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::perception::LaneInfoEx& Target::lane_ex() const {
  const ::perception::LaneInfoEx* p = lane_ex_;
  // @@protoc_insertion_point(field_get:perception.Target.lane_ex)
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::LaneInfoEx*>(
      &::perception::_LaneInfoEx_default_instance_);
}
inline ::perception::LaneInfoEx* Target::release_lane_ex() {
  // @@protoc_insertion_point(field_release:perception.Target.lane_ex)
  _has_bits_[0] &= ~0x00000008u;
  ::perception::LaneInfoEx* temp = lane_ex_;
  lane_ex_ = nullptr;
  return temp;
}
inline ::perception::LaneInfoEx* Target::mutable_lane_ex() {
  _has_bits_[0] |= 0x00000008u;
  if (lane_ex_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::LaneInfoEx>(GetArenaNoVirtual());
    lane_ex_ = p;
  }
  // @@protoc_insertion_point(field_mutable:perception.Target.lane_ex)
  return lane_ex_;
}
inline void Target::set_allocated_lane_ex(::perception::LaneInfoEx* lane_ex) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete lane_ex_;
  }
  if (lane_ex) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      lane_ex = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lane_ex, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  lane_ex_ = lane_ex;
  // @@protoc_insertion_point(field_set_allocated:perception.Target.lane_ex)
}

// optional string license_plate = 17;
inline bool Target::has_license_plate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Target::clear_license_plate() {
  license_plate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Target::license_plate() const {
  // @@protoc_insertion_point(field_get:perception.Target.license_plate)
  return license_plate_.GetNoArena();
}
inline void Target::set_license_plate(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  license_plate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perception.Target.license_plate)
}
#if LANG_CXX11
inline void Target::set_license_plate(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  license_plate_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:perception.Target.license_plate)
}
#endif
inline void Target::set_license_plate(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  license_plate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perception.Target.license_plate)
}
inline void Target::set_license_plate(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  license_plate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perception.Target.license_plate)
}
inline ::std::string* Target::mutable_license_plate() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:perception.Target.license_plate)
  return license_plate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Target::release_license_plate() {
  // @@protoc_insertion_point(field_release:perception.Target.license_plate)
  if (!has_license_plate()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return license_plate_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Target::set_allocated_license_plate(::std::string* license_plate) {
  if (license_plate != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  license_plate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), license_plate);
  // @@protoc_insertion_point(field_set_allocated:perception.Target.license_plate)
}

// optional .perception.CarType car_type = 18;
inline bool Target::has_car_type() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Target::clear_car_type() {
  car_type_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::perception::CarType Target::car_type() const {
  // @@protoc_insertion_point(field_get:perception.Target.car_type)
  return static_cast< ::perception::CarType >(car_type_);
}
inline void Target::set_car_type(::perception::CarType value) {
  assert(::perception::CarType_IsValid(value));
  _has_bits_[0] |= 0x00020000u;
  car_type_ = value;
  // @@protoc_insertion_point(field_set:perception.Target.car_type)
}

// optional .perception.CarStatus car_status = 19;
inline bool Target::has_car_status() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Target::clear_car_status() {
  car_status_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::perception::CarStatus Target::car_status() const {
  // @@protoc_insertion_point(field_get:perception.Target.car_status)
  return static_cast< ::perception::CarStatus >(car_status_);
}
inline void Target::set_car_status(::perception::CarStatus value) {
  assert(::perception::CarStatus_IsValid(value));
  _has_bits_[0] |= 0x00040000u;
  car_status_ = value;
  // @@protoc_insertion_point(field_set:perception.Target.car_status)
}

// optional float confidence = 20;
inline bool Target::has_confidence() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Target::clear_confidence() {
  confidence_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline float Target::confidence() const {
  // @@protoc_insertion_point(field_get:perception.Target.confidence)
  return confidence_;
}
inline void Target::set_confidence(float value) {
  _has_bits_[0] |= 0x00080000u;
  confidence_ = value;
  // @@protoc_insertion_point(field_set:perception.Target.confidence)
}

// optional float rcs = 21;
inline bool Target::has_rcs() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Target::clear_rcs() {
  rcs_ = 0;
  _has_bits_[0] &= ~0x00100000u;
}
inline float Target::rcs() const {
  // @@protoc_insertion_point(field_get:perception.Target.rcs)
  return rcs_;
}
inline void Target::set_rcs(float value) {
  _has_bits_[0] |= 0x00100000u;
  rcs_ = value;
  // @@protoc_insertion_point(field_set:perception.Target.rcs)
}

// -------------------------------------------------------------------

// VisibilityMsg

// required float distance = 2;
inline bool VisibilityMsg::has_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VisibilityMsg::clear_distance() {
  distance_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float VisibilityMsg::distance() const {
  // @@protoc_insertion_point(field_get:perception.VisibilityMsg.distance)
  return distance_;
}
inline void VisibilityMsg::set_distance(float value) {
  _has_bits_[0] |= 0x00000001u;
  distance_ = value;
  // @@protoc_insertion_point(field_set:perception.VisibilityMsg.distance)
}

// required int32 level = 3;
inline bool VisibilityMsg::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VisibilityMsg::clear_level() {
  level_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 VisibilityMsg::level() const {
  // @@protoc_insertion_point(field_get:perception.VisibilityMsg.level)
  return level_;
}
inline void VisibilityMsg::set_level(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  level_ = value;
  // @@protoc_insertion_point(field_set:perception.VisibilityMsg.level)
}

// -------------------------------------------------------------------

// LaneAreaMsg

// repeated .perception.LaneArea area = 1;
inline int LaneAreaMsg::area_size() const {
  return area_.size();
}
inline void LaneAreaMsg::clear_area() {
  area_.Clear();
}
inline ::perception::LaneArea* LaneAreaMsg::mutable_area(int index) {
  // @@protoc_insertion_point(field_mutable:perception.LaneAreaMsg.area)
  return area_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::perception::LaneArea >*
LaneAreaMsg::mutable_area() {
  // @@protoc_insertion_point(field_mutable_list:perception.LaneAreaMsg.area)
  return &area_;
}
inline const ::perception::LaneArea& LaneAreaMsg::area(int index) const {
  // @@protoc_insertion_point(field_get:perception.LaneAreaMsg.area)
  return area_.Get(index);
}
inline ::perception::LaneArea* LaneAreaMsg::add_area() {
  // @@protoc_insertion_point(field_add:perception.LaneAreaMsg.area)
  return area_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::perception::LaneArea >&
LaneAreaMsg::area() const {
  // @@protoc_insertion_point(field_list:perception.LaneAreaMsg.area)
  return area_;
}

// -------------------------------------------------------------------

// JamMsg

// repeated .perception.Jam jam = 1;
inline int JamMsg::jam_size() const {
  return jam_.size();
}
inline void JamMsg::clear_jam() {
  jam_.Clear();
}
inline ::perception::Jam* JamMsg::mutable_jam(int index) {
  // @@protoc_insertion_point(field_mutable:perception.JamMsg.jam)
  return jam_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::perception::Jam >*
JamMsg::mutable_jam() {
  // @@protoc_insertion_point(field_mutable_list:perception.JamMsg.jam)
  return &jam_;
}
inline const ::perception::Jam& JamMsg::jam(int index) const {
  // @@protoc_insertion_point(field_get:perception.JamMsg.jam)
  return jam_.Get(index);
}
inline ::perception::Jam* JamMsg::add_jam() {
  // @@protoc_insertion_point(field_add:perception.JamMsg.jam)
  return jam_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::perception::Jam >&
JamMsg::jam() const {
  // @@protoc_insertion_point(field_list:perception.JamMsg.jam)
  return jam_;
}

// -------------------------------------------------------------------

// FlowMsg

// repeated .perception.Flow flow = 1;
inline int FlowMsg::flow_size() const {
  return flow_.size();
}
inline void FlowMsg::clear_flow() {
  flow_.Clear();
}
inline ::perception::Flow* FlowMsg::mutable_flow(int index) {
  // @@protoc_insertion_point(field_mutable:perception.FlowMsg.flow)
  return flow_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::perception::Flow >*
FlowMsg::mutable_flow() {
  // @@protoc_insertion_point(field_mutable_list:perception.FlowMsg.flow)
  return &flow_;
}
inline const ::perception::Flow& FlowMsg::flow(int index) const {
  // @@protoc_insertion_point(field_get:perception.FlowMsg.flow)
  return flow_.Get(index);
}
inline ::perception::Flow* FlowMsg::add_flow() {
  // @@protoc_insertion_point(field_add:perception.FlowMsg.flow)
  return flow_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::perception::Flow >&
FlowMsg::flow() const {
  // @@protoc_insertion_point(field_list:perception.FlowMsg.flow)
  return flow_;
}

// optional .perception.Timestamp time_begin = 2;
inline bool FlowMsg::has_time_begin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlowMsg::clear_time_begin() {
  if (time_begin_ != nullptr) time_begin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::perception::Timestamp& FlowMsg::time_begin() const {
  const ::perception::Timestamp* p = time_begin_;
  // @@protoc_insertion_point(field_get:perception.FlowMsg.time_begin)
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::Timestamp*>(
      &::perception::_Timestamp_default_instance_);
}
inline ::perception::Timestamp* FlowMsg::release_time_begin() {
  // @@protoc_insertion_point(field_release:perception.FlowMsg.time_begin)
  _has_bits_[0] &= ~0x00000001u;
  ::perception::Timestamp* temp = time_begin_;
  time_begin_ = nullptr;
  return temp;
}
inline ::perception::Timestamp* FlowMsg::mutable_time_begin() {
  _has_bits_[0] |= 0x00000001u;
  if (time_begin_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::Timestamp>(GetArenaNoVirtual());
    time_begin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:perception.FlowMsg.time_begin)
  return time_begin_;
}
inline void FlowMsg::set_allocated_time_begin(::perception::Timestamp* time_begin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete time_begin_;
  }
  if (time_begin) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      time_begin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time_begin, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  time_begin_ = time_begin;
  // @@protoc_insertion_point(field_set_allocated:perception.FlowMsg.time_begin)
}

// optional .perception.Timestamp time_end = 3;
inline bool FlowMsg::has_time_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlowMsg::clear_time_end() {
  if (time_end_ != nullptr) time_end_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::perception::Timestamp& FlowMsg::time_end() const {
  const ::perception::Timestamp* p = time_end_;
  // @@protoc_insertion_point(field_get:perception.FlowMsg.time_end)
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::Timestamp*>(
      &::perception::_Timestamp_default_instance_);
}
inline ::perception::Timestamp* FlowMsg::release_time_end() {
  // @@protoc_insertion_point(field_release:perception.FlowMsg.time_end)
  _has_bits_[0] &= ~0x00000002u;
  ::perception::Timestamp* temp = time_end_;
  time_end_ = nullptr;
  return temp;
}
inline ::perception::Timestamp* FlowMsg::mutable_time_end() {
  _has_bits_[0] |= 0x00000002u;
  if (time_end_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::Timestamp>(GetArenaNoVirtual());
    time_end_ = p;
  }
  // @@protoc_insertion_point(field_mutable:perception.FlowMsg.time_end)
  return time_end_;
}
inline void FlowMsg::set_allocated_time_end(::perception::Timestamp* time_end) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete time_end_;
  }
  if (time_end) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      time_end = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time_end, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  time_end_ = time_end;
  // @@protoc_insertion_point(field_set_allocated:perception.FlowMsg.time_end)
}

// -------------------------------------------------------------------

// TargetMsg

// repeated .perception.Target target = 2;
inline int TargetMsg::target_size() const {
  return target_.size();
}
inline void TargetMsg::clear_target() {
  target_.Clear();
}
inline ::perception::Target* TargetMsg::mutable_target(int index) {
  // @@protoc_insertion_point(field_mutable:perception.TargetMsg.target)
  return target_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::perception::Target >*
TargetMsg::mutable_target() {
  // @@protoc_insertion_point(field_mutable_list:perception.TargetMsg.target)
  return &target_;
}
inline const ::perception::Target& TargetMsg::target(int index) const {
  // @@protoc_insertion_point(field_get:perception.TargetMsg.target)
  return target_.Get(index);
}
inline ::perception::Target* TargetMsg::add_target() {
  // @@protoc_insertion_point(field_add:perception.TargetMsg.target)
  return target_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::perception::Target >&
TargetMsg::target() const {
  // @@protoc_insertion_point(field_list:perception.TargetMsg.target)
  return target_;
}

// -------------------------------------------------------------------

// WarnMsg

// required bool warn = 1;
inline bool WarnMsg::has_warn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WarnMsg::clear_warn() {
  warn_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool WarnMsg::warn() const {
  // @@protoc_insertion_point(field_get:perception.WarnMsg.warn)
  return warn_;
}
inline void WarnMsg::set_warn(bool value) {
  _has_bits_[0] |= 0x00000001u;
  warn_ = value;
  // @@protoc_insertion_point(field_set:perception.WarnMsg.warn)
}

// -------------------------------------------------------------------

// PerceptionMsg

// required .perception.EventId event = 1;
inline bool PerceptionMsg::has_event() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PerceptionMsg::clear_event() {
  event_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::perception::EventId PerceptionMsg::event() const {
  // @@protoc_insertion_point(field_get:perception.PerceptionMsg.event)
  return static_cast< ::perception::EventId >(event_);
}
inline void PerceptionMsg::set_event(::perception::EventId value) {
  assert(::perception::EventId_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  event_ = value;
  // @@protoc_insertion_point(field_set:perception.PerceptionMsg.event)
}

// optional .perception.WarnMsg warn_msg = 2;
inline bool PerceptionMsg::has_warn_msg() const {
  return MsgType_case() == kWarnMsg;
}
inline void PerceptionMsg::set_has_warn_msg() {
  _oneof_case_[0] = kWarnMsg;
}
inline void PerceptionMsg::clear_warn_msg() {
  if (has_warn_msg()) {
    delete MsgType_.warn_msg_;
    clear_has_MsgType();
  }
}
inline ::perception::WarnMsg* PerceptionMsg::release_warn_msg() {
  // @@protoc_insertion_point(field_release:perception.PerceptionMsg.warn_msg)
  if (has_warn_msg()) {
    clear_has_MsgType();
      ::perception::WarnMsg* temp = MsgType_.warn_msg_;
    MsgType_.warn_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::perception::WarnMsg& PerceptionMsg::warn_msg() const {
  // @@protoc_insertion_point(field_get:perception.PerceptionMsg.warn_msg)
  return has_warn_msg()
      ? *MsgType_.warn_msg_
      : *reinterpret_cast< ::perception::WarnMsg*>(&::perception::_WarnMsg_default_instance_);
}
inline ::perception::WarnMsg* PerceptionMsg::mutable_warn_msg() {
  if (!has_warn_msg()) {
    clear_MsgType();
    set_has_warn_msg();
    MsgType_.warn_msg_ = CreateMaybeMessage< ::perception::WarnMsg >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:perception.PerceptionMsg.warn_msg)
  return MsgType_.warn_msg_;
}

// optional .perception.VisibilityMsg visibility_msg = 3;
inline bool PerceptionMsg::has_visibility_msg() const {
  return MsgType_case() == kVisibilityMsg;
}
inline void PerceptionMsg::set_has_visibility_msg() {
  _oneof_case_[0] = kVisibilityMsg;
}
inline void PerceptionMsg::clear_visibility_msg() {
  if (has_visibility_msg()) {
    delete MsgType_.visibility_msg_;
    clear_has_MsgType();
  }
}
inline ::perception::VisibilityMsg* PerceptionMsg::release_visibility_msg() {
  // @@protoc_insertion_point(field_release:perception.PerceptionMsg.visibility_msg)
  if (has_visibility_msg()) {
    clear_has_MsgType();
      ::perception::VisibilityMsg* temp = MsgType_.visibility_msg_;
    MsgType_.visibility_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::perception::VisibilityMsg& PerceptionMsg::visibility_msg() const {
  // @@protoc_insertion_point(field_get:perception.PerceptionMsg.visibility_msg)
  return has_visibility_msg()
      ? *MsgType_.visibility_msg_
      : *reinterpret_cast< ::perception::VisibilityMsg*>(&::perception::_VisibilityMsg_default_instance_);
}
inline ::perception::VisibilityMsg* PerceptionMsg::mutable_visibility_msg() {
  if (!has_visibility_msg()) {
    clear_MsgType();
    set_has_visibility_msg();
    MsgType_.visibility_msg_ = CreateMaybeMessage< ::perception::VisibilityMsg >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:perception.PerceptionMsg.visibility_msg)
  return MsgType_.visibility_msg_;
}

// optional .perception.LaneAreaMsg lane_area_msg = 4;
inline bool PerceptionMsg::has_lane_area_msg() const {
  return MsgType_case() == kLaneAreaMsg;
}
inline void PerceptionMsg::set_has_lane_area_msg() {
  _oneof_case_[0] = kLaneAreaMsg;
}
inline void PerceptionMsg::clear_lane_area_msg() {
  if (has_lane_area_msg()) {
    delete MsgType_.lane_area_msg_;
    clear_has_MsgType();
  }
}
inline ::perception::LaneAreaMsg* PerceptionMsg::release_lane_area_msg() {
  // @@protoc_insertion_point(field_release:perception.PerceptionMsg.lane_area_msg)
  if (has_lane_area_msg()) {
    clear_has_MsgType();
      ::perception::LaneAreaMsg* temp = MsgType_.lane_area_msg_;
    MsgType_.lane_area_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::perception::LaneAreaMsg& PerceptionMsg::lane_area_msg() const {
  // @@protoc_insertion_point(field_get:perception.PerceptionMsg.lane_area_msg)
  return has_lane_area_msg()
      ? *MsgType_.lane_area_msg_
      : *reinterpret_cast< ::perception::LaneAreaMsg*>(&::perception::_LaneAreaMsg_default_instance_);
}
inline ::perception::LaneAreaMsg* PerceptionMsg::mutable_lane_area_msg() {
  if (!has_lane_area_msg()) {
    clear_MsgType();
    set_has_lane_area_msg();
    MsgType_.lane_area_msg_ = CreateMaybeMessage< ::perception::LaneAreaMsg >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:perception.PerceptionMsg.lane_area_msg)
  return MsgType_.lane_area_msg_;
}

// optional .perception.JamMsg jam_msg = 5;
inline bool PerceptionMsg::has_jam_msg() const {
  return MsgType_case() == kJamMsg;
}
inline void PerceptionMsg::set_has_jam_msg() {
  _oneof_case_[0] = kJamMsg;
}
inline void PerceptionMsg::clear_jam_msg() {
  if (has_jam_msg()) {
    delete MsgType_.jam_msg_;
    clear_has_MsgType();
  }
}
inline ::perception::JamMsg* PerceptionMsg::release_jam_msg() {
  // @@protoc_insertion_point(field_release:perception.PerceptionMsg.jam_msg)
  if (has_jam_msg()) {
    clear_has_MsgType();
      ::perception::JamMsg* temp = MsgType_.jam_msg_;
    MsgType_.jam_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::perception::JamMsg& PerceptionMsg::jam_msg() const {
  // @@protoc_insertion_point(field_get:perception.PerceptionMsg.jam_msg)
  return has_jam_msg()
      ? *MsgType_.jam_msg_
      : *reinterpret_cast< ::perception::JamMsg*>(&::perception::_JamMsg_default_instance_);
}
inline ::perception::JamMsg* PerceptionMsg::mutable_jam_msg() {
  if (!has_jam_msg()) {
    clear_MsgType();
    set_has_jam_msg();
    MsgType_.jam_msg_ = CreateMaybeMessage< ::perception::JamMsg >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:perception.PerceptionMsg.jam_msg)
  return MsgType_.jam_msg_;
}

// optional .perception.FlowMsg flow_msg = 6;
inline bool PerceptionMsg::has_flow_msg() const {
  return MsgType_case() == kFlowMsg;
}
inline void PerceptionMsg::set_has_flow_msg() {
  _oneof_case_[0] = kFlowMsg;
}
inline void PerceptionMsg::clear_flow_msg() {
  if (has_flow_msg()) {
    delete MsgType_.flow_msg_;
    clear_has_MsgType();
  }
}
inline ::perception::FlowMsg* PerceptionMsg::release_flow_msg() {
  // @@protoc_insertion_point(field_release:perception.PerceptionMsg.flow_msg)
  if (has_flow_msg()) {
    clear_has_MsgType();
      ::perception::FlowMsg* temp = MsgType_.flow_msg_;
    MsgType_.flow_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::perception::FlowMsg& PerceptionMsg::flow_msg() const {
  // @@protoc_insertion_point(field_get:perception.PerceptionMsg.flow_msg)
  return has_flow_msg()
      ? *MsgType_.flow_msg_
      : *reinterpret_cast< ::perception::FlowMsg*>(&::perception::_FlowMsg_default_instance_);
}
inline ::perception::FlowMsg* PerceptionMsg::mutable_flow_msg() {
  if (!has_flow_msg()) {
    clear_MsgType();
    set_has_flow_msg();
    MsgType_.flow_msg_ = CreateMaybeMessage< ::perception::FlowMsg >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:perception.PerceptionMsg.flow_msg)
  return MsgType_.flow_msg_;
}

// optional .perception.TargetMsg target_msg = 7;
inline bool PerceptionMsg::has_target_msg() const {
  return MsgType_case() == kTargetMsg;
}
inline void PerceptionMsg::set_has_target_msg() {
  _oneof_case_[0] = kTargetMsg;
}
inline void PerceptionMsg::clear_target_msg() {
  if (has_target_msg()) {
    delete MsgType_.target_msg_;
    clear_has_MsgType();
  }
}
inline ::perception::TargetMsg* PerceptionMsg::release_target_msg() {
  // @@protoc_insertion_point(field_release:perception.PerceptionMsg.target_msg)
  if (has_target_msg()) {
    clear_has_MsgType();
      ::perception::TargetMsg* temp = MsgType_.target_msg_;
    MsgType_.target_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::perception::TargetMsg& PerceptionMsg::target_msg() const {
  // @@protoc_insertion_point(field_get:perception.PerceptionMsg.target_msg)
  return has_target_msg()
      ? *MsgType_.target_msg_
      : *reinterpret_cast< ::perception::TargetMsg*>(&::perception::_TargetMsg_default_instance_);
}
inline ::perception::TargetMsg* PerceptionMsg::mutable_target_msg() {
  if (!has_target_msg()) {
    clear_MsgType();
    set_has_target_msg();
    MsgType_.target_msg_ = CreateMaybeMessage< ::perception::TargetMsg >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:perception.PerceptionMsg.target_msg)
  return MsgType_.target_msg_;
}

// optional .perception.Timestamp time = 8;
inline bool PerceptionMsg::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PerceptionMsg::clear_time() {
  if (time_ != nullptr) time_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::perception::Timestamp& PerceptionMsg::time() const {
  const ::perception::Timestamp* p = time_;
  // @@protoc_insertion_point(field_get:perception.PerceptionMsg.time)
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::Timestamp*>(
      &::perception::_Timestamp_default_instance_);
}
inline ::perception::Timestamp* PerceptionMsg::release_time() {
  // @@protoc_insertion_point(field_release:perception.PerceptionMsg.time)
  _has_bits_[0] &= ~0x00000001u;
  ::perception::Timestamp* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::perception::Timestamp* PerceptionMsg::mutable_time() {
  _has_bits_[0] |= 0x00000001u;
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::Timestamp>(GetArenaNoVirtual());
    time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:perception.PerceptionMsg.time)
  return time_;
}
inline void PerceptionMsg::set_allocated_time(::perception::Timestamp* time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete time_;
  }
  if (time) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:perception.PerceptionMsg.time)
}

inline bool PerceptionMsg::has_MsgType() const {
  return MsgType_case() != MSGTYPE_NOT_SET;
}
inline void PerceptionMsg::clear_has_MsgType() {
  _oneof_case_[0] = MSGTYPE_NOT_SET;
}
inline PerceptionMsg::MsgTypeCase PerceptionMsg::MsgType_case() const {
  return PerceptionMsg::MsgTypeCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace perception

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perception::Flow_TrafficSig> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::Flow_TrafficSig>() {
  return ::perception::Flow_TrafficSig_descriptor();
}
template <> struct is_proto_enum< ::perception::Version> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::Version>() {
  return ::perception::Version_descriptor();
}
template <> struct is_proto_enum< ::perception::EventId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::EventId>() {
  return ::perception::EventId_descriptor();
}
template <> struct is_proto_enum< ::perception::Source> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::Source>() {
  return ::perception::Source_descriptor();
}
template <> struct is_proto_enum< ::perception::TargetType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::TargetType>() {
  return ::perception::TargetType_descriptor();
}
template <> struct is_proto_enum< ::perception::CarType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::CarType>() {
  return ::perception::CarType_descriptor();
}
template <> struct is_proto_enum< ::perception::CarStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::CarStatus>() {
  return ::perception::CarStatus_descriptor();
}
template <> struct is_proto_enum< ::perception::WareType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::WareType>() {
  return ::perception::WareType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_perception_2eproto
