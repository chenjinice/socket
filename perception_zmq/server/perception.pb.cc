// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perception.proto

#include "perception.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_perception_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Flow_perception_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_perception_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Jam_perception_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_perception_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_LaneInfoEx_perception_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_perception_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Position_perception_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_perception_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Size_perception_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_perception_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Timestamp_perception_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_perception_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_VisibilityMsg_perception_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_perception_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_WarnMsg_perception_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_perception_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_JamMsg_perception_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_perception_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_LaneAreaMsg_perception_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_perception_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_LaneArea_perception_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_perception_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_TargetMsg_perception_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_perception_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_FlowMsg_perception_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_perception_2eproto ::google::protobuf::internal::SCCInfo<3> scc_info_Target_perception_2eproto;
namespace perception {
class PositionDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Position> _instance;
} _Position_default_instance_;
class TimestampDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Timestamp> _instance;
} _Timestamp_default_instance_;
class SizeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Size> _instance;
} _Size_default_instance_;
class LaneInfoExDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<LaneInfoEx> _instance;
} _LaneInfoEx_default_instance_;
class LaneAreaDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<LaneArea> _instance;
} _LaneArea_default_instance_;
class JamDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Jam> _instance;
} _Jam_default_instance_;
class FlowDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Flow> _instance;
} _Flow_default_instance_;
class TargetDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Target> _instance;
} _Target_default_instance_;
class VisibilityMsgDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<VisibilityMsg> _instance;
} _VisibilityMsg_default_instance_;
class LaneAreaMsgDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<LaneAreaMsg> _instance;
} _LaneAreaMsg_default_instance_;
class JamMsgDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<JamMsg> _instance;
} _JamMsg_default_instance_;
class FlowMsgDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<FlowMsg> _instance;
} _FlowMsg_default_instance_;
class TargetMsgDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TargetMsg> _instance;
} _TargetMsg_default_instance_;
class WarnMsgDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<WarnMsg> _instance;
} _WarnMsg_default_instance_;
class PerceptionMsgDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<PerceptionMsg> _instance;
  const ::perception::WarnMsg* warn_msg_;
  const ::perception::VisibilityMsg* visibility_msg_;
  const ::perception::LaneAreaMsg* lane_area_msg_;
  const ::perception::JamMsg* jam_msg_;
  const ::perception::FlowMsg* flow_msg_;
  const ::perception::TargetMsg* target_msg_;
} _PerceptionMsg_default_instance_;
}  // namespace perception
static void InitDefaultsPosition_perception_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perception::_Position_default_instance_;
    new (ptr) ::perception::Position();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perception::Position::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Position_perception_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsPosition_perception_2eproto}, {}};

static void InitDefaultsTimestamp_perception_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perception::_Timestamp_default_instance_;
    new (ptr) ::perception::Timestamp();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perception::Timestamp::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Timestamp_perception_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsTimestamp_perception_2eproto}, {}};

static void InitDefaultsSize_perception_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perception::_Size_default_instance_;
    new (ptr) ::perception::Size();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perception::Size::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Size_perception_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsSize_perception_2eproto}, {}};

static void InitDefaultsLaneInfoEx_perception_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perception::_LaneInfoEx_default_instance_;
    new (ptr) ::perception::LaneInfoEx();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perception::LaneInfoEx::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_LaneInfoEx_perception_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsLaneInfoEx_perception_2eproto}, {}};

static void InitDefaultsLaneArea_perception_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perception::_LaneArea_default_instance_;
    new (ptr) ::perception::LaneArea();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perception::LaneArea::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_LaneArea_perception_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsLaneArea_perception_2eproto}, {
      &scc_info_Position_perception_2eproto.base,}};

static void InitDefaultsJam_perception_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perception::_Jam_default_instance_;
    new (ptr) ::perception::Jam();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perception::Jam::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Jam_perception_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsJam_perception_2eproto}, {}};

static void InitDefaultsFlow_perception_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perception::_Flow_default_instance_;
    new (ptr) ::perception::Flow();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perception::Flow::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Flow_perception_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsFlow_perception_2eproto}, {}};

static void InitDefaultsTarget_perception_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perception::_Target_default_instance_;
    new (ptr) ::perception::Target();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perception::Target::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<3> scc_info_Target_perception_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 3, InitDefaultsTarget_perception_2eproto}, {
      &scc_info_Position_perception_2eproto.base,
      &scc_info_Size_perception_2eproto.base,
      &scc_info_LaneInfoEx_perception_2eproto.base,}};

static void InitDefaultsVisibilityMsg_perception_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perception::_VisibilityMsg_default_instance_;
    new (ptr) ::perception::VisibilityMsg();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perception::VisibilityMsg::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_VisibilityMsg_perception_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsVisibilityMsg_perception_2eproto}, {}};

static void InitDefaultsLaneAreaMsg_perception_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perception::_LaneAreaMsg_default_instance_;
    new (ptr) ::perception::LaneAreaMsg();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perception::LaneAreaMsg::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_LaneAreaMsg_perception_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsLaneAreaMsg_perception_2eproto}, {
      &scc_info_LaneArea_perception_2eproto.base,}};

static void InitDefaultsJamMsg_perception_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perception::_JamMsg_default_instance_;
    new (ptr) ::perception::JamMsg();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perception::JamMsg::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_JamMsg_perception_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsJamMsg_perception_2eproto}, {
      &scc_info_Jam_perception_2eproto.base,}};

static void InitDefaultsFlowMsg_perception_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perception::_FlowMsg_default_instance_;
    new (ptr) ::perception::FlowMsg();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perception::FlowMsg::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_FlowMsg_perception_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsFlowMsg_perception_2eproto}, {
      &scc_info_Flow_perception_2eproto.base,
      &scc_info_Timestamp_perception_2eproto.base,}};

static void InitDefaultsTargetMsg_perception_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perception::_TargetMsg_default_instance_;
    new (ptr) ::perception::TargetMsg();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perception::TargetMsg::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_TargetMsg_perception_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsTargetMsg_perception_2eproto}, {
      &scc_info_Target_perception_2eproto.base,}};

static void InitDefaultsWarnMsg_perception_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perception::_WarnMsg_default_instance_;
    new (ptr) ::perception::WarnMsg();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perception::WarnMsg::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_WarnMsg_perception_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsWarnMsg_perception_2eproto}, {}};

static void InitDefaultsPerceptionMsg_perception_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::perception::_PerceptionMsg_default_instance_;
    new (ptr) ::perception::PerceptionMsg();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::perception::PerceptionMsg::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<7> scc_info_PerceptionMsg_perception_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 7, InitDefaultsPerceptionMsg_perception_2eproto}, {
      &scc_info_WarnMsg_perception_2eproto.base,
      &scc_info_VisibilityMsg_perception_2eproto.base,
      &scc_info_LaneAreaMsg_perception_2eproto.base,
      &scc_info_JamMsg_perception_2eproto.base,
      &scc_info_FlowMsg_perception_2eproto.base,
      &scc_info_TargetMsg_perception_2eproto.base,
      &scc_info_Timestamp_perception_2eproto.base,}};

void InitDefaults_perception_2eproto() {
  ::google::protobuf::internal::InitSCC(&scc_info_Position_perception_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Timestamp_perception_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Size_perception_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_LaneInfoEx_perception_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_LaneArea_perception_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Jam_perception_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Flow_perception_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Target_perception_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_VisibilityMsg_perception_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_LaneAreaMsg_perception_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_JamMsg_perception_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_FlowMsg_perception_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_TargetMsg_perception_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_WarnMsg_perception_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_PerceptionMsg_perception_2eproto.base);
}

static ::google::protobuf::Metadata file_level_metadata_perception_2eproto[15];
static const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors_perception_2eproto[8];
static constexpr ::google::protobuf::ServiceDescriptor const** file_level_service_descriptors_perception_2eproto = nullptr;

const ::google::protobuf::uint32 TableStruct_perception_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::perception::Position, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::perception::Position, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::perception::Position, lon_),
  PROTOBUF_FIELD_OFFSET(::perception::Position, lat_),
  PROTOBUF_FIELD_OFFSET(::perception::Position, elevation_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::perception::Timestamp, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::perception::Timestamp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::perception::Timestamp, seconds_),
  PROTOBUF_FIELD_OFFSET(::perception::Timestamp, nanos_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::perception::Size, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::perception::Size, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::perception::Size, length_),
  PROTOBUF_FIELD_OFFSET(::perception::Size, width_),
  PROTOBUF_FIELD_OFFSET(::perception::Size, height_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::perception::LaneInfoEx, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::perception::LaneInfoEx, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::perception::LaneInfoEx, lane_info_),
  PROTOBUF_FIELD_OFFSET(::perception::LaneInfoEx, lane_id_),
  PROTOBUF_FIELD_OFFSET(::perception::LaneInfoEx, lane_count_),
  PROTOBUF_FIELD_OFFSET(::perception::LaneInfoEx, lane_heading_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::perception::LaneArea, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::perception::LaneArea, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::perception::LaneArea, pos_),
  PROTOBUF_FIELD_OFFSET(::perception::LaneArea, camera_),
  PROTOBUF_FIELD_OFFSET(::perception::LaneArea, lane_id_),
  PROTOBUF_FIELD_OFFSET(::perception::LaneArea, lane_heading_),
  PROTOBUF_FIELD_OFFSET(::perception::LaneArea, ware_),
  ~0u,
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::perception::Jam, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::perception::Jam, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::perception::Jam, vehicle_num_),
  PROTOBUF_FIELD_OFFSET(::perception::Jam, vehicle_velocity_),
  PROTOBUF_FIELD_OFFSET(::perception::Jam, lane_heading_),
  PROTOBUF_FIELD_OFFSET(::perception::Jam, vehicle_flow_),
  PROTOBUF_FIELD_OFFSET(::perception::Jam, lane_id_),
  0,
  1,
  2,
  ~0u,
  3,
  PROTOBUF_FIELD_OFFSET(::perception::Flow, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::perception::Flow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::perception::Flow, camera_),
  PROTOBUF_FIELD_OFFSET(::perception::Flow, vehicle_num_),
  PROTOBUF_FIELD_OFFSET(::perception::Flow, pass_num_),
  PROTOBUF_FIELD_OFFSET(::perception::Flow, signal_),
  0,
  ~0u,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::perception::Target, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::perception::Target, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::perception::Target, id_),
  PROTOBUF_FIELD_OFFSET(::perception::Target, type_),
  PROTOBUF_FIELD_OFFSET(::perception::Target, pos_),
  PROTOBUF_FIELD_OFFSET(::perception::Target, camera_),
  PROTOBUF_FIELD_OFFSET(::perception::Target, velocity_),
  PROTOBUF_FIELD_OFFSET(::perception::Target, heading_),
  PROTOBUF_FIELD_OFFSET(::perception::Target, distance_),
  PROTOBUF_FIELD_OFFSET(::perception::Target, size_),
  PROTOBUF_FIELD_OFFSET(::perception::Target, approach_judge_),
  PROTOBUF_FIELD_OFFSET(::perception::Target, source_),
  PROTOBUF_FIELD_OFFSET(::perception::Target, capture_id_),
  PROTOBUF_FIELD_OFFSET(::perception::Target, in_lane_),
  PROTOBUF_FIELD_OFFSET(::perception::Target, lane_id_),
  PROTOBUF_FIELD_OFFSET(::perception::Target, lane_heading_),
  PROTOBUF_FIELD_OFFSET(::perception::Target, lane_type_),
  PROTOBUF_FIELD_OFFSET(::perception::Target, lane_ex_),
  PROTOBUF_FIELD_OFFSET(::perception::Target, license_plate_),
  PROTOBUF_FIELD_OFFSET(::perception::Target, car_type_),
  PROTOBUF_FIELD_OFFSET(::perception::Target, car_status_),
  PROTOBUF_FIELD_OFFSET(::perception::Target, confidence_),
  PROTOBUF_FIELD_OFFSET(::perception::Target, rcs_),
  4,
  5,
  1,
  6,
  7,
  8,
  9,
  2,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  3,
  0,
  17,
  18,
  19,
  20,
  PROTOBUF_FIELD_OFFSET(::perception::VisibilityMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::perception::VisibilityMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::perception::VisibilityMsg, distance_),
  PROTOBUF_FIELD_OFFSET(::perception::VisibilityMsg, level_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::perception::LaneAreaMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::perception::LaneAreaMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::perception::LaneAreaMsg, area_),
  ~0u,
  PROTOBUF_FIELD_OFFSET(::perception::JamMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::perception::JamMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::perception::JamMsg, jam_),
  ~0u,
  PROTOBUF_FIELD_OFFSET(::perception::FlowMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::perception::FlowMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::perception::FlowMsg, flow_),
  PROTOBUF_FIELD_OFFSET(::perception::FlowMsg, time_begin_),
  PROTOBUF_FIELD_OFFSET(::perception::FlowMsg, time_end_),
  ~0u,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::perception::TargetMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::perception::TargetMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::perception::TargetMsg, target_),
  ~0u,
  PROTOBUF_FIELD_OFFSET(::perception::WarnMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::perception::WarnMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::perception::WarnMsg, warn_),
  0,
  PROTOBUF_FIELD_OFFSET(::perception::PerceptionMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::perception::PerceptionMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::perception::PerceptionMsg, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::perception::PerceptionMsg, event_),
  offsetof(::perception::PerceptionMsgDefaultTypeInternal, warn_msg_),
  offsetof(::perception::PerceptionMsgDefaultTypeInternal, visibility_msg_),
  offsetof(::perception::PerceptionMsgDefaultTypeInternal, lane_area_msg_),
  offsetof(::perception::PerceptionMsgDefaultTypeInternal, jam_msg_),
  offsetof(::perception::PerceptionMsgDefaultTypeInternal, flow_msg_),
  offsetof(::perception::PerceptionMsgDefaultTypeInternal, target_msg_),
  PROTOBUF_FIELD_OFFSET(::perception::PerceptionMsg, time_),
  PROTOBUF_FIELD_OFFSET(::perception::PerceptionMsg, MsgType_),
  1,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, sizeof(::perception::Position)},
  { 11, 18, sizeof(::perception::Timestamp)},
  { 20, 28, sizeof(::perception::Size)},
  { 31, 40, sizeof(::perception::LaneInfoEx)},
  { 44, 54, sizeof(::perception::LaneArea)},
  { 59, 69, sizeof(::perception::Jam)},
  { 74, 83, sizeof(::perception::Flow)},
  { 87, 113, sizeof(::perception::Target)},
  { 134, 141, sizeof(::perception::VisibilityMsg)},
  { 143, 149, sizeof(::perception::LaneAreaMsg)},
  { 150, 156, sizeof(::perception::JamMsg)},
  { 157, 165, sizeof(::perception::FlowMsg)},
  { 168, 174, sizeof(::perception::TargetMsg)},
  { 175, 181, sizeof(::perception::WarnMsg)},
  { 182, 196, sizeof(::perception::PerceptionMsg)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::perception::_Position_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::perception::_Timestamp_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::perception::_Size_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::perception::_LaneInfoEx_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::perception::_LaneArea_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::perception::_Jam_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::perception::_Flow_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::perception::_Target_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::perception::_VisibilityMsg_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::perception::_LaneAreaMsg_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::perception::_JamMsg_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::perception::_FlowMsg_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::perception::_TargetMsg_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::perception::_WarnMsg_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::perception::_PerceptionMsg_default_instance_),
};

static ::google::protobuf::internal::AssignDescriptorsTable assign_descriptors_table_perception_2eproto = {
  {}, AddDescriptors_perception_2eproto, "perception.proto", schemas,
  file_default_instances, TableStruct_perception_2eproto::offsets,
  file_level_metadata_perception_2eproto, 15, file_level_enum_descriptors_perception_2eproto, file_level_service_descriptors_perception_2eproto,
};

const char descriptor_table_protodef_perception_2eproto[] =
  "\n\020perception.proto\022\nperception\"7\n\010Positi"
  "on\022\013\n\003lon\030\001 \002(\005\022\013\n\003lat\030\002 \002(\005\022\021\n\televatio"
  "n\030\003 \001(\002\"+\n\tTimestamp\022\017\n\007seconds\030\001 \002(\003\022\r\n"
  "\005nanos\030\002 \002(\005\"5\n\004Size\022\016\n\006length\030\001 \002(\002\022\r\n\005"
  "width\030\002 \002(\002\022\016\n\006height\030\003 \002(\002\"Z\n\nLaneInfoE"
  "x\022\021\n\tlane_info\030\001 \002(\005\022\017\n\007lane_id\030\002 \002(\005\022\022\n"
  "\nlane_count\030\003 \002(\005\022\024\n\014lane_heading\030\004 \002(\002\""
  "\210\001\n\010LaneArea\022!\n\003pos\030\001 \003(\0132\024.perception.P"
  "osition\022\016\n\006camera\030\002 \001(\005\022\017\n\007lane_id\030\003 \001(\005"
  "\022\024\n\014lane_heading\030\004 \001(\002\022\"\n\004ware\030\005 \001(\0162\024.p"
  "erception.WareType\"q\n\003Jam\022\023\n\013vehicle_num"
  "\030\001 \002(\r\022\030\n\020vehicle_velocity\030\002 \002(\002\022\024\n\014lane"
  "_heading\030\003 \002(\002\022\024\n\014vehicle_flow\030\004 \003(\005\022\017\n\007"
  "lane_id\030\005 \001(\005\"\230\001\n\004Flow\022\016\n\006camera\030\001 \001(\005\022\023"
  "\n\013vehicle_num\030\002 \003(\005\022\020\n\010pass_num\030\003 \003(\005\022+\n"
  "\006signal\030\004 \001(\0162\033.perception.Flow.TrafficS"
  "ig\",\n\nTrafficSig\022\013\n\007UNKNOWN\020\000\022\007\n\003Y2G\020\001\022\010"
  "\n\004OVER\020\002\"\220\004\n\006Target\022\n\n\002id\030\001 \002(\005\022$\n\004type\030"
  "\002 \002(\0162\026.perception.TargetType\022!\n\003pos\030\003 \002"
  "(\0132\024.perception.Position\022\016\n\006camera\030\004 \001(\005"
  "\022\020\n\010velocity\030\005 \001(\002\022\017\n\007heading\030\006 \001(\002\022\020\n\010d"
  "istance\030\007 \001(\002\022\036\n\004size\030\010 \001(\0132\020.perception"
  ".Size\022\026\n\016approach_judge\030\t \001(\005\022\"\n\006source\030"
  "\n \001(\0162\022.perception.Source\022\022\n\ncapture_id\030"
  "\013 \001(\005\022\017\n\007in_lane\030\014 \001(\010\022\017\n\007lane_id\030\r \001(\005\022"
  "\024\n\014lane_heading\030\016 \001(\002\022\021\n\tlane_type\030\017 \001(\005"
  "\022\'\n\007lane_ex\030\020 \001(\0132\026.perception.LaneInfoE"
  "x\022\025\n\rlicense_plate\030\021 \001(\t\022%\n\010car_type\030\022 \001"
  "(\0162\023.perception.CarType\022)\n\ncar_status\030\023 "
  "\001(\0162\025.perception.CarStatus\022\022\n\nconfidence"
  "\030\024 \001(\002\022\013\n\003rcs\030\025 \001(\002\"0\n\rVisibilityMsg\022\020\n\010"
  "distance\030\002 \002(\002\022\r\n\005level\030\003 \002(\005\"1\n\013LaneAre"
  "aMsg\022\"\n\004area\030\001 \003(\0132\024.perception.LaneArea"
  "\"&\n\006JamMsg\022\034\n\003jam\030\001 \003(\0132\017.perception.Jam"
  "\"}\n\007FlowMsg\022\036\n\004flow\030\001 \003(\0132\020.perception.F"
  "low\022)\n\ntime_begin\030\002 \001(\0132\025.perception.Tim"
  "estamp\022\'\n\010time_end\030\003 \001(\0132\025.perception.Ti"
  "mestamp\"/\n\tTargetMsg\022\"\n\006target\030\002 \003(\0132\022.p"
  "erception.Target\"\027\n\007WarnMsg\022\014\n\004warn\030\001 \002("
  "\010\"\360\002\n\rPerceptionMsg\022\"\n\005event\030\001 \002(\0162\023.per"
  "ception.EventId\022\'\n\010warn_msg\030\002 \001(\0132\023.perc"
  "eption.WarnMsgH\000\0223\n\016visibility_msg\030\003 \001(\013"
  "2\031.perception.VisibilityMsgH\000\0220\n\rlane_ar"
  "ea_msg\030\004 \001(\0132\027.perception.LaneAreaMsgH\000\022"
  "%\n\007jam_msg\030\005 \001(\0132\022.perception.JamMsgH\000\022\'"
  "\n\010flow_msg\030\006 \001(\0132\023.perception.FlowMsgH\000\022"
  "+\n\ntarget_msg\030\007 \001(\0132\025.perception.TargetM"
  "sgH\000\022#\n\004time\030\010 \001(\0132\025.perception.Timestam"
  "pB\t\n\007MsgType*\031\n\007Version\022\016\n\007VERSION\020\232\371\320\t*"
  "\325\002\n\007EventId\022\016\n\nEVENT_NONE\020\000\022\016\n\nPEDESTRIA"
  "N\020\001\022\016\n\nILLEGAL_V1\020\002\022\016\n\nVISIBILITY\020\003\022\022\n\016A"
  "VAILABLE_AREA\020\004\022\020\n\014ABNORMAL_CAR\020\005\022\016\n\nILL"
  "EGAL_V2\020\006\022\022\n\016TRAFFIC_STATUS\020\007\022\024\n\020BACKWAR"
  "D_DRIVING\020\010\022\017\n\013ROAD_DANGER\020\t\022\016\n\nFIRE_SMO"
  "KE\020\n\022\024\n\020TARGET_TO_FUSION\020\013\022\017\n\013TRAFFIC_JA"
  "M\020\014\022\020\n\014TRAFFIC_FLOW\020\r\022\016\n\nSPECIALCAR\020\016\022\014\n"
  "\010ACCIDENT\020\017\022\013\n\007ICEWARN\020\020\022\r\n\tLANE_WARE\020\021\022"
  "\014\n\010SPEEDING\020\022\022\010\n\004SNAP\020\023*=\n\006Source\022\010\n\004Non"
  "e\020\000\022\t\n\005RADAR\020\001\022\n\n\006VISION\020\002\022\t\n\005LIDAR\020\003\022\007\n"
  "\003V2X\020\004*Z\n\nTargetType\022\n\n\006OTHERS\020\000\022\t\n\005HUMA"
  "N\020\001\022\013\n\007VEHICLE\020\002\022\016\n\nMOTORCYCLE\020\003\022\n\n\006ANIM"
  "AL\020\004\022\014\n\010OBSTACLE\020\005*R\n\007CarType\022\n\n\006NORMAL\020"
  "\000\022\r\n\tAMBULANCE\020\001\022\r\n\tDANGERCAR\020\002\022\016\n\nFIREE"
  "NGINE\020\003\022\r\n\tPOLICECAR\020\004*\271\001\n\tCarStatus\022\021\n\r"
  "STATUS_NORMAL\020\000\022\016\n\nRETROGRADE\020\001\022\021\n\rOVER_"
  "SPEEDING\020\002\022\020\n\014LOW_SPEEDING\020\003\022\023\n\017ILLEGAL_"
  "PARKING\020\004\022\020\n\014LANE_PARKING\020\005\022\020\n\014AREA_PARK"
  "ING\020\006\022\030\n\024CONTINUOUS_DIVERSION\020\007\022\021\n\rLINE_"
  "PRESSING\020\010*M\n\010WareType\022\r\n\tWARE_NONE\020\000\022\014\n"
  "\010FULLLINE\020\001\022\016\n\nDOTTEDLINE\020\002\022\024\n\020DOUBLEYEL"
  "LOWLINE\020\003"
  ;
static ::google::protobuf::internal::DescriptorTable descriptor_table_perception_2eproto = {
  false, InitDefaults_perception_2eproto, 
  descriptor_table_protodef_perception_2eproto,
  "perception.proto", &assign_descriptors_table_perception_2eproto, 2809,
};

void AddDescriptors_perception_2eproto() {
  static constexpr ::google::protobuf::internal::InitFunc deps[1] =
  {
  };
 ::google::protobuf::internal::AddDescriptors(&descriptor_table_perception_2eproto, deps, 0);
}

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_perception_2eproto = []() { AddDescriptors_perception_2eproto(); return true; }();
namespace perception {
const ::google::protobuf::EnumDescriptor* Flow_TrafficSig_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_perception_2eproto);
  return file_level_enum_descriptors_perception_2eproto[0];
}
bool Flow_TrafficSig_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Flow_TrafficSig Flow::UNKNOWN;
constexpr Flow_TrafficSig Flow::Y2G;
constexpr Flow_TrafficSig Flow::OVER;
constexpr Flow_TrafficSig Flow::TrafficSig_MIN;
constexpr Flow_TrafficSig Flow::TrafficSig_MAX;
constexpr int Flow::TrafficSig_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::google::protobuf::EnumDescriptor* Version_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_perception_2eproto);
  return file_level_enum_descriptors_perception_2eproto[1];
}
bool Version_IsValid(int value) {
  switch (value) {
    case 20200602:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EventId_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_perception_2eproto);
  return file_level_enum_descriptors_perception_2eproto[2];
}
bool EventId_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* Source_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_perception_2eproto);
  return file_level_enum_descriptors_perception_2eproto[3];
}
bool Source_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TargetType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_perception_2eproto);
  return file_level_enum_descriptors_perception_2eproto[4];
}
bool TargetType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* CarType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_perception_2eproto);
  return file_level_enum_descriptors_perception_2eproto[5];
}
bool CarType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* CarStatus_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_perception_2eproto);
  return file_level_enum_descriptors_perception_2eproto[6];
}
bool CarStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* WareType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_perception_2eproto);
  return file_level_enum_descriptors_perception_2eproto[7];
}
bool WareType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void Position::InitAsDefaultInstance() {
}
class Position::HasBitSetters {
 public:
  static void set_has_lon(Position* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_lat(Position* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_elevation(Position* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Position::kLonFieldNumber;
const int Position::kLatFieldNumber;
const int Position::kElevationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Position::Position()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perception.Position)
}
Position::Position(const Position& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&lon_, &from.lon_,
    static_cast<size_t>(reinterpret_cast<char*>(&elevation_) -
    reinterpret_cast<char*>(&lon_)) + sizeof(elevation_));
  // @@protoc_insertion_point(copy_constructor:perception.Position)
}

void Position::SharedCtor() {
  ::memset(&lon_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&elevation_) -
      reinterpret_cast<char*>(&lon_)) + sizeof(elevation_));
}

Position::~Position() {
  // @@protoc_insertion_point(destructor:perception.Position)
  SharedDtor();
}

void Position::SharedDtor() {
}

void Position::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Position& Position::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Position_perception_2eproto.base);
  return *internal_default_instance();
}


void Position::Clear() {
// @@protoc_insertion_point(message_clear_start:perception.Position)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&lon_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&elevation_) -
        reinterpret_cast<char*>(&lon_)) + sizeof(elevation_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Position::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 lon = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_lon(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lat = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        set_lat(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional float elevation = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        set_elevation(::google::protobuf::internal::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Position::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:perception.Position)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 lon = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_lon(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lon_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lat = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_lat(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lat_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float elevation = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_elevation(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &elevation_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perception.Position)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perception.Position)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Position::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perception.Position)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 lon = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->lon(), output);
  }

  // required int32 lat = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->lat(), output);
  }

  // optional float elevation = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->elevation(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:perception.Position)
}

::google::protobuf::uint8* Position::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:perception.Position)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 lon = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->lon(), target);
  }

  // required int32 lat = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->lat(), target);
  }

  // optional float elevation = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->elevation(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perception.Position)
  return target;
}

size_t Position::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:perception.Position)
  size_t total_size = 0;

  if (has_lon()) {
    // required int32 lon = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lon());
  }

  if (has_lat()) {
    // required int32 lat = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat());
  }

  return total_size;
}
size_t Position::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perception.Position)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int32 lon = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lon());

    // required int32 lat = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lat());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional float elevation = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Position::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:perception.Position)
  GOOGLE_DCHECK_NE(&from, this);
  const Position* source =
      ::google::protobuf::DynamicCastToGenerated<Position>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:perception.Position)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:perception.Position)
    MergeFrom(*source);
  }
}

void Position::MergeFrom(const Position& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perception.Position)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      lon_ = from.lon_;
    }
    if (cached_has_bits & 0x00000002u) {
      lat_ = from.lat_;
    }
    if (cached_has_bits & 0x00000004u) {
      elevation_ = from.elevation_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Position::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:perception.Position)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Position::CopyFrom(const Position& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perception.Position)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Position::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void Position::Swap(Position* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Position::InternalSwap(Position* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(lon_, other->lon_);
  swap(lat_, other->lat_);
  swap(elevation_, other->elevation_);
}

::google::protobuf::Metadata Position::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_perception_2eproto);
  return ::file_level_metadata_perception_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Timestamp::InitAsDefaultInstance() {
}
class Timestamp::HasBitSetters {
 public:
  static void set_has_seconds(Timestamp* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_nanos(Timestamp* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Timestamp::kSecondsFieldNumber;
const int Timestamp::kNanosFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Timestamp::Timestamp()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perception.Timestamp)
}
Timestamp::Timestamp(const Timestamp& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&seconds_, &from.seconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&nanos_) -
    reinterpret_cast<char*>(&seconds_)) + sizeof(nanos_));
  // @@protoc_insertion_point(copy_constructor:perception.Timestamp)
}

void Timestamp::SharedCtor() {
  ::memset(&seconds_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&nanos_) -
      reinterpret_cast<char*>(&seconds_)) + sizeof(nanos_));
}

Timestamp::~Timestamp() {
  // @@protoc_insertion_point(destructor:perception.Timestamp)
  SharedDtor();
}

void Timestamp::SharedDtor() {
}

void Timestamp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Timestamp& Timestamp::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Timestamp_perception_2eproto.base);
  return *internal_default_instance();
}


void Timestamp::Clear() {
// @@protoc_insertion_point(message_clear_start:perception.Timestamp)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&seconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nanos_) -
        reinterpret_cast<char*>(&seconds_)) + sizeof(nanos_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Timestamp::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int64 seconds = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_seconds(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 nanos = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        set_nanos(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Timestamp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:perception.Timestamp)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 seconds = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_seconds(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &seconds_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 nanos = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_nanos(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nanos_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perception.Timestamp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perception.Timestamp)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Timestamp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perception.Timestamp)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 seconds = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->seconds(), output);
  }

  // required int32 nanos = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->nanos(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:perception.Timestamp)
}

::google::protobuf::uint8* Timestamp::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:perception.Timestamp)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 seconds = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->seconds(), target);
  }

  // required int32 nanos = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->nanos(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perception.Timestamp)
  return target;
}

size_t Timestamp::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:perception.Timestamp)
  size_t total_size = 0;

  if (has_seconds()) {
    // required int64 seconds = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->seconds());
  }

  if (has_nanos()) {
    // required int32 nanos = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->nanos());
  }

  return total_size;
}
size_t Timestamp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perception.Timestamp)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int64 seconds = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->seconds());

    // required int32 nanos = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->nanos());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Timestamp::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:perception.Timestamp)
  GOOGLE_DCHECK_NE(&from, this);
  const Timestamp* source =
      ::google::protobuf::DynamicCastToGenerated<Timestamp>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:perception.Timestamp)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:perception.Timestamp)
    MergeFrom(*source);
  }
}

void Timestamp::MergeFrom(const Timestamp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perception.Timestamp)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      seconds_ = from.seconds_;
    }
    if (cached_has_bits & 0x00000002u) {
      nanos_ = from.nanos_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Timestamp::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:perception.Timestamp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Timestamp::CopyFrom(const Timestamp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perception.Timestamp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Timestamp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void Timestamp::Swap(Timestamp* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Timestamp::InternalSwap(Timestamp* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(seconds_, other->seconds_);
  swap(nanos_, other->nanos_);
}

::google::protobuf::Metadata Timestamp::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_perception_2eproto);
  return ::file_level_metadata_perception_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Size::InitAsDefaultInstance() {
}
class Size::HasBitSetters {
 public:
  static void set_has_length(Size* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_width(Size* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_height(Size* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Size::kLengthFieldNumber;
const int Size::kWidthFieldNumber;
const int Size::kHeightFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Size::Size()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perception.Size)
}
Size::Size(const Size& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&length_, &from.length_,
    static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&length_)) + sizeof(height_));
  // @@protoc_insertion_point(copy_constructor:perception.Size)
}

void Size::SharedCtor() {
  ::memset(&length_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&height_) -
      reinterpret_cast<char*>(&length_)) + sizeof(height_));
}

Size::~Size() {
  // @@protoc_insertion_point(destructor:perception.Size)
  SharedDtor();
}

void Size::SharedDtor() {
}

void Size::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Size& Size::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Size_perception_2eproto.base);
  return *internal_default_instance();
}


void Size::Clear() {
// @@protoc_insertion_point(message_clear_start:perception.Size)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&length_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&height_) -
        reinterpret_cast<char*>(&length_)) + sizeof(height_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Size::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required float length = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 13) goto handle_unusual;
        set_length(::google::protobuf::internal::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // required float width = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        set_width(::google::protobuf::internal::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // required float height = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        set_height(::google::protobuf::internal::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Size::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:perception.Size)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float length = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (13 & 0xFF)) {
          HasBitSetters::set_has_length(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float width = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_width(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &width_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float height = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_height(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &height_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perception.Size)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perception.Size)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Size::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perception.Size)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required float length = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->length(), output);
  }

  // required float width = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->width(), output);
  }

  // required float height = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->height(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:perception.Size)
}

::google::protobuf::uint8* Size::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:perception.Size)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required float length = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->length(), target);
  }

  // required float width = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->width(), target);
  }

  // required float height = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->height(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perception.Size)
  return target;
}

size_t Size::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:perception.Size)
  size_t total_size = 0;

  if (has_length()) {
    // required float length = 1;
    total_size += 1 + 4;
  }

  if (has_width()) {
    // required float width = 2;
    total_size += 1 + 4;
  }

  if (has_height()) {
    // required float height = 3;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t Size::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perception.Size)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required float length = 1;
    total_size += 1 + 4;

    // required float width = 2;
    total_size += 1 + 4;

    // required float height = 3;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Size::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:perception.Size)
  GOOGLE_DCHECK_NE(&from, this);
  const Size* source =
      ::google::protobuf::DynamicCastToGenerated<Size>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:perception.Size)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:perception.Size)
    MergeFrom(*source);
  }
}

void Size::MergeFrom(const Size& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perception.Size)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      length_ = from.length_;
    }
    if (cached_has_bits & 0x00000002u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000004u) {
      height_ = from.height_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Size::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:perception.Size)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Size::CopyFrom(const Size& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perception.Size)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Size::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  return true;
}

void Size::Swap(Size* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Size::InternalSwap(Size* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(length_, other->length_);
  swap(width_, other->width_);
  swap(height_, other->height_);
}

::google::protobuf::Metadata Size::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_perception_2eproto);
  return ::file_level_metadata_perception_2eproto[kIndexInFileMessages];
}


// ===================================================================

void LaneInfoEx::InitAsDefaultInstance() {
}
class LaneInfoEx::HasBitSetters {
 public:
  static void set_has_lane_info(LaneInfoEx* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_lane_id(LaneInfoEx* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lane_count(LaneInfoEx* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_lane_heading(LaneInfoEx* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LaneInfoEx::kLaneInfoFieldNumber;
const int LaneInfoEx::kLaneIdFieldNumber;
const int LaneInfoEx::kLaneCountFieldNumber;
const int LaneInfoEx::kLaneHeadingFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LaneInfoEx::LaneInfoEx()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perception.LaneInfoEx)
}
LaneInfoEx::LaneInfoEx(const LaneInfoEx& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&lane_info_, &from.lane_info_,
    static_cast<size_t>(reinterpret_cast<char*>(&lane_heading_) -
    reinterpret_cast<char*>(&lane_info_)) + sizeof(lane_heading_));
  // @@protoc_insertion_point(copy_constructor:perception.LaneInfoEx)
}

void LaneInfoEx::SharedCtor() {
  ::memset(&lane_info_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lane_heading_) -
      reinterpret_cast<char*>(&lane_info_)) + sizeof(lane_heading_));
}

LaneInfoEx::~LaneInfoEx() {
  // @@protoc_insertion_point(destructor:perception.LaneInfoEx)
  SharedDtor();
}

void LaneInfoEx::SharedDtor() {
}

void LaneInfoEx::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LaneInfoEx& LaneInfoEx::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_LaneInfoEx_perception_2eproto.base);
  return *internal_default_instance();
}


void LaneInfoEx::Clear() {
// @@protoc_insertion_point(message_clear_start:perception.LaneInfoEx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&lane_info_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lane_heading_) -
        reinterpret_cast<char*>(&lane_info_)) + sizeof(lane_heading_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* LaneInfoEx::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 lane_info = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_lane_info(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lane_id = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        set_lane_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required int32 lane_count = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_lane_count(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required float lane_heading = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 37) goto handle_unusual;
        set_lane_heading(::google::protobuf::internal::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool LaneInfoEx::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:perception.LaneInfoEx)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 lane_info = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_lane_info(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_info_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lane_id = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_lane_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 lane_count = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_lane_count(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float lane_heading = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (37 & 0xFF)) {
          HasBitSetters::set_has_lane_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &lane_heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perception.LaneInfoEx)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perception.LaneInfoEx)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void LaneInfoEx::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perception.LaneInfoEx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 lane_info = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->lane_info(), output);
  }

  // required int32 lane_id = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->lane_id(), output);
  }

  // required int32 lane_count = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lane_count(), output);
  }

  // required float lane_heading = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->lane_heading(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:perception.LaneInfoEx)
}

::google::protobuf::uint8* LaneInfoEx::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:perception.LaneInfoEx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 lane_info = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->lane_info(), target);
  }

  // required int32 lane_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->lane_id(), target);
  }

  // required int32 lane_count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->lane_count(), target);
  }

  // required float lane_heading = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->lane_heading(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perception.LaneInfoEx)
  return target;
}

size_t LaneInfoEx::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:perception.LaneInfoEx)
  size_t total_size = 0;

  if (has_lane_info()) {
    // required int32 lane_info = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lane_info());
  }

  if (has_lane_id()) {
    // required int32 lane_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lane_id());
  }

  if (has_lane_count()) {
    // required int32 lane_count = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lane_count());
  }

  if (has_lane_heading()) {
    // required float lane_heading = 4;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t LaneInfoEx::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perception.LaneInfoEx)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required int32 lane_info = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lane_info());

    // required int32 lane_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lane_id());

    // required int32 lane_count = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lane_count());

    // required float lane_heading = 4;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LaneInfoEx::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:perception.LaneInfoEx)
  GOOGLE_DCHECK_NE(&from, this);
  const LaneInfoEx* source =
      ::google::protobuf::DynamicCastToGenerated<LaneInfoEx>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:perception.LaneInfoEx)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:perception.LaneInfoEx)
    MergeFrom(*source);
  }
}

void LaneInfoEx::MergeFrom(const LaneInfoEx& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perception.LaneInfoEx)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      lane_info_ = from.lane_info_;
    }
    if (cached_has_bits & 0x00000002u) {
      lane_id_ = from.lane_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      lane_count_ = from.lane_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      lane_heading_ = from.lane_heading_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LaneInfoEx::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:perception.LaneInfoEx)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LaneInfoEx::CopyFrom(const LaneInfoEx& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perception.LaneInfoEx)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaneInfoEx::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  return true;
}

void LaneInfoEx::Swap(LaneInfoEx* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LaneInfoEx::InternalSwap(LaneInfoEx* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(lane_info_, other->lane_info_);
  swap(lane_id_, other->lane_id_);
  swap(lane_count_, other->lane_count_);
  swap(lane_heading_, other->lane_heading_);
}

::google::protobuf::Metadata LaneInfoEx::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_perception_2eproto);
  return ::file_level_metadata_perception_2eproto[kIndexInFileMessages];
}


// ===================================================================

void LaneArea::InitAsDefaultInstance() {
}
class LaneArea::HasBitSetters {
 public:
  static void set_has_camera(LaneArea* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_lane_id(LaneArea* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lane_heading(LaneArea* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_ware(LaneArea* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LaneArea::kPosFieldNumber;
const int LaneArea::kCameraFieldNumber;
const int LaneArea::kLaneIdFieldNumber;
const int LaneArea::kLaneHeadingFieldNumber;
const int LaneArea::kWareFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LaneArea::LaneArea()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perception.LaneArea)
}
LaneArea::LaneArea(const LaneArea& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      pos_(from.pos_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&camera_, &from.camera_,
    static_cast<size_t>(reinterpret_cast<char*>(&ware_) -
    reinterpret_cast<char*>(&camera_)) + sizeof(ware_));
  // @@protoc_insertion_point(copy_constructor:perception.LaneArea)
}

void LaneArea::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_LaneArea_perception_2eproto.base);
  ::memset(&camera_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ware_) -
      reinterpret_cast<char*>(&camera_)) + sizeof(ware_));
}

LaneArea::~LaneArea() {
  // @@protoc_insertion_point(destructor:perception.LaneArea)
  SharedDtor();
}

void LaneArea::SharedDtor() {
}

void LaneArea::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LaneArea& LaneArea::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_LaneArea_perception_2eproto.base);
  return *internal_default_instance();
}


void LaneArea::Clear() {
// @@protoc_insertion_point(message_clear_start:perception.LaneArea)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  pos_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&camera_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ware_) -
        reinterpret_cast<char*>(&camera_)) + sizeof(ware_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* LaneArea::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .perception.Position pos = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_pos(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      // optional int32 camera = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        set_camera(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_id = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_lane_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional float lane_heading = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 37) goto handle_unusual;
        set_lane_heading(::google::protobuf::internal::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional .perception.WareType ware = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::perception::WareType_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(5, val, mutable_unknown_fields());
          break;
        }
        set_ware(static_cast<::perception::WareType>(val));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool LaneArea::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:perception.LaneArea)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .perception.Position pos = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_pos()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 camera = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_camera(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &camera_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_id = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_lane_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float lane_heading = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (37 & 0xFF)) {
          HasBitSetters::set_has_lane_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &lane_heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .perception.WareType ware = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perception::WareType_IsValid(value)) {
            set_ware(static_cast< ::perception::WareType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                5, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perception.LaneArea)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perception.LaneArea)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void LaneArea::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perception.LaneArea)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .perception.Position pos = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->pos_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->pos(static_cast<int>(i)),
      output);
  }

  cached_has_bits = _has_bits_[0];
  // optional int32 camera = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->camera(), output);
  }

  // optional int32 lane_id = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lane_id(), output);
  }

  // optional float lane_heading = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->lane_heading(), output);
  }

  // optional .perception.WareType ware = 5;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->ware(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:perception.LaneArea)
}

::google::protobuf::uint8* LaneArea::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:perception.LaneArea)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .perception.Position pos = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->pos_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->pos(static_cast<int>(i)), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional int32 camera = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->camera(), target);
  }

  // optional int32 lane_id = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->lane_id(), target);
  }

  // optional float lane_heading = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->lane_heading(), target);
  }

  // optional .perception.WareType ware = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->ware(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perception.LaneArea)
  return target;
}

size_t LaneArea::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perception.LaneArea)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .perception.Position pos = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->pos_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->pos(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 camera = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->camera());
    }

    // optional int32 lane_id = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lane_id());
    }

    // optional float lane_heading = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional .perception.WareType ware = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->ware());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LaneArea::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:perception.LaneArea)
  GOOGLE_DCHECK_NE(&from, this);
  const LaneArea* source =
      ::google::protobuf::DynamicCastToGenerated<LaneArea>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:perception.LaneArea)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:perception.LaneArea)
    MergeFrom(*source);
  }
}

void LaneArea::MergeFrom(const LaneArea& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perception.LaneArea)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  pos_.MergeFrom(from.pos_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      camera_ = from.camera_;
    }
    if (cached_has_bits & 0x00000002u) {
      lane_id_ = from.lane_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      lane_heading_ = from.lane_heading_;
    }
    if (cached_has_bits & 0x00000008u) {
      ware_ = from.ware_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LaneArea::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:perception.LaneArea)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LaneArea::CopyFrom(const LaneArea& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perception.LaneArea)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaneArea::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->pos())) return false;
  return true;
}

void LaneArea::Swap(LaneArea* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LaneArea::InternalSwap(LaneArea* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&pos_)->InternalSwap(CastToBase(&other->pos_));
  swap(camera_, other->camera_);
  swap(lane_id_, other->lane_id_);
  swap(lane_heading_, other->lane_heading_);
  swap(ware_, other->ware_);
}

::google::protobuf::Metadata LaneArea::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_perception_2eproto);
  return ::file_level_metadata_perception_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Jam::InitAsDefaultInstance() {
}
class Jam::HasBitSetters {
 public:
  static void set_has_vehicle_num(Jam* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_vehicle_velocity(Jam* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_lane_heading(Jam* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_lane_id(Jam* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Jam::kVehicleNumFieldNumber;
const int Jam::kVehicleVelocityFieldNumber;
const int Jam::kLaneHeadingFieldNumber;
const int Jam::kVehicleFlowFieldNumber;
const int Jam::kLaneIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Jam::Jam()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perception.Jam)
}
Jam::Jam(const Jam& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      vehicle_flow_(from.vehicle_flow_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&vehicle_num_, &from.vehicle_num_,
    static_cast<size_t>(reinterpret_cast<char*>(&lane_id_) -
    reinterpret_cast<char*>(&vehicle_num_)) + sizeof(lane_id_));
  // @@protoc_insertion_point(copy_constructor:perception.Jam)
}

void Jam::SharedCtor() {
  ::memset(&vehicle_num_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lane_id_) -
      reinterpret_cast<char*>(&vehicle_num_)) + sizeof(lane_id_));
}

Jam::~Jam() {
  // @@protoc_insertion_point(destructor:perception.Jam)
  SharedDtor();
}

void Jam::SharedDtor() {
}

void Jam::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Jam& Jam::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Jam_perception_2eproto.base);
  return *internal_default_instance();
}


void Jam::Clear() {
// @@protoc_insertion_point(message_clear_start:perception.Jam)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vehicle_flow_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&vehicle_num_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lane_id_) -
        reinterpret_cast<char*>(&vehicle_num_)) + sizeof(lane_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Jam::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required uint32 vehicle_num = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_vehicle_num(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required float vehicle_velocity = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        set_vehicle_velocity(::google::protobuf::internal::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // required float lane_heading = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        set_lane_heading(::google::protobuf::internal::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // repeated int32 vehicle_flow = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) == 32) {
          do {
            add_vehicle_flow(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ctx->Done(&ptr)) return ptr;
          } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 32 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::internal::PackedInt32Parser(mutable_vehicle_flow(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_id = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        set_lane_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Jam::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:perception.Jam)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 vehicle_num = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_vehicle_num(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &vehicle_num_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float vehicle_velocity = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_vehicle_velocity(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &vehicle_velocity_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required float lane_heading = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_lane_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &lane_heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 vehicle_flow = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 32u, input, this->mutable_vehicle_flow())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_vehicle_flow())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_id = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_lane_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perception.Jam)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perception.Jam)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Jam::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perception.Jam)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 vehicle_num = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->vehicle_num(), output);
  }

  // required float vehicle_velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->vehicle_velocity(), output);
  }

  // required float lane_heading = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->lane_heading(), output);
  }

  // repeated int32 vehicle_flow = 4;
  for (int i = 0, n = this->vehicle_flow_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      4, this->vehicle_flow(i), output);
  }

  // optional int32 lane_id = 5;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->lane_id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:perception.Jam)
}

::google::protobuf::uint8* Jam::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:perception.Jam)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 vehicle_num = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->vehicle_num(), target);
  }

  // required float vehicle_velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->vehicle_velocity(), target);
  }

  // required float lane_heading = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->lane_heading(), target);
  }

  // repeated int32 vehicle_flow = 4;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteInt32ToArray(4, this->vehicle_flow_, target);

  // optional int32 lane_id = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->lane_id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perception.Jam)
  return target;
}

size_t Jam::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:perception.Jam)
  size_t total_size = 0;

  if (has_vehicle_num()) {
    // required uint32 vehicle_num = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->vehicle_num());
  }

  if (has_vehicle_velocity()) {
    // required float vehicle_velocity = 2;
    total_size += 1 + 4;
  }

  if (has_lane_heading()) {
    // required float lane_heading = 3;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t Jam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perception.Jam)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 vehicle_num = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->vehicle_num());

    // required float vehicle_velocity = 2;
    total_size += 1 + 4;

    // required float lane_heading = 3;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 vehicle_flow = 4;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int32Size(this->vehicle_flow_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->vehicle_flow_size());
    total_size += data_size;
  }

  // optional int32 lane_id = 5;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->lane_id());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Jam::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:perception.Jam)
  GOOGLE_DCHECK_NE(&from, this);
  const Jam* source =
      ::google::protobuf::DynamicCastToGenerated<Jam>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:perception.Jam)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:perception.Jam)
    MergeFrom(*source);
  }
}

void Jam::MergeFrom(const Jam& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perception.Jam)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  vehicle_flow_.MergeFrom(from.vehicle_flow_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      vehicle_num_ = from.vehicle_num_;
    }
    if (cached_has_bits & 0x00000002u) {
      vehicle_velocity_ = from.vehicle_velocity_;
    }
    if (cached_has_bits & 0x00000004u) {
      lane_heading_ = from.lane_heading_;
    }
    if (cached_has_bits & 0x00000008u) {
      lane_id_ = from.lane_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Jam::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:perception.Jam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Jam::CopyFrom(const Jam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perception.Jam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Jam::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  return true;
}

void Jam::Swap(Jam* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Jam::InternalSwap(Jam* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  vehicle_flow_.InternalSwap(&other->vehicle_flow_);
  swap(vehicle_num_, other->vehicle_num_);
  swap(vehicle_velocity_, other->vehicle_velocity_);
  swap(lane_heading_, other->lane_heading_);
  swap(lane_id_, other->lane_id_);
}

::google::protobuf::Metadata Jam::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_perception_2eproto);
  return ::file_level_metadata_perception_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Flow::InitAsDefaultInstance() {
}
class Flow::HasBitSetters {
 public:
  static void set_has_camera(Flow* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_signal(Flow* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Flow::kCameraFieldNumber;
const int Flow::kVehicleNumFieldNumber;
const int Flow::kPassNumFieldNumber;
const int Flow::kSignalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Flow::Flow()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perception.Flow)
}
Flow::Flow(const Flow& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      vehicle_num_(from.vehicle_num_),
      pass_num_(from.pass_num_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&camera_, &from.camera_,
    static_cast<size_t>(reinterpret_cast<char*>(&signal_) -
    reinterpret_cast<char*>(&camera_)) + sizeof(signal_));
  // @@protoc_insertion_point(copy_constructor:perception.Flow)
}

void Flow::SharedCtor() {
  ::memset(&camera_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&signal_) -
      reinterpret_cast<char*>(&camera_)) + sizeof(signal_));
}

Flow::~Flow() {
  // @@protoc_insertion_point(destructor:perception.Flow)
  SharedDtor();
}

void Flow::SharedDtor() {
}

void Flow::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Flow& Flow::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Flow_perception_2eproto.base);
  return *internal_default_instance();
}


void Flow::Clear() {
// @@protoc_insertion_point(message_clear_start:perception.Flow)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vehicle_num_.Clear();
  pass_num_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&camera_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&signal_) -
        reinterpret_cast<char*>(&camera_)) + sizeof(signal_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Flow::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional int32 camera = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_camera(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated int32 vehicle_num = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) == 16) {
          do {
            add_vehicle_num(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ctx->Done(&ptr)) return ptr;
          } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 16 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::internal::PackedInt32Parser(mutable_vehicle_num(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated int32 pass_num = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) == 24) {
          do {
            add_pass_num(::google::protobuf::internal::ReadVarint(&ptr));
            GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
            if (ctx->Done(&ptr)) return ptr;
          } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 24 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::internal::PackedInt32Parser(mutable_pass_num(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .perception.Flow.TrafficSig signal = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::perception::Flow_TrafficSig_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(4, val, mutable_unknown_fields());
          break;
        }
        set_signal(static_cast<::perception::Flow_TrafficSig>(val));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Flow::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:perception.Flow)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 camera = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_camera(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &camera_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 vehicle_num = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 16u, input, this->mutable_vehicle_num())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_vehicle_num())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 pass_num = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24u, input, this->mutable_pass_num())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_pass_num())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .perception.Flow.TrafficSig signal = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perception::Flow_TrafficSig_IsValid(value)) {
            set_signal(static_cast< ::perception::Flow_TrafficSig >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                4, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perception.Flow)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perception.Flow)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Flow::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perception.Flow)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 camera = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->camera(), output);
  }

  // repeated int32 vehicle_num = 2;
  for (int i = 0, n = this->vehicle_num_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      2, this->vehicle_num(i), output);
  }

  // repeated int32 pass_num = 3;
  for (int i = 0, n = this->pass_num_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->pass_num(i), output);
  }

  // optional .perception.Flow.TrafficSig signal = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->signal(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:perception.Flow)
}

::google::protobuf::uint8* Flow::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:perception.Flow)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 camera = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->camera(), target);
  }

  // repeated int32 vehicle_num = 2;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteInt32ToArray(2, this->vehicle_num_, target);

  // repeated int32 pass_num = 3;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteInt32ToArray(3, this->pass_num_, target);

  // optional .perception.Flow.TrafficSig signal = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->signal(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perception.Flow)
  return target;
}

size_t Flow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perception.Flow)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 vehicle_num = 2;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int32Size(this->vehicle_num_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->vehicle_num_size());
    total_size += data_size;
  }

  // repeated int32 pass_num = 3;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int32Size(this->pass_num_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->pass_num_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 camera = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->camera());
    }

    // optional .perception.Flow.TrafficSig signal = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->signal());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Flow::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:perception.Flow)
  GOOGLE_DCHECK_NE(&from, this);
  const Flow* source =
      ::google::protobuf::DynamicCastToGenerated<Flow>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:perception.Flow)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:perception.Flow)
    MergeFrom(*source);
  }
}

void Flow::MergeFrom(const Flow& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perception.Flow)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  vehicle_num_.MergeFrom(from.vehicle_num_);
  pass_num_.MergeFrom(from.pass_num_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      camera_ = from.camera_;
    }
    if (cached_has_bits & 0x00000002u) {
      signal_ = from.signal_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Flow::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:perception.Flow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Flow::CopyFrom(const Flow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perception.Flow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Flow::IsInitialized() const {
  return true;
}

void Flow::Swap(Flow* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Flow::InternalSwap(Flow* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  vehicle_num_.InternalSwap(&other->vehicle_num_);
  pass_num_.InternalSwap(&other->pass_num_);
  swap(camera_, other->camera_);
  swap(signal_, other->signal_);
}

::google::protobuf::Metadata Flow::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_perception_2eproto);
  return ::file_level_metadata_perception_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Target::InitAsDefaultInstance() {
  ::perception::_Target_default_instance_._instance.get_mutable()->pos_ = const_cast< ::perception::Position*>(
      ::perception::Position::internal_default_instance());
  ::perception::_Target_default_instance_._instance.get_mutable()->size_ = const_cast< ::perception::Size*>(
      ::perception::Size::internal_default_instance());
  ::perception::_Target_default_instance_._instance.get_mutable()->lane_ex_ = const_cast< ::perception::LaneInfoEx*>(
      ::perception::LaneInfoEx::internal_default_instance());
}
class Target::HasBitSetters {
 public:
  static void set_has_id(Target* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_type(Target* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static const ::perception::Position& pos(const Target* msg);
  static void set_has_pos(Target* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_camera(Target* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_velocity(Target* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_heading(Target* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static void set_has_distance(Target* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
  static const ::perception::Size& size(const Target* msg);
  static void set_has_size(Target* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_approach_judge(Target* msg) {
    msg->_has_bits_[0] |= 0x00000400u;
  }
  static void set_has_source(Target* msg) {
    msg->_has_bits_[0] |= 0x00000800u;
  }
  static void set_has_capture_id(Target* msg) {
    msg->_has_bits_[0] |= 0x00001000u;
  }
  static void set_has_in_lane(Target* msg) {
    msg->_has_bits_[0] |= 0x00002000u;
  }
  static void set_has_lane_id(Target* msg) {
    msg->_has_bits_[0] |= 0x00004000u;
  }
  static void set_has_lane_heading(Target* msg) {
    msg->_has_bits_[0] |= 0x00008000u;
  }
  static void set_has_lane_type(Target* msg) {
    msg->_has_bits_[0] |= 0x00010000u;
  }
  static const ::perception::LaneInfoEx& lane_ex(const Target* msg);
  static void set_has_lane_ex(Target* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_license_plate(Target* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_car_type(Target* msg) {
    msg->_has_bits_[0] |= 0x00020000u;
  }
  static void set_has_car_status(Target* msg) {
    msg->_has_bits_[0] |= 0x00040000u;
  }
  static void set_has_confidence(Target* msg) {
    msg->_has_bits_[0] |= 0x00080000u;
  }
  static void set_has_rcs(Target* msg) {
    msg->_has_bits_[0] |= 0x00100000u;
  }
};

const ::perception::Position&
Target::HasBitSetters::pos(const Target* msg) {
  return *msg->pos_;
}
const ::perception::Size&
Target::HasBitSetters::size(const Target* msg) {
  return *msg->size_;
}
const ::perception::LaneInfoEx&
Target::HasBitSetters::lane_ex(const Target* msg) {
  return *msg->lane_ex_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Target::kIdFieldNumber;
const int Target::kTypeFieldNumber;
const int Target::kPosFieldNumber;
const int Target::kCameraFieldNumber;
const int Target::kVelocityFieldNumber;
const int Target::kHeadingFieldNumber;
const int Target::kDistanceFieldNumber;
const int Target::kSizeFieldNumber;
const int Target::kApproachJudgeFieldNumber;
const int Target::kSourceFieldNumber;
const int Target::kCaptureIdFieldNumber;
const int Target::kInLaneFieldNumber;
const int Target::kLaneIdFieldNumber;
const int Target::kLaneHeadingFieldNumber;
const int Target::kLaneTypeFieldNumber;
const int Target::kLaneExFieldNumber;
const int Target::kLicensePlateFieldNumber;
const int Target::kCarTypeFieldNumber;
const int Target::kCarStatusFieldNumber;
const int Target::kConfidenceFieldNumber;
const int Target::kRcsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Target::Target()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perception.Target)
}
Target::Target(const Target& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  license_plate_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_license_plate()) {
    license_plate_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.license_plate_);
  }
  if (from.has_pos()) {
    pos_ = new ::perception::Position(*from.pos_);
  } else {
    pos_ = nullptr;
  }
  if (from.has_size()) {
    size_ = new ::perception::Size(*from.size_);
  } else {
    size_ = nullptr;
  }
  if (from.has_lane_ex()) {
    lane_ex_ = new ::perception::LaneInfoEx(*from.lane_ex_);
  } else {
    lane_ex_ = nullptr;
  }
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&rcs_) -
    reinterpret_cast<char*>(&id_)) + sizeof(rcs_));
  // @@protoc_insertion_point(copy_constructor:perception.Target)
}

void Target::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Target_perception_2eproto.base);
  license_plate_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&pos_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rcs_) -
      reinterpret_cast<char*>(&pos_)) + sizeof(rcs_));
}

Target::~Target() {
  // @@protoc_insertion_point(destructor:perception.Target)
  SharedDtor();
}

void Target::SharedDtor() {
  license_plate_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete pos_;
  if (this != internal_default_instance()) delete size_;
  if (this != internal_default_instance()) delete lane_ex_;
}

void Target::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Target& Target::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Target_perception_2eproto.base);
  return *internal_default_instance();
}


void Target::Clear() {
// @@protoc_insertion_point(message_clear_start:perception.Target)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      license_plate_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(pos_ != nullptr);
      pos_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(size_ != nullptr);
      size_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(lane_ex_ != nullptr);
      lane_ex_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&velocity_) -
        reinterpret_cast<char*>(&id_)) + sizeof(velocity_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&heading_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lane_heading_) -
        reinterpret_cast<char*>(&heading_)) + sizeof(lane_heading_));
  }
  if (cached_has_bits & 0x001f0000u) {
    ::memset(&lane_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rcs_) -
        reinterpret_cast<char*>(&lane_type_)) + sizeof(rcs_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Target::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required int32 id = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // required .perception.TargetType type = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::perception::TargetType_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(2, val, mutable_unknown_fields());
          break;
        }
        set_type(static_cast<::perception::TargetType>(val));
        break;
      }
      // required .perception.Position pos = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ctx->ParseMessage(mutable_pos(), ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 camera = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        set_camera(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional float velocity = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 45) goto handle_unusual;
        set_velocity(::google::protobuf::internal::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float heading = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 53) goto handle_unusual;
        set_heading(::google::protobuf::internal::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float distance = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 61) goto handle_unusual;
        set_distance(::google::protobuf::internal::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional .perception.Size size = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 66) goto handle_unusual;
        ptr = ctx->ParseMessage(mutable_size(), ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 approach_judge = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 72) goto handle_unusual;
        set_approach_judge(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .perception.Source source = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 80) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::perception::Source_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(10, val, mutable_unknown_fields());
          break;
        }
        set_source(static_cast<::perception::Source>(val));
        break;
      }
      // optional int32 capture_id = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 88) goto handle_unusual;
        set_capture_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool in_lane = 12;
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 96) goto handle_unusual;
        set_in_lane(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 lane_id = 13;
      case 13: {
        if (static_cast<::google::protobuf::uint8>(tag) != 104) goto handle_unusual;
        set_lane_id(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional float lane_heading = 14;
      case 14: {
        if (static_cast<::google::protobuf::uint8>(tag) != 117) goto handle_unusual;
        set_lane_heading(::google::protobuf::internal::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional int32 lane_type = 15;
      case 15: {
        if (static_cast<::google::protobuf::uint8>(tag) != 120) goto handle_unusual;
        set_lane_type(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .perception.LaneInfoEx lane_ex = 16;
      case 16: {
        if (static_cast<::google::protobuf::uint8>(tag) != 130) goto handle_unusual;
        ptr = ctx->ParseMessage(mutable_lane_ex(), ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional string license_plate = 17;
      case 17: {
        if (static_cast<::google::protobuf::uint8>(tag) != 138) goto handle_unusual;
        ptr = ::google::protobuf::internal::InlineGreedyStringParserUTF8Verify(mutable_license_plate(), ptr, ctx, "perception.Target.license_plate");
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .perception.CarType car_type = 18;
      case 18: {
        if (static_cast<::google::protobuf::uint8>(tag) != 144) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::perception::CarType_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(18, val, mutable_unknown_fields());
          break;
        }
        set_car_type(static_cast<::perception::CarType>(val));
        break;
      }
      // optional .perception.CarStatus car_status = 19;
      case 19: {
        if (static_cast<::google::protobuf::uint8>(tag) != 152) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::perception::CarStatus_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(19, val, mutable_unknown_fields());
          break;
        }
        set_car_status(static_cast<::perception::CarStatus>(val));
        break;
      }
      // optional float confidence = 20;
      case 20: {
        if (static_cast<::google::protobuf::uint8>(tag) != 165) goto handle_unusual;
        set_confidence(::google::protobuf::internal::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float rcs = 21;
      case 21: {
        if (static_cast<::google::protobuf::uint8>(tag) != 173) goto handle_unusual;
        set_rcs(::google::protobuf::internal::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Target::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:perception.Target)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .perception.TargetType type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perception::TargetType_IsValid(value)) {
            set_type(static_cast< ::perception::TargetType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .perception.Position pos = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_pos()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 camera = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_camera(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &camera_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float velocity = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (45 & 0xFF)) {
          HasBitSetters::set_has_velocity(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &velocity_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float heading = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (53 & 0xFF)) {
          HasBitSetters::set_has_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float distance = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (61 & 0xFF)) {
          HasBitSetters::set_has_distance(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .perception.Size size = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (66 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_size()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 approach_judge = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_approach_judge(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &approach_judge_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .perception.Source source = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (80 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perception::Source_IsValid(value)) {
            set_source(static_cast< ::perception::Source >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                10, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 capture_id = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (88 & 0xFF)) {
          HasBitSetters::set_has_capture_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &capture_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool in_lane = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (96 & 0xFF)) {
          HasBitSetters::set_has_in_lane(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &in_lane_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_id = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (104 & 0xFF)) {
          HasBitSetters::set_has_lane_id(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float lane_heading = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (117 & 0xFF)) {
          HasBitSetters::set_has_lane_heading(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &lane_heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 lane_type = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (120 & 0xFF)) {
          HasBitSetters::set_has_lane_type(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lane_type_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .perception.LaneInfoEx lane_ex = 16;
      case 16: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (130 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_lane_ex()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string license_plate = 17;
      case 17: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (138 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_license_plate()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->license_plate().data(), static_cast<int>(this->license_plate().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "perception.Target.license_plate");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .perception.CarType car_type = 18;
      case 18: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (144 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perception::CarType_IsValid(value)) {
            set_car_type(static_cast< ::perception::CarType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                18, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .perception.CarStatus car_status = 19;
      case 19: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (152 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perception::CarStatus_IsValid(value)) {
            set_car_status(static_cast< ::perception::CarStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                19, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float confidence = 20;
      case 20: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (165 & 0xFF)) {
          HasBitSetters::set_has_confidence(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &confidence_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float rcs = 21;
      case 21: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (173 & 0xFF)) {
          HasBitSetters::set_has_rcs(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &rcs_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perception.Target)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perception.Target)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Target::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perception.Target)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 id = 1;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // required .perception.TargetType type = 2;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // required .perception.Position pos = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::pos(this), output);
  }

  // optional int32 camera = 4;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->camera(), output);
  }

  // optional float velocity = 5;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->velocity(), output);
  }

  // optional float heading = 6;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->heading(), output);
  }

  // optional float distance = 7;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->distance(), output);
  }

  // optional .perception.Size size = 8;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, HasBitSetters::size(this), output);
  }

  // optional int32 approach_judge = 9;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->approach_judge(), output);
  }

  // optional .perception.Source source = 10;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->source(), output);
  }

  // optional int32 capture_id = 11;
  if (cached_has_bits & 0x00001000u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->capture_id(), output);
  }

  // optional bool in_lane = 12;
  if (cached_has_bits & 0x00002000u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->in_lane(), output);
  }

  // optional int32 lane_id = 13;
  if (cached_has_bits & 0x00004000u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(13, this->lane_id(), output);
  }

  // optional float lane_heading = 14;
  if (cached_has_bits & 0x00008000u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(14, this->lane_heading(), output);
  }

  // optional int32 lane_type = 15;
  if (cached_has_bits & 0x00010000u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(15, this->lane_type(), output);
  }

  // optional .perception.LaneInfoEx lane_ex = 16;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      16, HasBitSetters::lane_ex(this), output);
  }

  // optional string license_plate = 17;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->license_plate().data(), static_cast<int>(this->license_plate().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "perception.Target.license_plate");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      17, this->license_plate(), output);
  }

  // optional .perception.CarType car_type = 18;
  if (cached_has_bits & 0x00020000u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      18, this->car_type(), output);
  }

  // optional .perception.CarStatus car_status = 19;
  if (cached_has_bits & 0x00040000u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      19, this->car_status(), output);
  }

  // optional float confidence = 20;
  if (cached_has_bits & 0x00080000u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(20, this->confidence(), output);
  }

  // optional float rcs = 21;
  if (cached_has_bits & 0x00100000u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(21, this->rcs(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:perception.Target)
}

::google::protobuf::uint8* Target::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:perception.Target)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 id = 1;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // required .perception.TargetType type = 2;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  // required .perception.Position pos = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::pos(this), target);
  }

  // optional int32 camera = 4;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->camera(), target);
  }

  // optional float velocity = 5;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->velocity(), target);
  }

  // optional float heading = 6;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->heading(), target);
  }

  // optional float distance = 7;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->distance(), target);
  }

  // optional .perception.Size size = 8;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        8, HasBitSetters::size(this), target);
  }

  // optional int32 approach_judge = 9;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->approach_judge(), target);
  }

  // optional .perception.Source source = 10;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      10, this->source(), target);
  }

  // optional int32 capture_id = 11;
  if (cached_has_bits & 0x00001000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->capture_id(), target);
  }

  // optional bool in_lane = 12;
  if (cached_has_bits & 0x00002000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(12, this->in_lane(), target);
  }

  // optional int32 lane_id = 13;
  if (cached_has_bits & 0x00004000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(13, this->lane_id(), target);
  }

  // optional float lane_heading = 14;
  if (cached_has_bits & 0x00008000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(14, this->lane_heading(), target);
  }

  // optional int32 lane_type = 15;
  if (cached_has_bits & 0x00010000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(15, this->lane_type(), target);
  }

  // optional .perception.LaneInfoEx lane_ex = 16;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        16, HasBitSetters::lane_ex(this), target);
  }

  // optional string license_plate = 17;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->license_plate().data(), static_cast<int>(this->license_plate().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "perception.Target.license_plate");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        17, this->license_plate(), target);
  }

  // optional .perception.CarType car_type = 18;
  if (cached_has_bits & 0x00020000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      18, this->car_type(), target);
  }

  // optional .perception.CarStatus car_status = 19;
  if (cached_has_bits & 0x00040000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      19, this->car_status(), target);
  }

  // optional float confidence = 20;
  if (cached_has_bits & 0x00080000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(20, this->confidence(), target);
  }

  // optional float rcs = 21;
  if (cached_has_bits & 0x00100000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(21, this->rcs(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perception.Target)
  return target;
}

size_t Target::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:perception.Target)
  size_t total_size = 0;

  if (has_pos()) {
    // required .perception.Position pos = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *pos_);
  }

  if (has_id()) {
    // required int32 id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->id());
  }

  if (has_type()) {
    // required .perception.TargetType type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  return total_size;
}
size_t Target::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perception.Target)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000032) ^ 0x00000032) == 0) {  // All required fields are present.
    // required .perception.Position pos = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *pos_);

    // required int32 id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->id());

    // required .perception.TargetType type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string license_plate = 17;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->license_plate());
  }

  if (cached_has_bits & 0x0000000cu) {
    // optional .perception.Size size = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *size_);
    }

    // optional .perception.LaneInfoEx lane_ex = 16;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *lane_ex_);
    }

  }
  if (cached_has_bits & 0x000000c0u) {
    // optional int32 camera = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->camera());
    }

    // optional float velocity = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional float heading = 6;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float distance = 7;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional int32 approach_judge = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->approach_judge());
    }

    // optional .perception.Source source = 10;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->source());
    }

    // optional int32 capture_id = 11;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->capture_id());
    }

    // optional bool in_lane = 12;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional int32 lane_id = 13;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lane_id());
    }

    // optional float lane_heading = 14;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x001f0000u) {
    // optional int32 lane_type = 15;
    if (cached_has_bits & 0x00010000u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lane_type());
    }

    // optional .perception.CarType car_type = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->car_type());
    }

    // optional .perception.CarStatus car_status = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->car_status());
    }

    // optional float confidence = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 4;
    }

    // optional float rcs = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 4;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Target::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:perception.Target)
  GOOGLE_DCHECK_NE(&from, this);
  const Target* source =
      ::google::protobuf::DynamicCastToGenerated<Target>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:perception.Target)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:perception.Target)
    MergeFrom(*source);
  }
}

void Target::MergeFrom(const Target& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perception.Target)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      license_plate_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.license_plate_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_pos()->::perception::Position::MergeFrom(from.pos());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_size()->::perception::Size::MergeFrom(from.size());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_lane_ex()->::perception::LaneInfoEx::MergeFrom(from.lane_ex());
    }
    if (cached_has_bits & 0x00000010u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000020u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000040u) {
      camera_ = from.camera_;
    }
    if (cached_has_bits & 0x00000080u) {
      velocity_ = from.velocity_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      heading_ = from.heading_;
    }
    if (cached_has_bits & 0x00000200u) {
      distance_ = from.distance_;
    }
    if (cached_has_bits & 0x00000400u) {
      approach_judge_ = from.approach_judge_;
    }
    if (cached_has_bits & 0x00000800u) {
      source_ = from.source_;
    }
    if (cached_has_bits & 0x00001000u) {
      capture_id_ = from.capture_id_;
    }
    if (cached_has_bits & 0x00002000u) {
      in_lane_ = from.in_lane_;
    }
    if (cached_has_bits & 0x00004000u) {
      lane_id_ = from.lane_id_;
    }
    if (cached_has_bits & 0x00008000u) {
      lane_heading_ = from.lane_heading_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x001f0000u) {
    if (cached_has_bits & 0x00010000u) {
      lane_type_ = from.lane_type_;
    }
    if (cached_has_bits & 0x00020000u) {
      car_type_ = from.car_type_;
    }
    if (cached_has_bits & 0x00040000u) {
      car_status_ = from.car_status_;
    }
    if (cached_has_bits & 0x00080000u) {
      confidence_ = from.confidence_;
    }
    if (cached_has_bits & 0x00100000u) {
      rcs_ = from.rcs_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Target::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:perception.Target)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Target::CopyFrom(const Target& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perception.Target)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Target::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000032) != 0x00000032) return false;
  if (has_pos()) {
    if (!this->pos_->IsInitialized()) return false;
  }
  if (has_size()) {
    if (!this->size_->IsInitialized()) return false;
  }
  if (has_lane_ex()) {
    if (!this->lane_ex_->IsInitialized()) return false;
  }
  return true;
}

void Target::Swap(Target* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Target::InternalSwap(Target* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  license_plate_.Swap(&other->license_plate_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(pos_, other->pos_);
  swap(size_, other->size_);
  swap(lane_ex_, other->lane_ex_);
  swap(id_, other->id_);
  swap(type_, other->type_);
  swap(camera_, other->camera_);
  swap(velocity_, other->velocity_);
  swap(heading_, other->heading_);
  swap(distance_, other->distance_);
  swap(approach_judge_, other->approach_judge_);
  swap(source_, other->source_);
  swap(capture_id_, other->capture_id_);
  swap(in_lane_, other->in_lane_);
  swap(lane_id_, other->lane_id_);
  swap(lane_heading_, other->lane_heading_);
  swap(lane_type_, other->lane_type_);
  swap(car_type_, other->car_type_);
  swap(car_status_, other->car_status_);
  swap(confidence_, other->confidence_);
  swap(rcs_, other->rcs_);
}

::google::protobuf::Metadata Target::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_perception_2eproto);
  return ::file_level_metadata_perception_2eproto[kIndexInFileMessages];
}


// ===================================================================

void VisibilityMsg::InitAsDefaultInstance() {
}
class VisibilityMsg::HasBitSetters {
 public:
  static void set_has_distance(VisibilityMsg* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_level(VisibilityMsg* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int VisibilityMsg::kDistanceFieldNumber;
const int VisibilityMsg::kLevelFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

VisibilityMsg::VisibilityMsg()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perception.VisibilityMsg)
}
VisibilityMsg::VisibilityMsg(const VisibilityMsg& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&distance_, &from.distance_,
    static_cast<size_t>(reinterpret_cast<char*>(&level_) -
    reinterpret_cast<char*>(&distance_)) + sizeof(level_));
  // @@protoc_insertion_point(copy_constructor:perception.VisibilityMsg)
}

void VisibilityMsg::SharedCtor() {
  ::memset(&distance_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&level_) -
      reinterpret_cast<char*>(&distance_)) + sizeof(level_));
}

VisibilityMsg::~VisibilityMsg() {
  // @@protoc_insertion_point(destructor:perception.VisibilityMsg)
  SharedDtor();
}

void VisibilityMsg::SharedDtor() {
}

void VisibilityMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const VisibilityMsg& VisibilityMsg::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_VisibilityMsg_perception_2eproto.base);
  return *internal_default_instance();
}


void VisibilityMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:perception.VisibilityMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&distance_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&level_) -
        reinterpret_cast<char*>(&distance_)) + sizeof(level_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* VisibilityMsg::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required float distance = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        set_distance(::google::protobuf::internal::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // required int32 level = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        set_level(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool VisibilityMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:perception.VisibilityMsg)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float distance = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_distance(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 level = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_level(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &level_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perception.VisibilityMsg)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perception.VisibilityMsg)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void VisibilityMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perception.VisibilityMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required float distance = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->distance(), output);
  }

  // required int32 level = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->level(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:perception.VisibilityMsg)
}

::google::protobuf::uint8* VisibilityMsg::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:perception.VisibilityMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required float distance = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->distance(), target);
  }

  // required int32 level = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->level(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perception.VisibilityMsg)
  return target;
}

size_t VisibilityMsg::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:perception.VisibilityMsg)
  size_t total_size = 0;

  if (has_distance()) {
    // required float distance = 2;
    total_size += 1 + 4;
  }

  if (has_level()) {
    // required int32 level = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->level());
  }

  return total_size;
}
size_t VisibilityMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perception.VisibilityMsg)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required float distance = 2;
    total_size += 1 + 4;

    // required int32 level = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->level());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VisibilityMsg::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:perception.VisibilityMsg)
  GOOGLE_DCHECK_NE(&from, this);
  const VisibilityMsg* source =
      ::google::protobuf::DynamicCastToGenerated<VisibilityMsg>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:perception.VisibilityMsg)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:perception.VisibilityMsg)
    MergeFrom(*source);
  }
}

void VisibilityMsg::MergeFrom(const VisibilityMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perception.VisibilityMsg)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      distance_ = from.distance_;
    }
    if (cached_has_bits & 0x00000002u) {
      level_ = from.level_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void VisibilityMsg::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:perception.VisibilityMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VisibilityMsg::CopyFrom(const VisibilityMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perception.VisibilityMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VisibilityMsg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void VisibilityMsg::Swap(VisibilityMsg* other) {
  if (other == this) return;
  InternalSwap(other);
}
void VisibilityMsg::InternalSwap(VisibilityMsg* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(distance_, other->distance_);
  swap(level_, other->level_);
}

::google::protobuf::Metadata VisibilityMsg::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_perception_2eproto);
  return ::file_level_metadata_perception_2eproto[kIndexInFileMessages];
}


// ===================================================================

void LaneAreaMsg::InitAsDefaultInstance() {
}
class LaneAreaMsg::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LaneAreaMsg::kAreaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LaneAreaMsg::LaneAreaMsg()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perception.LaneAreaMsg)
}
LaneAreaMsg::LaneAreaMsg(const LaneAreaMsg& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      area_(from.area_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perception.LaneAreaMsg)
}

void LaneAreaMsg::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_LaneAreaMsg_perception_2eproto.base);
}

LaneAreaMsg::~LaneAreaMsg() {
  // @@protoc_insertion_point(destructor:perception.LaneAreaMsg)
  SharedDtor();
}

void LaneAreaMsg::SharedDtor() {
}

void LaneAreaMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LaneAreaMsg& LaneAreaMsg::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_LaneAreaMsg_perception_2eproto.base);
  return *internal_default_instance();
}


void LaneAreaMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:perception.LaneAreaMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  area_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* LaneAreaMsg::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .perception.LaneArea area = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_area(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool LaneAreaMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:perception.LaneAreaMsg)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .perception.LaneArea area = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_area()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perception.LaneAreaMsg)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perception.LaneAreaMsg)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void LaneAreaMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perception.LaneAreaMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .perception.LaneArea area = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->area_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->area(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:perception.LaneAreaMsg)
}

::google::protobuf::uint8* LaneAreaMsg::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:perception.LaneAreaMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .perception.LaneArea area = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->area_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->area(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perception.LaneAreaMsg)
  return target;
}

size_t LaneAreaMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perception.LaneAreaMsg)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .perception.LaneArea area = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->area_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->area(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LaneAreaMsg::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:perception.LaneAreaMsg)
  GOOGLE_DCHECK_NE(&from, this);
  const LaneAreaMsg* source =
      ::google::protobuf::DynamicCastToGenerated<LaneAreaMsg>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:perception.LaneAreaMsg)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:perception.LaneAreaMsg)
    MergeFrom(*source);
  }
}

void LaneAreaMsg::MergeFrom(const LaneAreaMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perception.LaneAreaMsg)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  area_.MergeFrom(from.area_);
}

void LaneAreaMsg::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:perception.LaneAreaMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LaneAreaMsg::CopyFrom(const LaneAreaMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perception.LaneAreaMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaneAreaMsg::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->area())) return false;
  return true;
}

void LaneAreaMsg::Swap(LaneAreaMsg* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LaneAreaMsg::InternalSwap(LaneAreaMsg* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&area_)->InternalSwap(CastToBase(&other->area_));
}

::google::protobuf::Metadata LaneAreaMsg::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_perception_2eproto);
  return ::file_level_metadata_perception_2eproto[kIndexInFileMessages];
}


// ===================================================================

void JamMsg::InitAsDefaultInstance() {
}
class JamMsg::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int JamMsg::kJamFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

JamMsg::JamMsg()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perception.JamMsg)
}
JamMsg::JamMsg(const JamMsg& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      jam_(from.jam_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perception.JamMsg)
}

void JamMsg::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_JamMsg_perception_2eproto.base);
}

JamMsg::~JamMsg() {
  // @@protoc_insertion_point(destructor:perception.JamMsg)
  SharedDtor();
}

void JamMsg::SharedDtor() {
}

void JamMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const JamMsg& JamMsg::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_JamMsg_perception_2eproto.base);
  return *internal_default_instance();
}


void JamMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:perception.JamMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  jam_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* JamMsg::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .perception.Jam jam = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_jam(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool JamMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:perception.JamMsg)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .perception.Jam jam = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_jam()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perception.JamMsg)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perception.JamMsg)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void JamMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perception.JamMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .perception.Jam jam = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->jam_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->jam(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:perception.JamMsg)
}

::google::protobuf::uint8* JamMsg::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:perception.JamMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .perception.Jam jam = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->jam_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->jam(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perception.JamMsg)
  return target;
}

size_t JamMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perception.JamMsg)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .perception.Jam jam = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->jam_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->jam(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void JamMsg::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:perception.JamMsg)
  GOOGLE_DCHECK_NE(&from, this);
  const JamMsg* source =
      ::google::protobuf::DynamicCastToGenerated<JamMsg>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:perception.JamMsg)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:perception.JamMsg)
    MergeFrom(*source);
  }
}

void JamMsg::MergeFrom(const JamMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perception.JamMsg)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  jam_.MergeFrom(from.jam_);
}

void JamMsg::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:perception.JamMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void JamMsg::CopyFrom(const JamMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perception.JamMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JamMsg::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->jam())) return false;
  return true;
}

void JamMsg::Swap(JamMsg* other) {
  if (other == this) return;
  InternalSwap(other);
}
void JamMsg::InternalSwap(JamMsg* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&jam_)->InternalSwap(CastToBase(&other->jam_));
}

::google::protobuf::Metadata JamMsg::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_perception_2eproto);
  return ::file_level_metadata_perception_2eproto[kIndexInFileMessages];
}


// ===================================================================

void FlowMsg::InitAsDefaultInstance() {
  ::perception::_FlowMsg_default_instance_._instance.get_mutable()->time_begin_ = const_cast< ::perception::Timestamp*>(
      ::perception::Timestamp::internal_default_instance());
  ::perception::_FlowMsg_default_instance_._instance.get_mutable()->time_end_ = const_cast< ::perception::Timestamp*>(
      ::perception::Timestamp::internal_default_instance());
}
class FlowMsg::HasBitSetters {
 public:
  static const ::perception::Timestamp& time_begin(const FlowMsg* msg);
  static void set_has_time_begin(FlowMsg* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::perception::Timestamp& time_end(const FlowMsg* msg);
  static void set_has_time_end(FlowMsg* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

const ::perception::Timestamp&
FlowMsg::HasBitSetters::time_begin(const FlowMsg* msg) {
  return *msg->time_begin_;
}
const ::perception::Timestamp&
FlowMsg::HasBitSetters::time_end(const FlowMsg* msg) {
  return *msg->time_end_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FlowMsg::kFlowFieldNumber;
const int FlowMsg::kTimeBeginFieldNumber;
const int FlowMsg::kTimeEndFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FlowMsg::FlowMsg()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perception.FlowMsg)
}
FlowMsg::FlowMsg(const FlowMsg& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      flow_(from.flow_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_time_begin()) {
    time_begin_ = new ::perception::Timestamp(*from.time_begin_);
  } else {
    time_begin_ = nullptr;
  }
  if (from.has_time_end()) {
    time_end_ = new ::perception::Timestamp(*from.time_end_);
  } else {
    time_end_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:perception.FlowMsg)
}

void FlowMsg::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_FlowMsg_perception_2eproto.base);
  ::memset(&time_begin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&time_end_) -
      reinterpret_cast<char*>(&time_begin_)) + sizeof(time_end_));
}

FlowMsg::~FlowMsg() {
  // @@protoc_insertion_point(destructor:perception.FlowMsg)
  SharedDtor();
}

void FlowMsg::SharedDtor() {
  if (this != internal_default_instance()) delete time_begin_;
  if (this != internal_default_instance()) delete time_end_;
}

void FlowMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FlowMsg& FlowMsg::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_FlowMsg_perception_2eproto.base);
  return *internal_default_instance();
}


void FlowMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:perception.FlowMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  flow_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(time_begin_ != nullptr);
      time_begin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(time_end_ != nullptr);
      time_end_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* FlowMsg::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .perception.Flow flow = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_flow(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      // optional .perception.Timestamp time_begin = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ctx->ParseMessage(mutable_time_begin(), ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .perception.Timestamp time_end = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ctx->ParseMessage(mutable_time_end(), ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool FlowMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:perception.FlowMsg)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .perception.Flow flow = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_flow()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .perception.Timestamp time_begin = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_time_begin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .perception.Timestamp time_end = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_time_end()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perception.FlowMsg)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perception.FlowMsg)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void FlowMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perception.FlowMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .perception.Flow flow = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->flow_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->flow(static_cast<int>(i)),
      output);
  }

  cached_has_bits = _has_bits_[0];
  // optional .perception.Timestamp time_begin = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::time_begin(this), output);
  }

  // optional .perception.Timestamp time_end = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::time_end(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:perception.FlowMsg)
}

::google::protobuf::uint8* FlowMsg::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:perception.FlowMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .perception.Flow flow = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->flow_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->flow(static_cast<int>(i)), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .perception.Timestamp time_begin = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::time_begin(this), target);
  }

  // optional .perception.Timestamp time_end = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::time_end(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perception.FlowMsg)
  return target;
}

size_t FlowMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perception.FlowMsg)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .perception.Flow flow = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->flow_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->flow(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .perception.Timestamp time_begin = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *time_begin_);
    }

    // optional .perception.Timestamp time_end = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *time_end_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FlowMsg::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:perception.FlowMsg)
  GOOGLE_DCHECK_NE(&from, this);
  const FlowMsg* source =
      ::google::protobuf::DynamicCastToGenerated<FlowMsg>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:perception.FlowMsg)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:perception.FlowMsg)
    MergeFrom(*source);
  }
}

void FlowMsg::MergeFrom(const FlowMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perception.FlowMsg)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  flow_.MergeFrom(from.flow_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_time_begin()->::perception::Timestamp::MergeFrom(from.time_begin());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_time_end()->::perception::Timestamp::MergeFrom(from.time_end());
    }
  }
}

void FlowMsg::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:perception.FlowMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FlowMsg::CopyFrom(const FlowMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perception.FlowMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlowMsg::IsInitialized() const {
  if (has_time_begin()) {
    if (!this->time_begin_->IsInitialized()) return false;
  }
  if (has_time_end()) {
    if (!this->time_end_->IsInitialized()) return false;
  }
  return true;
}

void FlowMsg::Swap(FlowMsg* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FlowMsg::InternalSwap(FlowMsg* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&flow_)->InternalSwap(CastToBase(&other->flow_));
  swap(time_begin_, other->time_begin_);
  swap(time_end_, other->time_end_);
}

::google::protobuf::Metadata FlowMsg::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_perception_2eproto);
  return ::file_level_metadata_perception_2eproto[kIndexInFileMessages];
}


// ===================================================================

void TargetMsg::InitAsDefaultInstance() {
}
class TargetMsg::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TargetMsg::kTargetFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TargetMsg::TargetMsg()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perception.TargetMsg)
}
TargetMsg::TargetMsg(const TargetMsg& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      target_(from.target_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:perception.TargetMsg)
}

void TargetMsg::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_TargetMsg_perception_2eproto.base);
}

TargetMsg::~TargetMsg() {
  // @@protoc_insertion_point(destructor:perception.TargetMsg)
  SharedDtor();
}

void TargetMsg::SharedDtor() {
}

void TargetMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TargetMsg& TargetMsg::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_TargetMsg_perception_2eproto.base);
  return *internal_default_instance();
}


void TargetMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:perception.TargetMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  target_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TargetMsg::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .perception.Target target = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ctx->ParseMessage(add_target(), ptr);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          if (ctx->Done(&ptr)) return ptr;
        } while ((::google::protobuf::internal::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TargetMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:perception.TargetMsg)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .perception.Target target = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_target()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perception.TargetMsg)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perception.TargetMsg)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TargetMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perception.TargetMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .perception.Target target = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->target_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->target(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:perception.TargetMsg)
}

::google::protobuf::uint8* TargetMsg::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:perception.TargetMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .perception.Target target = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->target_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->target(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perception.TargetMsg)
  return target;
}

size_t TargetMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perception.TargetMsg)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .perception.Target target = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->target_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->target(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TargetMsg::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:perception.TargetMsg)
  GOOGLE_DCHECK_NE(&from, this);
  const TargetMsg* source =
      ::google::protobuf::DynamicCastToGenerated<TargetMsg>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:perception.TargetMsg)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:perception.TargetMsg)
    MergeFrom(*source);
  }
}

void TargetMsg::MergeFrom(const TargetMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perception.TargetMsg)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  target_.MergeFrom(from.target_);
}

void TargetMsg::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:perception.TargetMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TargetMsg::CopyFrom(const TargetMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perception.TargetMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TargetMsg::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->target())) return false;
  return true;
}

void TargetMsg::Swap(TargetMsg* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TargetMsg::InternalSwap(TargetMsg* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&target_)->InternalSwap(CastToBase(&other->target_));
}

::google::protobuf::Metadata TargetMsg::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_perception_2eproto);
  return ::file_level_metadata_perception_2eproto[kIndexInFileMessages];
}


// ===================================================================

void WarnMsg::InitAsDefaultInstance() {
}
class WarnMsg::HasBitSetters {
 public:
  static void set_has_warn(WarnMsg* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int WarnMsg::kWarnFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

WarnMsg::WarnMsg()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perception.WarnMsg)
}
WarnMsg::WarnMsg(const WarnMsg& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  warn_ = from.warn_;
  // @@protoc_insertion_point(copy_constructor:perception.WarnMsg)
}

void WarnMsg::SharedCtor() {
  warn_ = false;
}

WarnMsg::~WarnMsg() {
  // @@protoc_insertion_point(destructor:perception.WarnMsg)
  SharedDtor();
}

void WarnMsg::SharedDtor() {
}

void WarnMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const WarnMsg& WarnMsg::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_WarnMsg_perception_2eproto.base);
  return *internal_default_instance();
}


void WarnMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:perception.WarnMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  warn_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* WarnMsg::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required bool warn = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        set_warn(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool WarnMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:perception.WarnMsg)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool warn = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_warn(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &warn_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perception.WarnMsg)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perception.WarnMsg)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void WarnMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perception.WarnMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool warn = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->warn(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:perception.WarnMsg)
}

::google::protobuf::uint8* WarnMsg::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:perception.WarnMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool warn = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->warn(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perception.WarnMsg)
  return target;
}

size_t WarnMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perception.WarnMsg)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required bool warn = 1;
  if (has_warn()) {
    total_size += 1 + 1;
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WarnMsg::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:perception.WarnMsg)
  GOOGLE_DCHECK_NE(&from, this);
  const WarnMsg* source =
      ::google::protobuf::DynamicCastToGenerated<WarnMsg>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:perception.WarnMsg)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:perception.WarnMsg)
    MergeFrom(*source);
  }
}

void WarnMsg::MergeFrom(const WarnMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perception.WarnMsg)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_warn()) {
    set_warn(from.warn());
  }
}

void WarnMsg::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:perception.WarnMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WarnMsg::CopyFrom(const WarnMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perception.WarnMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WarnMsg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void WarnMsg::Swap(WarnMsg* other) {
  if (other == this) return;
  InternalSwap(other);
}
void WarnMsg::InternalSwap(WarnMsg* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(warn_, other->warn_);
}

::google::protobuf::Metadata WarnMsg::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_perception_2eproto);
  return ::file_level_metadata_perception_2eproto[kIndexInFileMessages];
}


// ===================================================================

void PerceptionMsg::InitAsDefaultInstance() {
  ::perception::_PerceptionMsg_default_instance_.warn_msg_ = const_cast< ::perception::WarnMsg*>(
      ::perception::WarnMsg::internal_default_instance());
  ::perception::_PerceptionMsg_default_instance_.visibility_msg_ = const_cast< ::perception::VisibilityMsg*>(
      ::perception::VisibilityMsg::internal_default_instance());
  ::perception::_PerceptionMsg_default_instance_.lane_area_msg_ = const_cast< ::perception::LaneAreaMsg*>(
      ::perception::LaneAreaMsg::internal_default_instance());
  ::perception::_PerceptionMsg_default_instance_.jam_msg_ = const_cast< ::perception::JamMsg*>(
      ::perception::JamMsg::internal_default_instance());
  ::perception::_PerceptionMsg_default_instance_.flow_msg_ = const_cast< ::perception::FlowMsg*>(
      ::perception::FlowMsg::internal_default_instance());
  ::perception::_PerceptionMsg_default_instance_.target_msg_ = const_cast< ::perception::TargetMsg*>(
      ::perception::TargetMsg::internal_default_instance());
  ::perception::_PerceptionMsg_default_instance_._instance.get_mutable()->time_ = const_cast< ::perception::Timestamp*>(
      ::perception::Timestamp::internal_default_instance());
}
class PerceptionMsg::HasBitSetters {
 public:
  static void set_has_event(PerceptionMsg* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::perception::WarnMsg& warn_msg(const PerceptionMsg* msg);
  static const ::perception::VisibilityMsg& visibility_msg(const PerceptionMsg* msg);
  static const ::perception::LaneAreaMsg& lane_area_msg(const PerceptionMsg* msg);
  static const ::perception::JamMsg& jam_msg(const PerceptionMsg* msg);
  static const ::perception::FlowMsg& flow_msg(const PerceptionMsg* msg);
  static const ::perception::TargetMsg& target_msg(const PerceptionMsg* msg);
  static const ::perception::Timestamp& time(const PerceptionMsg* msg);
  static void set_has_time(PerceptionMsg* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

const ::perception::WarnMsg&
PerceptionMsg::HasBitSetters::warn_msg(const PerceptionMsg* msg) {
  return *msg->MsgType_.warn_msg_;
}
const ::perception::VisibilityMsg&
PerceptionMsg::HasBitSetters::visibility_msg(const PerceptionMsg* msg) {
  return *msg->MsgType_.visibility_msg_;
}
const ::perception::LaneAreaMsg&
PerceptionMsg::HasBitSetters::lane_area_msg(const PerceptionMsg* msg) {
  return *msg->MsgType_.lane_area_msg_;
}
const ::perception::JamMsg&
PerceptionMsg::HasBitSetters::jam_msg(const PerceptionMsg* msg) {
  return *msg->MsgType_.jam_msg_;
}
const ::perception::FlowMsg&
PerceptionMsg::HasBitSetters::flow_msg(const PerceptionMsg* msg) {
  return *msg->MsgType_.flow_msg_;
}
const ::perception::TargetMsg&
PerceptionMsg::HasBitSetters::target_msg(const PerceptionMsg* msg) {
  return *msg->MsgType_.target_msg_;
}
const ::perception::Timestamp&
PerceptionMsg::HasBitSetters::time(const PerceptionMsg* msg) {
  return *msg->time_;
}
void PerceptionMsg::set_allocated_warn_msg(::perception::WarnMsg* warn_msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_MsgType();
  if (warn_msg) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      warn_msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, warn_msg, submessage_arena);
    }
    set_has_warn_msg();
    MsgType_.warn_msg_ = warn_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:perception.PerceptionMsg.warn_msg)
}
void PerceptionMsg::set_allocated_visibility_msg(::perception::VisibilityMsg* visibility_msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_MsgType();
  if (visibility_msg) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      visibility_msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, visibility_msg, submessage_arena);
    }
    set_has_visibility_msg();
    MsgType_.visibility_msg_ = visibility_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:perception.PerceptionMsg.visibility_msg)
}
void PerceptionMsg::set_allocated_lane_area_msg(::perception::LaneAreaMsg* lane_area_msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_MsgType();
  if (lane_area_msg) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      lane_area_msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lane_area_msg, submessage_arena);
    }
    set_has_lane_area_msg();
    MsgType_.lane_area_msg_ = lane_area_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:perception.PerceptionMsg.lane_area_msg)
}
void PerceptionMsg::set_allocated_jam_msg(::perception::JamMsg* jam_msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_MsgType();
  if (jam_msg) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      jam_msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, jam_msg, submessage_arena);
    }
    set_has_jam_msg();
    MsgType_.jam_msg_ = jam_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:perception.PerceptionMsg.jam_msg)
}
void PerceptionMsg::set_allocated_flow_msg(::perception::FlowMsg* flow_msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_MsgType();
  if (flow_msg) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      flow_msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, flow_msg, submessage_arena);
    }
    set_has_flow_msg();
    MsgType_.flow_msg_ = flow_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:perception.PerceptionMsg.flow_msg)
}
void PerceptionMsg::set_allocated_target_msg(::perception::TargetMsg* target_msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_MsgType();
  if (target_msg) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      target_msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, target_msg, submessage_arena);
    }
    set_has_target_msg();
    MsgType_.target_msg_ = target_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:perception.PerceptionMsg.target_msg)
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PerceptionMsg::kEventFieldNumber;
const int PerceptionMsg::kWarnMsgFieldNumber;
const int PerceptionMsg::kVisibilityMsgFieldNumber;
const int PerceptionMsg::kLaneAreaMsgFieldNumber;
const int PerceptionMsg::kJamMsgFieldNumber;
const int PerceptionMsg::kFlowMsgFieldNumber;
const int PerceptionMsg::kTargetMsgFieldNumber;
const int PerceptionMsg::kTimeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PerceptionMsg::PerceptionMsg()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perception.PerceptionMsg)
}
PerceptionMsg::PerceptionMsg(const PerceptionMsg& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_time()) {
    time_ = new ::perception::Timestamp(*from.time_);
  } else {
    time_ = nullptr;
  }
  event_ = from.event_;
  clear_has_MsgType();
  switch (from.MsgType_case()) {
    case kWarnMsg: {
      mutable_warn_msg()->::perception::WarnMsg::MergeFrom(from.warn_msg());
      break;
    }
    case kVisibilityMsg: {
      mutable_visibility_msg()->::perception::VisibilityMsg::MergeFrom(from.visibility_msg());
      break;
    }
    case kLaneAreaMsg: {
      mutable_lane_area_msg()->::perception::LaneAreaMsg::MergeFrom(from.lane_area_msg());
      break;
    }
    case kJamMsg: {
      mutable_jam_msg()->::perception::JamMsg::MergeFrom(from.jam_msg());
      break;
    }
    case kFlowMsg: {
      mutable_flow_msg()->::perception::FlowMsg::MergeFrom(from.flow_msg());
      break;
    }
    case kTargetMsg: {
      mutable_target_msg()->::perception::TargetMsg::MergeFrom(from.target_msg());
      break;
    }
    case MSGTYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:perception.PerceptionMsg)
}

void PerceptionMsg::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_PerceptionMsg_perception_2eproto.base);
  ::memset(&time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&event_) -
      reinterpret_cast<char*>(&time_)) + sizeof(event_));
  clear_has_MsgType();
}

PerceptionMsg::~PerceptionMsg() {
  // @@protoc_insertion_point(destructor:perception.PerceptionMsg)
  SharedDtor();
}

void PerceptionMsg::SharedDtor() {
  if (this != internal_default_instance()) delete time_;
  if (has_MsgType()) {
    clear_MsgType();
  }
}

void PerceptionMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PerceptionMsg& PerceptionMsg::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_PerceptionMsg_perception_2eproto.base);
  return *internal_default_instance();
}


void PerceptionMsg::clear_MsgType() {
// @@protoc_insertion_point(one_of_clear_start:perception.PerceptionMsg)
  switch (MsgType_case()) {
    case kWarnMsg: {
      delete MsgType_.warn_msg_;
      break;
    }
    case kVisibilityMsg: {
      delete MsgType_.visibility_msg_;
      break;
    }
    case kLaneAreaMsg: {
      delete MsgType_.lane_area_msg_;
      break;
    }
    case kJamMsg: {
      delete MsgType_.jam_msg_;
      break;
    }
    case kFlowMsg: {
      delete MsgType_.flow_msg_;
      break;
    }
    case kTargetMsg: {
      delete MsgType_.target_msg_;
      break;
    }
    case MSGTYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = MSGTYPE_NOT_SET;
}


void PerceptionMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:perception.PerceptionMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(time_ != nullptr);
    time_->Clear();
  }
  event_ = 0;
  clear_MsgType();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PerceptionMsg::_InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) {
  while (!ctx->Done(&ptr)) {
    ::google::protobuf::uint32 tag;
    ptr = ::google::protobuf::internal::ReadTag(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .perception.EventId event = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::perception::EventId_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, mutable_unknown_fields());
          break;
        }
        set_event(static_cast<::perception::EventId>(val));
        break;
      }
      // optional .perception.WarnMsg warn_msg = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ctx->ParseMessage(mutable_warn_msg(), ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .perception.VisibilityMsg visibility_msg = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ctx->ParseMessage(mutable_visibility_msg(), ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .perception.LaneAreaMsg lane_area_msg = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ctx->ParseMessage(mutable_lane_area_msg(), ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .perception.JamMsg jam_msg = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = ctx->ParseMessage(mutable_jam_msg(), ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .perception.FlowMsg flow_msg = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ctx->ParseMessage(mutable_flow_msg(), ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .perception.TargetMsg target_msg = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ctx->ParseMessage(mutable_target_msg(), ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .perception.Timestamp time = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 66) goto handle_unusual;
        ptr = ctx->ParseMessage(mutable_time(), ptr);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          return ptr;
        }
        ptr = UnknownFieldParse(tag,
          _internal_metadata_.mutable_unknown_fields(), ptr, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        break;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PerceptionMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:perception.PerceptionMsg)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .perception.EventId event = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perception::EventId_IsValid(value)) {
            set_event(static_cast< ::perception::EventId >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .perception.WarnMsg warn_msg = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_warn_msg()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .perception.VisibilityMsg visibility_msg = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_visibility_msg()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .perception.LaneAreaMsg lane_area_msg = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_lane_area_msg()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .perception.JamMsg jam_msg = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_jam_msg()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .perception.FlowMsg flow_msg = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_flow_msg()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .perception.TargetMsg target_msg = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_target_msg()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .perception.Timestamp time = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (66 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_time()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perception.PerceptionMsg)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perception.PerceptionMsg)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PerceptionMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perception.PerceptionMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .perception.EventId event = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->event(), output);
  }

  switch (MsgType_case()) {
    case kWarnMsg:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        2, HasBitSetters::warn_msg(this), output);
      break;
    case kVisibilityMsg:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        3, HasBitSetters::visibility_msg(this), output);
      break;
    case kLaneAreaMsg:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        4, HasBitSetters::lane_area_msg(this), output);
      break;
    case kJamMsg:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        5, HasBitSetters::jam_msg(this), output);
      break;
    case kFlowMsg:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        6, HasBitSetters::flow_msg(this), output);
      break;
    case kTargetMsg:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        7, HasBitSetters::target_msg(this), output);
      break;
    default: ;
  }
  // optional .perception.Timestamp time = 8;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, HasBitSetters::time(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:perception.PerceptionMsg)
}

::google::protobuf::uint8* PerceptionMsg::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:perception.PerceptionMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .perception.EventId event = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->event(), target);
  }

  switch (MsgType_case()) {
    case kWarnMsg:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          2, HasBitSetters::warn_msg(this), target);
      break;
    case kVisibilityMsg:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          3, HasBitSetters::visibility_msg(this), target);
      break;
    case kLaneAreaMsg:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          4, HasBitSetters::lane_area_msg(this), target);
      break;
    case kJamMsg:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          5, HasBitSetters::jam_msg(this), target);
      break;
    case kFlowMsg:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          6, HasBitSetters::flow_msg(this), target);
      break;
    case kTargetMsg:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageToArray(
          7, HasBitSetters::target_msg(this), target);
      break;
    default: ;
  }
  // optional .perception.Timestamp time = 8;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        8, HasBitSetters::time(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perception.PerceptionMsg)
  return target;
}

size_t PerceptionMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perception.PerceptionMsg)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .perception.EventId event = 1;
  if (has_event()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->event());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .perception.Timestamp time = 8;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *time_);
  }

  switch (MsgType_case()) {
    // optional .perception.WarnMsg warn_msg = 2;
    case kWarnMsg: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *MsgType_.warn_msg_);
      break;
    }
    // optional .perception.VisibilityMsg visibility_msg = 3;
    case kVisibilityMsg: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *MsgType_.visibility_msg_);
      break;
    }
    // optional .perception.LaneAreaMsg lane_area_msg = 4;
    case kLaneAreaMsg: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *MsgType_.lane_area_msg_);
      break;
    }
    // optional .perception.JamMsg jam_msg = 5;
    case kJamMsg: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *MsgType_.jam_msg_);
      break;
    }
    // optional .perception.FlowMsg flow_msg = 6;
    case kFlowMsg: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *MsgType_.flow_msg_);
      break;
    }
    // optional .perception.TargetMsg target_msg = 7;
    case kTargetMsg: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *MsgType_.target_msg_);
      break;
    }
    case MSGTYPE_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PerceptionMsg::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:perception.PerceptionMsg)
  GOOGLE_DCHECK_NE(&from, this);
  const PerceptionMsg* source =
      ::google::protobuf::DynamicCastToGenerated<PerceptionMsg>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:perception.PerceptionMsg)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:perception.PerceptionMsg)
    MergeFrom(*source);
  }
}

void PerceptionMsg::MergeFrom(const PerceptionMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perception.PerceptionMsg)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_time()->::perception::Timestamp::MergeFrom(from.time());
    }
    if (cached_has_bits & 0x00000002u) {
      event_ = from.event_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.MsgType_case()) {
    case kWarnMsg: {
      mutable_warn_msg()->::perception::WarnMsg::MergeFrom(from.warn_msg());
      break;
    }
    case kVisibilityMsg: {
      mutable_visibility_msg()->::perception::VisibilityMsg::MergeFrom(from.visibility_msg());
      break;
    }
    case kLaneAreaMsg: {
      mutable_lane_area_msg()->::perception::LaneAreaMsg::MergeFrom(from.lane_area_msg());
      break;
    }
    case kJamMsg: {
      mutable_jam_msg()->::perception::JamMsg::MergeFrom(from.jam_msg());
      break;
    }
    case kFlowMsg: {
      mutable_flow_msg()->::perception::FlowMsg::MergeFrom(from.flow_msg());
      break;
    }
    case kTargetMsg: {
      mutable_target_msg()->::perception::TargetMsg::MergeFrom(from.target_msg());
      break;
    }
    case MSGTYPE_NOT_SET: {
      break;
    }
  }
}

void PerceptionMsg::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:perception.PerceptionMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PerceptionMsg::CopyFrom(const PerceptionMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perception.PerceptionMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PerceptionMsg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (has_time()) {
    if (!this->time_->IsInitialized()) return false;
  }
  switch (MsgType_case()) {
    case kWarnMsg: {
      if (has_warn_msg()) {
        if (!this->warn_msg().IsInitialized()) return false;
      }
      break;
    }
    case kVisibilityMsg: {
      if (has_visibility_msg()) {
        if (!this->visibility_msg().IsInitialized()) return false;
      }
      break;
    }
    case kLaneAreaMsg: {
      if (has_lane_area_msg()) {
        if (!this->lane_area_msg().IsInitialized()) return false;
      }
      break;
    }
    case kJamMsg: {
      if (has_jam_msg()) {
        if (!this->jam_msg().IsInitialized()) return false;
      }
      break;
    }
    case kFlowMsg: {
      if (has_flow_msg()) {
        if (!this->flow_msg().IsInitialized()) return false;
      }
      break;
    }
    case kTargetMsg: {
      if (has_target_msg()) {
        if (!this->target_msg().IsInitialized()) return false;
      }
      break;
    }
    case MSGTYPE_NOT_SET: {
      break;
    }
  }
  return true;
}

void PerceptionMsg::Swap(PerceptionMsg* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PerceptionMsg::InternalSwap(PerceptionMsg* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(time_, other->time_);
  swap(event_, other->event_);
  swap(MsgType_, other->MsgType_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::google::protobuf::Metadata PerceptionMsg::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_perception_2eproto);
  return ::file_level_metadata_perception_2eproto[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace perception
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::perception::Position* Arena::CreateMaybeMessage< ::perception::Position >(Arena* arena) {
  return Arena::CreateInternal< ::perception::Position >(arena);
}
template<> PROTOBUF_NOINLINE ::perception::Timestamp* Arena::CreateMaybeMessage< ::perception::Timestamp >(Arena* arena) {
  return Arena::CreateInternal< ::perception::Timestamp >(arena);
}
template<> PROTOBUF_NOINLINE ::perception::Size* Arena::CreateMaybeMessage< ::perception::Size >(Arena* arena) {
  return Arena::CreateInternal< ::perception::Size >(arena);
}
template<> PROTOBUF_NOINLINE ::perception::LaneInfoEx* Arena::CreateMaybeMessage< ::perception::LaneInfoEx >(Arena* arena) {
  return Arena::CreateInternal< ::perception::LaneInfoEx >(arena);
}
template<> PROTOBUF_NOINLINE ::perception::LaneArea* Arena::CreateMaybeMessage< ::perception::LaneArea >(Arena* arena) {
  return Arena::CreateInternal< ::perception::LaneArea >(arena);
}
template<> PROTOBUF_NOINLINE ::perception::Jam* Arena::CreateMaybeMessage< ::perception::Jam >(Arena* arena) {
  return Arena::CreateInternal< ::perception::Jam >(arena);
}
template<> PROTOBUF_NOINLINE ::perception::Flow* Arena::CreateMaybeMessage< ::perception::Flow >(Arena* arena) {
  return Arena::CreateInternal< ::perception::Flow >(arena);
}
template<> PROTOBUF_NOINLINE ::perception::Target* Arena::CreateMaybeMessage< ::perception::Target >(Arena* arena) {
  return Arena::CreateInternal< ::perception::Target >(arena);
}
template<> PROTOBUF_NOINLINE ::perception::VisibilityMsg* Arena::CreateMaybeMessage< ::perception::VisibilityMsg >(Arena* arena) {
  return Arena::CreateInternal< ::perception::VisibilityMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::perception::LaneAreaMsg* Arena::CreateMaybeMessage< ::perception::LaneAreaMsg >(Arena* arena) {
  return Arena::CreateInternal< ::perception::LaneAreaMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::perception::JamMsg* Arena::CreateMaybeMessage< ::perception::JamMsg >(Arena* arena) {
  return Arena::CreateInternal< ::perception::JamMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::perception::FlowMsg* Arena::CreateMaybeMessage< ::perception::FlowMsg >(Arena* arena) {
  return Arena::CreateInternal< ::perception::FlowMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::perception::TargetMsg* Arena::CreateMaybeMessage< ::perception::TargetMsg >(Arena* arena) {
  return Arena::CreateInternal< ::perception::TargetMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::perception::WarnMsg* Arena::CreateMaybeMessage< ::perception::WarnMsg >(Arena* arena) {
  return Arena::CreateInternal< ::perception::WarnMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::perception::PerceptionMsg* Arena::CreateMaybeMessage< ::perception::PerceptionMsg >(Arena* arena) {
  return Arena::CreateInternal< ::perception::PerceptionMsg >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
